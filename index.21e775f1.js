/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */let e,t,i;const n={ROTATE:0,DOLLY:1,PAN:2},r={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},s="srgb",a="srgb-linear",o="300 es";/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */class l{addEventListener(e,t){void 0===this._listeners&&(this._listeners={});let i=this._listeners;void 0===i[e]&&(i[e]=[]),-1===i[e].indexOf(t)&&i[e].push(t)}hasEventListener(e,t){if(void 0===this._listeners)return!1;let i=this._listeners;return void 0!==i[e]&&-1!==i[e].indexOf(t)}removeEventListener(e,t){if(void 0===this._listeners)return;let i=this._listeners,n=i[e];if(void 0!==n){let e=n.indexOf(t);-1!==e&&n.splice(e,1)}}dispatchEvent(e){if(void 0===this._listeners)return;let t=this._listeners,i=t[e.type];if(void 0!==i){e.target=this;// Make a copy, in case listeners are removed while iterating.
let t=i.slice(0);for(let i=0,n=t.length;i<n;i++)t[i].call(this,e);e.target=null}}}const h=[];for(let e=0;e<256;e++)h[e]=(e<16?"0":"")+e.toString(16);let u=1234567;const c=Math.PI/180,d=180/Math.PI;// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function p(){let e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,i=4294967295*Math.random()|0,n=4294967295*Math.random()|0,r=h[255&e]+h[e>>8&255]+h[e>>16&255]+h[e>>24&255]+"-"+h[255&t]+h[t>>8&255]+"-"+h[t>>16&15|64]+h[t>>24&255]+"-"+h[63&i|128]+h[i>>8&255]+"-"+h[i>>16&255]+h[i>>24&255]+h[255&n]+h[n>>8&255]+h[n>>16&255]+h[n>>24&255];// .toLowerCase() here flattens concatenated strings to save heap memory space.
return r.toLowerCase()}function m(e,t,i){return Math.max(t,Math.min(i,e))}// compute euclidean modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function f(e,t){return(e%t+t)%t}// https://en.wikipedia.org/wiki/Linear_interpolation
function g(e,t,i){return(1-i)*e+i*t}function v(e){return(e&e-1)==0&&0!==e}function x(e){return Math.pow(2,Math.ceil(Math.log(e)/Math.LN2))}function y(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))}var _=/*#__PURE__*/Object.freeze({__proto__:null,DEG2RAD:c,RAD2DEG:d,generateUUID:p,clamp:m,euclideanModulo:f,mapLinear:// Linear mapping from range <a1, a2> to range <b1, b2>
function(e,t,i,n,r){return n+(e-t)*(r-n)/(i-t)},inverseLerp:// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
function(e,t,i){return e!==t?(i-e)/(t-e):0},lerp:g,damp:// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
function(e,t,i,n){return g(e,t,1-Math.exp(-i*n))},pingpong:// https://www.desmos.com/calculator/vcsjnyz7x4
function(e,t=1){return t-Math.abs(f(e,2*t)-t)},smoothstep:// http://en.wikipedia.org/wiki/Smoothstep
function(e,t,i){return e<=t?0:e>=i?1:(e=(e-t)/(i-t))*e*(3-2*e)},smootherstep:function(e,t,i){return e<=t?0:e>=i?1:(e=(e-t)/(i-t))*e*e*(e*(6*e-15)+10)},randInt:// Random integer from <low, high> interval
function(e,t){return e+Math.floor(Math.random()*(t-e+1))},randFloat:// Random float from <low, high> interval
function(e,t){return e+Math.random()*(t-e)},randFloatSpread:// Random float from <-range/2, range/2> interval
function(e){return e*(.5-Math.random())},seededRandom:// Deterministic pseudo-random float in the interval [ 0, 1 ]
function(e){void 0!==e&&(u=e);// Mulberry32 generator
let t=u+=1831565813;return t=Math.imul(t^t>>>15,1|t),(((t^=t+Math.imul(t^t>>>7,61|t))^t>>>14)>>>0)/4294967296},degToRad:function(e){return e*c},radToDeg:function(e){return e*d},isPowerOfTwo:v,ceilPowerOfTwo:x,floorPowerOfTwo:y,setQuaternionFromProperEuler:function(e,t,i,n,r){// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
// rotations are applied to the axes in the order specified by 'order'
// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
// angles are in radians
let s=Math.cos,a=Math.sin,o=s(i/2),l=a(i/2),h=s((t+n)/2),u=a((t+n)/2),c=s((t-n)/2),d=a((t-n)/2),p=s((n-t)/2),m=a((n-t)/2);switch(r){case"XYX":e.set(o*u,l*c,l*d,o*h);break;case"YZY":e.set(l*d,o*u,l*c,o*h);break;case"ZXZ":e.set(l*c,l*d,o*u,o*h);break;case"XZX":e.set(o*u,l*m,l*p,o*h);break;case"YXY":e.set(l*p,o*u,l*m,o*h);break;case"ZYZ":e.set(l*m,l*p,o*u,o*h);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}},normalize:function(e,t){switch(t.constructor){case Float32Array:return e;case Uint16Array:return Math.round(65535*e);case Uint8Array:return Math.round(255*e);case Int16Array:return Math.round(32767*e);case Int8Array:return Math.round(127*e);default:throw Error("Invalid component type.")}},denormalize:function(e,t){switch(t.constructor){case Float32Array:return e;case Uint16Array:return e/65535;case Uint8Array:return e/255;case Int16Array:return Math.max(e/32767,-1);case Int8Array:return Math.max(e/127,-1);default:throw Error("Invalid component type.")}}});class b{constructor(e=0,t=0){this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return void 0!==t?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return void 0!==t?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){let t=this.x,i=this.y,n=e.elements;return this.x=n[0]*t+n[3]*i+n[6],this.y=n[1]*t+n[4]*i+n[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return(// assumes min < max, componentwise
this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this)}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){let i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){// computes the angle in radians with respect to the positive x-axis
let e=Math.atan2(-this.y,-this.x)+Math.PI;return e}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){let t=this.x-e.x,i=this.y-e.y;return t*t+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,i){return void 0!==i&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){let i=Math.cos(t),n=Math.sin(t),r=this.x-e.x,s=this.y-e.y;return this.x=r*i-s*n+e.x,this.y=r*n+s*i+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}b.prototype.isVector2=!0;class M{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,i,n,r,s,a,o,l){let h=this.elements;return h[0]=e,h[1]=n,h[2]=a,h[3]=t,h[4]=r,h[5]=o,h[6]=i,h[7]=s,h[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){let t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],this}extractBasis(e,t,i){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(e){let t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){let i=e.elements,n=t.elements,r=this.elements,s=i[0],a=i[3],o=i[6],l=i[1],h=i[4],u=i[7],c=i[2],d=i[5],p=i[8],m=n[0],f=n[3],g=n[6],v=n[1],x=n[4],y=n[7],_=n[2],b=n[5],M=n[8];return r[0]=s*m+a*v+o*_,r[3]=s*f+a*x+o*b,r[6]=s*g+a*y+o*M,r[1]=l*m+h*v+u*_,r[4]=l*f+h*x+u*b,r[7]=l*g+h*y+u*M,r[2]=c*m+d*v+p*_,r[5]=c*f+d*x+p*b,r[8]=c*g+d*y+p*M,this}multiplyScalar(e){let t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){let e=this.elements,t=e[0],i=e[1],n=e[2],r=e[3],s=e[4],a=e[5],o=e[6],l=e[7],h=e[8];return t*s*h-t*a*l-i*r*h+i*a*o+n*r*l-n*s*o}invert(){let e=this.elements,t=e[0],i=e[1],n=e[2],r=e[3],s=e[4],a=e[5],o=e[6],l=e[7],h=e[8],u=h*s-a*l,c=a*o-h*r,d=l*r-s*o,p=t*u+i*c+n*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);let m=1/p;return e[0]=u*m,e[1]=(n*l-h*i)*m,e[2]=(a*i-n*s)*m,e[3]=c*m,e[4]=(h*t-n*o)*m,e[5]=(n*r-a*t)*m,e[6]=d*m,e[7]=(i*o-l*t)*m,e[8]=(s*t-i*r)*m,this}transpose(){let e;let t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){let t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,i,n,r,s,a){let o=Math.cos(r),l=Math.sin(r);return this.set(i*o,i*l,-i*(o*s+l*a)+s+e,-n*l,n*o,-n*(-l*s+o*a)+a+t,0,0,1),this}scale(e,t){let i=this.elements;return i[0]*=e,i[3]*=e,i[6]*=e,i[1]*=t,i[4]*=t,i[7]*=t,this}rotate(e){let t=Math.cos(e),i=Math.sin(e),n=this.elements,r=n[0],s=n[3],a=n[6],o=n[1],l=n[4],h=n[7];return n[0]=t*r+i*o,n[3]=t*s+i*l,n[6]=t*a+i*h,n[1]=-i*r+t*o,n[4]=-i*s+t*l,n[7]=-i*a+t*h,this}translate(e,t){let i=this.elements;return i[0]+=e*i[2],i[3]+=e*i[5],i[6]+=e*i[8],i[1]+=t*i[2],i[4]+=t*i[5],i[7]+=t*i[8],this}equals(e){let t=this.elements,i=e.elements;for(let e=0;e<9;e++)if(t[e]!==i[e])return!1;return!0}fromArray(e,t=0){for(let i=0;i<9;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){let i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e}clone(){return new this.constructor().fromArray(this.elements)}}function w(e){// assumes larger values usually on last
for(let t=e.length-1;t>=0;--t)if(e[t]>65535)return!0;return!1}function S(e){return document.createElementNS("http://www.w3.org/1999/xhtml",e)}function T(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}function E(e){return e<.0031308?12.92*e:1.055*Math.pow(e,.41666)-.055}M.prototype.isMatrix3=!0,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array;// JavaScript RGB-to-RGB transforms, defined as
// FN[InputColorSpace][OutputColorSpace] callback functions.
const A={[s]:{[a]:T},[a]:{[s]:E}},R={legacyMode:!0,get workingColorSpace(){return a},set workingColorSpace(colorSpace){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(e,t,i){if(this.legacyMode||t===i||!t||!i)return e;if(A[t]&&void 0!==A[t][i]){let n=A[t][i];return e.r=n(e.r),e.g=n(e.g),e.b=n(e.b),e}throw Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(e,t){return this.convert(e,this.workingColorSpace,t)},toWorkingColorSpace:function(e,t){return this.convert(e,t,this.workingColorSpace)}},L={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},C={r:0,g:0,b:0},P={h:0,s:0,l:0},I={h:0,s:0,l:0};function D(e,t,i){return(i<0&&(i+=1),i>1&&(i-=1),i<1/6)?e+(t-e)*6*i:i<.5?t:i<2/3?e+(t-e)*6*(2/3-i):e}function N(e,t){return t.r=e.r,t.g=e.g,t.b=e.b,t}class O{constructor(e,t,i){if(void 0===t&&void 0===i)return this.set(e);return this.setRGB(e,t,i)}set(e){return e&&e.isColor?this.copy(e):"number"==typeof e?this.setHex(e):"string"==typeof e&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=s){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(255&e)/255,R.toWorkingColorSpace(this,t),this}setRGB(e,t,i,n=a){return this.r=e,this.g=t,this.b=i,R.toWorkingColorSpace(this,n),this}setHSL(e,t,i,n=a){if(// h,s,l ranges are in 0.0 - 1.0
e=f(e,1),t=m(t,0,1),i=m(i,0,1),0===t)this.r=this.g=this.b=i;else{let n=i<=.5?i*(1+t):i+t-i*t,r=2*i-n;this.r=D(r,n,e+1/3),this.g=D(r,n,e),this.b=D(r,n,e-1/3)}return R.toWorkingColorSpace(this,n),this}setStyle(e,t=s){let i;function n(t){void 0!==t&&1>parseFloat(t)&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}if(i=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let e;let r=i[1],s=i[2];switch(r){case"rgb":case"rgba":if(e=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return(// rgb(255,0,0) rgba(255,0,0,0.5)
this.r=Math.min(255,parseInt(e[1],10))/255,this.g=Math.min(255,parseInt(e[2],10))/255,this.b=Math.min(255,parseInt(e[3],10))/255,R.toWorkingColorSpace(this,t),n(e[4]),this);if(e=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return(// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
this.r=Math.min(100,parseInt(e[1],10))/100,this.g=Math.min(100,parseInt(e[2],10))/100,this.b=Math.min(100,parseInt(e[3],10))/100,R.toWorkingColorSpace(this,t),n(e[4]),this);break;case"hsl":case"hsla":if(e=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)){// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
let i=parseFloat(e[1])/360,r=parseInt(e[2],10)/100,s=parseInt(e[3],10)/100;return n(e[4]),this.setHSL(i,r,s,t)}}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){// hex color
let e=i[1],n=e.length;if(3===n)return(// #ff0
this.r=parseInt(e.charAt(0)+e.charAt(0),16)/255,this.g=parseInt(e.charAt(1)+e.charAt(1),16)/255,this.b=parseInt(e.charAt(2)+e.charAt(2),16)/255,R.toWorkingColorSpace(this,t),this);if(6===n)return(// #ff0000
this.r=parseInt(e.charAt(0)+e.charAt(1),16)/255,this.g=parseInt(e.charAt(2)+e.charAt(3),16)/255,this.b=parseInt(e.charAt(4)+e.charAt(5),16)/255,R.toWorkingColorSpace(this,t),this)}return e&&e.length>0?this.setColorName(e,t):this}setColorName(e,t=s){// color keywords
let i=L[e.toLowerCase()];return void 0!==i?this.setHex(i,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=T(e.r),this.g=T(e.g),this.b=T(e.b),this}copyLinearToSRGB(e){return this.r=E(e.r),this.g=E(e.g),this.b=E(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=s){return R.fromWorkingColorSpace(N(this,C),e),m(255*C.r,0,255)<<16^m(255*C.g,0,255)<<8^m(255*C.b,0,255)<<0}getHexString(e=s){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=a){let i,n;// h,s,l ranges are in 0.0 - 1.0
R.fromWorkingColorSpace(N(this,C),t);let r=C.r,s=C.g,o=C.b,l=Math.max(r,s,o),h=Math.min(r,s,o),u=(h+l)/2;if(h===l)i=0,n=0;else{let e=l-h;switch(n=u<=.5?e/(l+h):e/(2-l-h),l){case r:i=(s-o)/e+(s<o?6:0);break;case s:i=(o-r)/e+2;break;case o:i=(r-s)/e+4}i/=6}return e.h=i,e.s=n,e.l=u,e}getRGB(e,t=a){return R.fromWorkingColorSpace(N(this,C),t),e.r=C.r,e.g=C.g,e.b=C.b,e}getStyle(e=s){return(R.fromWorkingColorSpace(N(this,C),e),e!==s)?`color(${e} ${C.r} ${C.g} ${C.b})`:`rgb(${255*C.r|0},${255*C.g|0},${255*C.b|0})`}offsetHSL(e,t,i){return this.getHSL(P),P.h+=e,P.s+=t,P.l+=i,this.setHSL(P.h,P.s,P.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,i){return this.r=e.r+(t.r-e.r)*i,this.g=e.g+(t.g-e.g)*i,this.b=e.b+(t.b-e.b)*i,this}lerpHSL(e,t){this.getHSL(P),e.getHSL(I);let i=g(P.h,I.h,t),n=g(P.s,I.s,t),r=g(P.l,I.l,t);return this.setHSL(i,n,r),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),!0===e.normalized&&(// assuming Uint8Array
this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}O.NAMES=L,O.prototype.isColor=!0,O.prototype.r=1,O.prototype.g=1,O.prototype.b=1;class z{static getDataURL(t){let i;if(/^data:/i.test(t.src)||"undefined"==typeof HTMLCanvasElement)return t.src;if(t instanceof HTMLCanvasElement)i=t;else{void 0===e&&(e=S("canvas")),e.width=t.width,e.height=t.height;let n=e.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),i=e}return i.width>2048||i.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),i.toDataURL("image/jpeg",.6)):i.toDataURL("image/png")}static sRGBToLinear(e){if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap){let t=S("canvas");t.width=e.width,t.height=e.height;let i=t.getContext("2d");i.drawImage(e,0,0,e.width,e.height);let n=i.getImageData(0,0,e.width,e.height),r=n.data;for(let e=0;e<r.length;e++)r[e]=255*T(r[e]/255);return i.putImageData(n,0,0),t}if(!e.data)return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e;{let t=e.data.slice(0);for(let e=0;e<t.length;e++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[e]=Math.floor(255*T(t[e]/255)):t[e]=T(t[e]);return{data:t,width:e.width,height:e.height}}}}class U{constructor(e=null){this.uuid=p(),this.data=e,this.version=0}set needsUpdate(e){!0===e&&this.version++}toJSON(e){let t=void 0===e||"string"==typeof e;if(!t&&void 0!==e.images[this.uuid])return e.images[this.uuid];let i={uuid:this.uuid,url:""},n=this.data;if(null!==n){let e;if(Array.isArray(n)){// cube texture
e=[];for(let t=0,i=n.length;t<i;t++)n[t].isDataTexture?e.push(H(n[t].image)):e.push(H(n[t]))}else e=H(n);i.url=e}return t||(e.images[this.uuid]=i),i}}function H(e){return"undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap?z.getDataURL(e):e.data?{data:Array.prototype.slice.call(e.data),width:e.width,height:e.height,type:e.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}U.prototype.isSource=!0;let F=0;class B extends l{constructor(e=B.DEFAULT_IMAGE,t=B.DEFAULT_MAPPING,i=1001,n=1001,r=1006,s=1008,a=1023,o=1009,l=1,h=3e3){super(),Object.defineProperty(this,"id",{value:F++}),this.uuid=p(),this.name="",this.source=new U(e),this.mipmaps=[],this.mapping=t,this.wrapS=i,this.wrapT=n,this.magFilter=r,this.minFilter=s,this.anisotropy=l,this.format=a,this.internalFormat=null,this.type=o,this.offset=new b(0,0),this.repeat=new b(1,1),this.center=new b(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new M,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
//
// Also changing the encoding after already used by a Material will not automatically make the Material
// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
this.encoding=h,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){let t=void 0===e||"string"==typeof e;if(!t&&void 0!==e.textures[this.uuid])return e.textures[this.uuid];let i={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return"{}"!==JSON.stringify(this.userData)&&(i.userData=this.userData),t||(e.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(300!==this.mapping)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case 1e3:e.x=e.x-Math.floor(e.x);break;case 1001:e.x=e.x<0?0:1;break;case 1002:1===Math.abs(Math.floor(e.x)%2)?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x)}if(e.y<0||e.y>1)switch(this.wrapT){case 1e3:e.y=e.y-Math.floor(e.y);break;case 1001:e.y=e.y<0?0:1;break;case 1002:1===Math.abs(Math.floor(e.y)%2)?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y)}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){!0===e&&(this.version++,this.source.needsUpdate=!0)}}B.DEFAULT_IMAGE=null,B.DEFAULT_MAPPING=300,B.prototype.isTexture=!0;class G{constructor(e=0,t=0,i=0,n=1){this.x=e,this.y=t,this.z=i,this.w=n}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,i,n){return this.x=e,this.y=t,this.z=i,this.w=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=void 0!==e.w?e.w:1,this}add(e,t){return void 0!==t?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return void 0!==t?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){let t=this.x,i=this.y,n=this.z,r=this.w,s=e.elements;return this.x=s[0]*t+s[4]*i+s[8]*n+s[12]*r,this.y=s[1]*t+s[5]*i+s[9]*n+s[13]*r,this.z=s[2]*t+s[6]*i+s[10]*n+s[14]*r,this.w=s[3]*t+s[7]*i+s[11]*n+s[15]*r,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
// q is assumed to be normalized
this.w=2*Math.acos(e.w);let t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,i,n;let r=e.elements,s=r[0],a=r[4],o=r[8],l=r[1],h=r[5],u=r[9],c=r[2],d=r[6],p=r[10];if(.01>Math.abs(a-l)&&.01>Math.abs(o-c)&&.01>Math.abs(u-d)){// singularity found
// first check for identity matrix which must have +1 for all terms
// in leading diagonal and zero in other terms
if(.1>Math.abs(a+l)&&.1>Math.abs(o+c)&&.1>Math.abs(u+d)&&.1>Math.abs(s+h+p-3))return(// this singularity is identity matrix so angle = 0
this.set(1,0,0,0),this);// zero angle, arbitrary axis
let e=(s+1)/2,r=(h+1)/2,m=(p+1)/2,f=(a+l)/4,g=(o+c)/4,v=(u+d)/4;return e>r&&e>m?e<.01?(t=0,i=.707106781,n=.707106781):(i=f/(t=Math.sqrt(e)),n=g/t):r>m?r<.01?(t=.707106781,i=0,n=.707106781):(t=f/(i=Math.sqrt(r)),n=v/i):m<.01?(t=.707106781,i=.707106781,n=0):(t=g/(n=Math.sqrt(m)),i=v/n),this.set(t,i,n,Math.PI),this;// return 180 deg rotation
}// as we have reached here there are no singularities so we can handle normally
let m=Math.sqrt((d-u)*(d-u)+(o-c)*(o-c)+(l-a)*(l-a));// used to normalize
return .001>Math.abs(m)&&(m=1),// prevent divide by zero, should not happen if matrix is orthogonal and should be
// caught by singularity test above, but I've left it in just in case
this.x=(d-u)/m,this.y=(o-c)/m,this.z=(l-a)/m,this.w=Math.acos((s+h+p-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return(// assumes min < max, componentwise
this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this)}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){let i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this.w=e.w+(t.w-e.w)*i,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,i){return void 0!==i&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}G.prototype.isVector4=!0;/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/class k extends l{constructor(e,t,i={}){super(),this.width=e,this.height=t,this.depth=1,this.scissor=new G(0,0,e,t),this.scissorTest=!1,this.viewport=new G(0,0,e,t),this.texture=new B({width:e,height:t,depth:1},i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=void 0!==i.generateMipmaps&&i.generateMipmaps,this.texture.internalFormat=void 0!==i.internalFormat?i.internalFormat:null,this.texture.minFilter=void 0!==i.minFilter?i.minFilter:1006,this.depthBuffer=void 0===i.depthBuffer||i.depthBuffer,this.stencilBuffer=void 0!==i.stencilBuffer&&i.stencilBuffer,this.depthTexture=void 0!==i.depthTexture?i.depthTexture:null,this.samples=void 0!==i.samples?i.samples:0}setSize(e,t,i=1){(this.width!==e||this.height!==t||this.depth!==i)&&(this.width=e,this.height=t,this.depth=i,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=i,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0,// ensure image object is not shared, see #20328
this.texture.image=Object.assign({},e.texture.image),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,null!==e.depthTexture&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}k.prototype.isWebGLRenderTarget=!0;class V extends B{constructor(e=null,t=1,i=1,n=1){super(null),this.image={data:e,width:t,height:i,depth:n},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}V.prototype.isDataArrayTexture=!0,(class extends k{constructor(e,t,i){super(e,t),this.depth=i,this.texture=new V(null,e,t,i),this.texture.isRenderTargetTexture=!0}}).prototype.isWebGLArrayRenderTarget=!0;class W extends B{constructor(e=null,t=1,i=1,n=1){// We're going to add .setXXX() methods for setting properties later.
// Users can still set in DataTexture3D directly.
//
//	const texture = new THREE.DataTexture3D( data, width, height, depth );
// 	texture.anisotropy = 16;
//
// See #14839
super(null),this.image={data:e,width:t,height:i,depth:n},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}W.prototype.isData3DTexture=!0,(class extends k{constructor(e,t,i){super(e,t),this.depth=i,this.texture=new W(null,e,t,i),this.texture.isRenderTargetTexture=!0}}).prototype.isWebGL3DRenderTarget=!0,(class extends k{constructor(e,t,i,n={}){super(e,t,n);let r=this.texture;this.texture=[];for(let e=0;e<i;e++)this.texture[e]=r.clone(),this.texture[e].isRenderTargetTexture=!0}setSize(e,t,i=1){if(this.width!==e||this.height!==t||this.depth!==i){this.width=e,this.height=t,this.depth=i;for(let n=0,r=this.texture.length;n<r;n++)this.texture[n].image.width=e,this.texture[n].image.height=t,this.texture[n].image.depth=i;this.dispose()}return this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t),this}copy(e){this.dispose(),this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this.texture.length=0;for(let t=0,i=e.texture.length;t<i;t++)this.texture[t]=e.texture[t].clone();return this}}).prototype.isWebGLMultipleRenderTargets=!0;class j{constructor(e=0,t=0,i=0,n=1){this._x=e,this._y=t,this._z=i,this._w=n}static slerp(e,t,i,n){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),i.slerpQuaternions(e,t,n)}static slerpFlat(e,t,i,n,r,s,a){// fuzz-free, array-based Quaternion SLERP operation
let o=i[n+0],l=i[n+1],h=i[n+2],u=i[n+3],c=r[s+0],d=r[s+1],p=r[s+2],m=r[s+3];if(0===a){e[t+0]=o,e[t+1]=l,e[t+2]=h,e[t+3]=u;return}if(1===a){e[t+0]=c,e[t+1]=d,e[t+2]=p,e[t+3]=m;return}if(u!==m||o!==c||l!==d||h!==p){let e=1-a,t=o*c+l*d+h*p+u*m,i=t>=0?1:-1,n=1-t*t;// Skip the Slerp for tiny steps to avoid numeric problems:
if(n>Number.EPSILON){let r=Math.sqrt(n),s=Math.atan2(r,t*i);e=Math.sin(e*s)/r,a=Math.sin(a*s)/r}let r=a*i;// Normalize in case we just did a lerp:
if(o=o*e+c*r,l=l*e+d*r,h=h*e+p*r,u=u*e+m*r,e===1-a){let e=1/Math.sqrt(o*o+l*l+h*h+u*u);o*=e,l*=e,h*=e,u*=e}}e[t]=o,e[t+1]=l,e[t+2]=h,e[t+3]=u}static multiplyQuaternionsFlat(e,t,i,n,r,s){let a=i[n],o=i[n+1],l=i[n+2],h=i[n+3],u=r[s],c=r[s+1],d=r[s+2],p=r[s+3];return e[t]=a*p+h*u+o*d-l*c,e[t+1]=o*p+h*c+l*u-a*d,e[t+2]=l*p+h*d+a*c-o*u,e[t+3]=h*p-a*u-o*c-l*d,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,i,n){return this._x=e,this._y=t,this._z=i,this._w=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!(e&&e.isEuler))throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");let i=e._x,n=e._y,r=e._z,s=e._order,a=Math.cos,o=Math.sin,l=a(i/2),h=a(n/2),u=a(r/2),c=o(i/2),d=o(n/2),p=o(r/2);switch(s){case"XYZ":this._x=c*h*u+l*d*p,this._y=l*d*u-c*h*p,this._z=l*h*p+c*d*u,this._w=l*h*u-c*d*p;break;case"YXZ":this._x=c*h*u+l*d*p,this._y=l*d*u-c*h*p,this._z=l*h*p-c*d*u,this._w=l*h*u+c*d*p;break;case"ZXY":this._x=c*h*u-l*d*p,this._y=l*d*u+c*h*p,this._z=l*h*p+c*d*u,this._w=l*h*u-c*d*p;break;case"ZYX":this._x=c*h*u-l*d*p,this._y=l*d*u+c*h*p,this._z=l*h*p-c*d*u,this._w=l*h*u+c*d*p;break;case"YZX":this._x=c*h*u+l*d*p,this._y=l*d*u+c*h*p,this._z=l*h*p-c*d*u,this._w=l*h*u-c*d*p;break;case"XZY":this._x=c*h*u-l*d*p,this._y=l*d*u-c*h*p,this._z=l*h*p+c*d*u,this._w=l*h*u+c*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!1!==t&&this._onChangeCallback(),this}setFromAxisAngle(e,t){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
// assumes axis is normalized
let i=t/2,n=Math.sin(i);return this._x=e.x*n,this._y=e.y*n,this._z=e.z*n,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(e){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
let t=e.elements,i=t[0],n=t[4],r=t[8],s=t[1],a=t[5],o=t[9],l=t[2],h=t[6],u=t[10],c=i+a+u;if(c>0){let e=.5/Math.sqrt(c+1);this._w=.25/e,this._x=(h-o)*e,this._y=(r-l)*e,this._z=(s-n)*e}else if(i>a&&i>u){let e=2*Math.sqrt(1+i-a-u);this._w=(h-o)/e,this._x=.25*e,this._y=(n+s)/e,this._z=(r+l)/e}else if(a>u){let e=2*Math.sqrt(1+a-i-u);this._w=(r-l)/e,this._x=(n+s)/e,this._y=.25*e,this._z=(o+h)/e}else{let e=2*Math.sqrt(1+u-i-a);this._w=(s-n)/e,this._x=(r+l)/e,this._y=(o+h)/e,this._z=.25*e}return this._onChangeCallback(),this}setFromUnitVectors(e,t){// assumes direction vectors vFrom and vTo are normalized
let i=e.dot(t)+1;return i<Number.EPSILON?(// vFrom and vTo point in opposite directions
i=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0):(this._x=0,this._y=-e.z,this._z=e.y)):(// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x),this._w=i,this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(m(this.dot(e),-1,1)))}rotateTowards(e,t){let i=this.angleTo(e);return 0===i||this.slerp(e,Math.min(1,t/i)),this}identity(){return this.set(0,0,0,1)}invert(){// quaternion is assumed to have unit length
return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return 0===e?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return void 0!==t?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
let i=e._x,n=e._y,r=e._z,s=e._w,a=t._x,o=t._y,l=t._z,h=t._w;return this._x=i*h+s*a+n*l-r*o,this._y=n*h+s*o+r*a-i*l,this._z=r*h+s*l+i*o-n*a,this._w=s*h-i*a-n*o-r*l,this._onChangeCallback(),this}slerp(e,t){if(0===t)return this;if(1===t)return this.copy(e);let i=this._x,n=this._y,r=this._z,s=this._w,a=s*e._w+i*e._x+n*e._y+r*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=s,this._x=i,this._y=n,this._z=r,this;let o=1-a*a;if(o<=Number.EPSILON){let e=1-t;return this._w=e*s+t*this._w,this._x=e*i+t*this._x,this._y=e*n+t*this._y,this._z=e*r+t*this._z,this.normalize(),this._onChangeCallback(),this}let l=Math.sqrt(o),h=Math.atan2(l,a),u=Math.sin((1-t)*h)/l,c=Math.sin(t*h)/l;return this._w=s*u+this._w*c,this._x=i*u+this._x*c,this._y=n*u+this._y*c,this._z=r*u+this._z*c,this._onChangeCallback(),this}slerpQuaternions(e,t,i){return this.copy(e).slerp(t,i)}random(){// Derived from http://planning.cs.uiuc.edu/node198.html
// Note, this source uses w, x, y, z ordering,
// so we swap the order below.
let e=Math.random(),t=Math.sqrt(1-e),i=Math.sqrt(e),n=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(t*Math.cos(n),i*Math.sin(r),i*Math.cos(r),t*Math.sin(n))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}j.prototype.isQuaternion=!0;class q{constructor(e=0,t=0,i=0){this.x=e,this.y=t,this.z=i}set(e,t,i){return void 0===i&&(i=this.z),this.x=e,this.y=t,this.z=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return void 0!==t?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return void 0!==t?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return void 0!==t?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(Y.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(Y.setFromAxisAngle(e,t))}applyMatrix3(e){let t=this.x,i=this.y,n=this.z,r=e.elements;return this.x=r[0]*t+r[3]*i+r[6]*n,this.y=r[1]*t+r[4]*i+r[7]*n,this.z=r[2]*t+r[5]*i+r[8]*n,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){let t=this.x,i=this.y,n=this.z,r=e.elements,s=1/(r[3]*t+r[7]*i+r[11]*n+r[15]);return this.x=(r[0]*t+r[4]*i+r[8]*n+r[12])*s,this.y=(r[1]*t+r[5]*i+r[9]*n+r[13])*s,this.z=(r[2]*t+r[6]*i+r[10]*n+r[14])*s,this}applyQuaternion(e){let t=this.x,i=this.y,n=this.z,r=e.x,s=e.y,a=e.z,o=e.w,l=o*t+s*n-a*i,h=o*i+a*t-r*n,u=o*n+r*i-s*t,c=-r*t-s*i-a*n;return(// calculate result * inverse quat
this.x=l*o+-(c*r)+-(h*a)- -(u*s),this.y=h*o+-(c*s)+-(u*r)- -(l*a),this.z=u*o+-(c*a)+-(l*s)- -(h*r),this)}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){// input: THREE.Matrix4 affine matrix
// vector interpreted as a direction
let t=this.x,i=this.y,n=this.z,r=e.elements;return this.x=r[0]*t+r[4]*i+r[8]*n,this.y=r[1]*t+r[5]*i+r[9]*n,this.z=r[2]*t+r[6]*i+r[10]*n,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return(// assumes min < max, componentwise
this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this)}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){let i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}// TODO lengthSquared?
lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this}cross(e,t){return void 0!==t?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){let i=e.x,n=e.y,r=e.z,s=t.x,a=t.y,o=t.z;return this.x=n*o-r*a,this.y=r*s-i*o,this.z=i*a-n*s,this}projectOnVector(e){let t=e.lengthSq();if(0===t)return this.set(0,0,0);let i=e.dot(this)/t;return this.copy(e).multiplyScalar(i)}projectOnPlane(e){return X.copy(this).projectOnVector(e),this.sub(X)}reflect(e){// reflect incident vector off plane orthogonal to normal
// normal is assumed to have unit length
return this.sub(X.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){let t=Math.sqrt(this.lengthSq()*e.lengthSq());if(0===t)return Math.PI/2;let i=this.dot(e)/t;// clamp, to handle numerical problems
return Math.acos(m(i,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){let t=this.x-e.x,i=this.y-e.y,n=this.z-e.z;return t*t+i*i+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,i){let n=Math.sin(t)*e;return this.x=n*Math.sin(i),this.y=Math.cos(t)*e,this.z=n*Math.cos(i),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,i){return this.x=e*Math.sin(t),this.y=i,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){let t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){let t=this.setFromMatrixColumn(e,0).length(),i=this.setFromMatrixColumn(e,1).length(),n=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=i,this.z=n,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,4*t)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,3*t)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,i){return void 0!==i&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){// Derived from https://mathworld.wolfram.com/SpherePointPicking.html
let e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,i=Math.sqrt(1-e**2);return this.x=i*Math.cos(t),this.y=i*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}q.prototype.isVector3=!0;const X=/*@__PURE__*/new q,Y=/*@__PURE__*/new j;class J{constructor(e=new q(1/0,1/0,1/0),t=new q(-1/0,-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,i=1/0,n=1/0,r=-1/0,s=-1/0,a=-1/0;for(let o=0,l=e.length;o<l;o+=3){let l=e[o],h=e[o+1],u=e[o+2];l<t&&(t=l),h<i&&(i=h),u<n&&(n=u),l>r&&(r=l),h>s&&(s=h),u>a&&(a=u)}return this.min.set(t,i,n),this.max.set(r,s,a),this}setFromBufferAttribute(e){let t=1/0,i=1/0,n=1/0,r=-1/0,s=-1/0,a=-1/0;for(let o=0,l=e.count;o<l;o++){let l=e.getX(o),h=e.getY(o),u=e.getZ(o);l<t&&(t=l),h<i&&(i=h),u<n&&(n=u),l>r&&(r=l),h>s&&(s=h),u>a&&(a=u)}return this.min.set(t,i,n),this.max.set(r,s,a),this}setFromPoints(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){let i=K.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(i),this.max.copy(e).add(i),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){// Computes the world-axis-aligned bounding box of an object (including its children),
// accounting for both the object's, and children's, world transforms
e.updateWorldMatrix(!1,!1);let i=e.geometry;if(void 0!==i){if(t&&void 0!=i.attributes&&void 0!==i.attributes.position){let t=i.attributes.position;for(let i=0,n=t.count;i<n;i++)K.fromBufferAttribute(t,i).applyMatrix4(e.matrixWorld),this.expandByPoint(K)}else null===i.boundingBox&&i.computeBoundingBox(),Q.copy(i.boundingBox),Q.applyMatrix4(e.matrixWorld),this.union(Q)}let n=e.children;for(let e=0,i=n.length;e<i;e++)this.expandByObject(n[e],t);return this}containsPoint(e){return!(e.x<this.min.x)&&!(e.x>this.max.x)&&!(e.y<this.min.y)&&!(e.y>this.max.y)&&!(e.z<this.min.z)&&!(e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){// This can potentially have a divide by zero if the box
// has a size dimension of 0.
return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){// using 6 splitting planes to rule out intersections.
return!(e.max.x<this.min.x)&&!(e.min.x>this.max.x)&&!(e.max.y<this.min.y)&&!(e.min.y>this.max.y)&&!(e.max.z<this.min.z)&&!(e.min.z>this.max.z)}intersectsSphere(e){// If that point is inside the sphere, the AABB and sphere intersect.
return(// Find the point on the AABB closest to the sphere center.
this.clampPoint(e.center,K),K.distanceToSquared(e.center)<=e.radius*e.radius)}intersectsPlane(e){// We compute the minimum and maximum dot product values. If those values
// are on the same side (back or front) of the plane, then there is no intersection.
let t,i;return e.normal.x>0?(t=e.normal.x*this.min.x,i=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,i=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,i+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,i+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,i+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,i+=e.normal.z*this.min.z),t<=-e.constant&&i>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;// compute box center and extents
this.getCenter(es),ea.subVectors(this.max,es),// translate triangle to aabb origin
$.subVectors(e.a,es),ee.subVectors(e.b,es),et.subVectors(e.c,es),// compute edge vectors for triangle
ei.subVectors(ee,$),en.subVectors(et,ee),er.subVectors($,et);// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
let t=[0,-ei.z,ei.y,0,-en.z,en.y,0,-er.z,er.y,ei.z,0,-ei.x,en.z,0,-en.x,er.z,0,-er.x,-ei.y,ei.x,0,-en.y,en.x,0,-er.y,er.x,0];return!!(eh(t,$,ee,et,ea)&&eh(// test 3 face normals from the aabb
t=[1,0,0,0,1,0,0,0,1],$,ee,et,ea))&&(// finally testing the face normal of the triangle
// use already existing triangle edge vectors here
eo.crossVectors(ei,en),eh(t=[eo.x,eo.y,eo.z],$,ee,et,ea))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){let t=K.copy(e).clamp(this.min,this.max);return t.sub(e).length()}getBoundingSphere(e){return this.getCenter(e.center),e.radius=.5*this.getSize(K).length(),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()||(// NOTE: I am using a binary pattern to specify all 2^3 combinations below
Z[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Z[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Z[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Z[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Z[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Z[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Z[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Z[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Z)),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}J.prototype.isBox3=!0;const Z=[/*@__PURE__*/new q,/*@__PURE__*/new q,/*@__PURE__*/new q,/*@__PURE__*/new q,/*@__PURE__*/new q,/*@__PURE__*/new q,/*@__PURE__*/new q,/*@__PURE__*/new q],K=/*@__PURE__*/new q,Q=/*@__PURE__*/new J,$=/*@__PURE__*/new q,ee=/*@__PURE__*/new q,et=/*@__PURE__*/new q,ei=/*@__PURE__*/new q,en=/*@__PURE__*/new q,er=/*@__PURE__*/new q,es=/*@__PURE__*/new q,ea=/*@__PURE__*/new q,eo=/*@__PURE__*/new q,el=/*@__PURE__*/new q;function eh(e,t,i,n,r){for(let s=0,a=e.length-3;s<=a;s+=3){el.fromArray(e,s);// project the aabb onto the separating axis
let a=r.x*Math.abs(el.x)+r.y*Math.abs(el.y)+r.z*Math.abs(el.z),o=t.dot(el),l=i.dot(el),h=n.dot(el);// actual test, basically see if either of the most extreme of the triangle points intersects r
if(Math.max(-Math.max(o,l,h),Math.min(o,l,h))>a)// the axis is separating and we can exit
return!1}return!0}const eu=/*@__PURE__*/new J,ec=/*@__PURE__*/new q,ed=/*@__PURE__*/new q,ep=/*@__PURE__*/new q;class em{constructor(e=new q,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){let i=this.center;void 0!==t?i.copy(t):eu.setFromPoints(e).getCenter(i);let n=0;for(let t=0,r=e.length;t<r;t++)n=Math.max(n,i.distanceToSquared(e[t]));return this.radius=Math.sqrt(n),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){let t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){let i=this.center.distanceToSquared(e);return t.copy(e),i>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?// Empty sphere produces empty bounding box
e.makeEmpty():(e.set(this.center,this.center),e.expandByScalar(this.radius)),e}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671
ep.subVectors(e,this.center);let t=ep.lengthSq();if(t>this.radius*this.radius){let e=Math.sqrt(t),i=(e-this.radius)*.5;// Nudge this sphere towards the target point. Add half the missing distance to radius,
// and the other half to position. This gives a tighter enclosure, instead of if
// the whole missing distance were just added to radius.
this.center.add(ep.multiplyScalar(i/e)),this.radius+=i}return this}union(e){return!0===this.center.equals(e.center)?ed.set(0,0,1).multiplyScalar(e.radius):ed.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius),this.expandByPoint(ec.copy(e.center).add(ed)),this.expandByPoint(ec.copy(e.center).sub(ed)),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const ef=/*@__PURE__*/new q,eg=/*@__PURE__*/new q,ev=/*@__PURE__*/new q,ex=/*@__PURE__*/new q,ey=/*@__PURE__*/new q,e_=/*@__PURE__*/new q,eb=/*@__PURE__*/new q;class eM{constructor(e=new q,t=new q(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,ef)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);let i=t.dot(this.direction);return i<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(i).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){let t=ef.subVectors(e,this.origin).dot(this.direction);return(// point behind the ray
t<0?this.origin.distanceToSquared(e):(ef.copy(this.direction).multiplyScalar(t).add(this.origin),ef.distanceToSquared(e)))}distanceSqToSegment(e,t,i,n){let r,s,a,o;// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
// It returns the min distance between the ray and the segment
// defined by v0 and v1
// It can also set two optional targets :
// - The closest point on the ray
// - The closest point on the segment
eg.copy(e).add(t).multiplyScalar(.5),ev.copy(t).sub(e).normalize(),ex.copy(this.origin).sub(eg);let l=.5*e.distanceTo(t),h=-this.direction.dot(ev),u=ex.dot(this.direction),c=-ex.dot(ev),d=ex.lengthSq(),p=Math.abs(1-h*h);if(p>0){if(// The ray and segment are not parallel.
r=h*c-u,s=h*u-c,o=l*p,r>=0){if(s>=-o){if(s<=o){// region 0
// Minimum at interior points of ray and segment.
let e=1/p;r*=e,s*=e,a=r*(r+h*s+2*u)+s*(h*r+s+2*c)+d}else a=-(r=Math.max(0,-(h*// region 1
(s=l)+u)))*r+s*(s+2*c)+d}else a=-(r=Math.max(0,-(h*// region 5
(s=-l)+u)))*r+s*(s+2*c)+d}else s<=-o?(s=// region 4
(r=Math.max(0,-(-h*l+u)))>0?-l:Math.min(Math.max(-l,-c),l),a=-r*r+s*(s+2*c)+d):s<=o?(// region 3
r=0,a=(s=Math.min(Math.max(-l,-c),l))*(s+2*c)+d):(s=// region 2
(r=Math.max(0,-(h*l+u)))>0?l:Math.min(Math.max(-l,-c),l),a=-r*r+s*(s+2*c)+d)}else // Ray and segment are parallel.
s=h>0?-l:l,a=-(r=Math.max(0,-(h*s+u)))*r+s*(s+2*c)+d;return i&&i.copy(this.direction).multiplyScalar(r).add(this.origin),n&&n.copy(ev).multiplyScalar(s).add(eg),a}intersectSphere(e,t){ef.subVectors(e.center,this.origin);let i=ef.dot(this.direction),n=ef.dot(ef)-i*i,r=e.radius*e.radius;if(n>r)return null;let s=Math.sqrt(r-n),a=i-s,o=i+s;return(// test to see if both t0 and t1 are behind the ray - if so, return null
a<0&&o<0?null:a<0?this.at(o,t):this.at(a,t))}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){let t=e.normal.dot(this.direction);if(0===t)return(// line is coplanar, return origin
0===e.distanceToPoint(this.origin)?0:null);let i=-(this.origin.dot(e.normal)+e.constant)/t;// Return if the ray never intersects the plane
return i>=0?i:null}intersectPlane(e,t){let i=this.distanceToPlane(e);return null===i?null:this.at(i,t)}intersectsPlane(e){// check if the ray lies on the plane first
let t=e.distanceToPoint(this.origin);if(0===t)return!0;let i=e.normal.dot(this.direction);return i*t<0}intersectBox(e,t){let i,n,r,s,a,o;let l=1/this.direction.x,h=1/this.direction.y,u=1/this.direction.z,c=this.origin;return(l>=0?(i=(e.min.x-c.x)*l,n=(e.max.x-c.x)*l):(i=(e.max.x-c.x)*l,n=(e.min.x-c.x)*l),h>=0?(r=(e.min.y-c.y)*h,s=(e.max.y-c.y)*h):(r=(e.max.y-c.y)*h,s=(e.min.y-c.y)*h),i>s||r>n)?null:((r>i||i!=i)&&(i=r),(s<n||n!=n)&&(n=s),u>=0?(a=(e.min.z-c.z)*u,o=(e.max.z-c.z)*u):(a=(e.max.z-c.z)*u,o=(e.min.z-c.z)*u),i>o||a>n)?null:((a>i||i!=i)&&(i=a),(o<n||n!=n)&&(n=o),n<0)?null:this.at(i>=0?i:n,t)}intersectsBox(e){return null!==this.intersectBox(e,ef)}intersectTriangle(e,t,i,n,r){let s;// Compute the offset origin, edges, and normal.
// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
ey.subVectors(t,e),e_.subVectors(i,e),eb.crossVectors(ey,e_);// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
let a=this.direction.dot(eb);if(a>0){if(n)return null;s=1}else{if(!(a<0))return null;s=-1,a=-a}ex.subVectors(this.origin,e);let o=s*this.direction.dot(e_.crossVectors(ex,e_));// b1 < 0, no intersection
if(o<0)return null;let l=s*this.direction.dot(ey.cross(ex));// b2 < 0, no intersection
if(l<0||o+l>a)return null;// Line intersects triangle, check if ray does.
let h=-s*ex.dot(eb);return(// t < 0, no intersection
h<0?null:this.at(h/a,r))}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class ew{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,i,n,r,s,a,o,l,h,u,c,d,p,m,f){let g=this.elements;return g[0]=e,g[4]=t,g[8]=i,g[12]=n,g[1]=r,g[5]=s,g[9]=a,g[13]=o,g[2]=l,g[6]=h,g[10]=u,g[14]=c,g[3]=d,g[7]=p,g[11]=m,g[15]=f,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new ew().fromArray(this.elements)}copy(e){let t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],t[9]=i[9],t[10]=i[10],t[11]=i[11],t[12]=i[12],t[13]=i[13],t[14]=i[14],t[15]=i[15],this}copyPosition(e){let t=this.elements,i=e.elements;return t[12]=i[12],t[13]=i[13],t[14]=i[14],this}setFromMatrix3(e){let t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,i){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(e,t,i){return this.set(e.x,t.x,i.x,0,e.y,t.y,i.y,0,e.z,t.z,i.z,0,0,0,0,1),this}extractRotation(e){// this method does not support reflection matrices
let t=this.elements,i=e.elements,n=1/eS.setFromMatrixColumn(e,0).length(),r=1/eS.setFromMatrixColumn(e,1).length(),s=1/eS.setFromMatrixColumn(e,2).length();return t[0]=i[0]*n,t[1]=i[1]*n,t[2]=i[2]*n,t[3]=0,t[4]=i[4]*r,t[5]=i[5]*r,t[6]=i[6]*r,t[7]=0,t[8]=i[8]*s,t[9]=i[9]*s,t[10]=i[10]*s,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");let t=this.elements,i=e.x,n=e.y,r=e.z,s=Math.cos(i),a=Math.sin(i),o=Math.cos(n),l=Math.sin(n),h=Math.cos(r),u=Math.sin(r);if("XYZ"===e.order){let e=s*h,i=s*u,n=a*h,r=a*u;t[0]=o*h,t[4]=-o*u,t[8]=l,t[1]=i+n*l,t[5]=e-r*l,t[9]=-a*o,t[2]=r-e*l,t[6]=n+i*l,t[10]=s*o}else if("YXZ"===e.order){let e=o*h,i=o*u,n=l*h,r=l*u;t[0]=e+r*a,t[4]=n*a-i,t[8]=s*l,t[1]=s*u,t[5]=s*h,t[9]=-a,t[2]=i*a-n,t[6]=r+e*a,t[10]=s*o}else if("ZXY"===e.order){let e=o*h,i=o*u,n=l*h,r=l*u;t[0]=e-r*a,t[4]=-s*u,t[8]=n+i*a,t[1]=i+n*a,t[5]=s*h,t[9]=r-e*a,t[2]=-s*l,t[6]=a,t[10]=s*o}else if("ZYX"===e.order){let e=s*h,i=s*u,n=a*h,r=a*u;t[0]=o*h,t[4]=n*l-i,t[8]=e*l+r,t[1]=o*u,t[5]=r*l+e,t[9]=i*l-n,t[2]=-l,t[6]=a*o,t[10]=s*o}else if("YZX"===e.order){let e=s*o,i=s*l,n=a*o,r=a*l;t[0]=o*h,t[4]=r-e*u,t[8]=n*u+i,t[1]=u,t[5]=s*h,t[9]=-a*h,t[2]=-l*h,t[6]=i*u+n,t[10]=e-r*u}else if("XZY"===e.order){let e=s*o,i=s*l,n=a*o,r=a*l;t[0]=o*h,t[4]=-u,t[8]=l*h,t[1]=e*u+r,t[5]=s*h,t[9]=i*u-n,t[2]=n*u-i,t[6]=a*h,t[10]=r*u+e}return(// bottom row
t[3]=0,t[7]=0,t[11]=0,// last column
t[12]=0,t[13]=0,t[14]=0,t[15]=1,this)}makeRotationFromQuaternion(e){return this.compose(eE,e,eA)}lookAt(e,t,i){let n=this.elements;return eC.subVectors(e,t),0===eC.lengthSq()&&(eC.z=1),eC.normalize(),eR.crossVectors(i,eC),0===eR.lengthSq()&&(1===Math.abs(i.z)?eC.x+=1e-4:eC.z+=1e-4,eC.normalize(),eR.crossVectors(i,eC)),eR.normalize(),eL.crossVectors(eC,eR),n[0]=eR.x,n[4]=eL.x,n[8]=eC.x,n[1]=eR.y,n[5]=eL.y,n[9]=eC.y,n[2]=eR.z,n[6]=eL.z,n[10]=eC.z,this}multiply(e,t){return void 0!==t?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){let i=e.elements,n=t.elements,r=this.elements,s=i[0],a=i[4],o=i[8],l=i[12],h=i[1],u=i[5],c=i[9],d=i[13],p=i[2],m=i[6],f=i[10],g=i[14],v=i[3],x=i[7],y=i[11],_=i[15],b=n[0],M=n[4],w=n[8],S=n[12],T=n[1],E=n[5],A=n[9],R=n[13],L=n[2],C=n[6],P=n[10],I=n[14],D=n[3],N=n[7],O=n[11],z=n[15];return r[0]=s*b+a*T+o*L+l*D,r[4]=s*M+a*E+o*C+l*N,r[8]=s*w+a*A+o*P+l*O,r[12]=s*S+a*R+o*I+l*z,r[1]=h*b+u*T+c*L+d*D,r[5]=h*M+u*E+c*C+d*N,r[9]=h*w+u*A+c*P+d*O,r[13]=h*S+u*R+c*I+d*z,r[2]=p*b+m*T+f*L+g*D,r[6]=p*M+m*E+f*C+g*N,r[10]=p*w+m*A+f*P+g*O,r[14]=p*S+m*R+f*I+g*z,r[3]=v*b+x*T+y*L+_*D,r[7]=v*M+x*E+y*C+_*N,r[11]=v*w+x*A+y*P+_*O,r[15]=v*S+x*R+y*I+_*z,this}multiplyScalar(e){let t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){let e=this.elements,t=e[0],i=e[4],n=e[8],r=e[12],s=e[1],a=e[5],o=e[9],l=e[13],h=e[2],u=e[6],c=e[10],d=e[14],p=e[3],m=e[7],f=e[11],g=e[15];//TODO: make this more efficient
//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
return p*(+r*o*u-n*l*u-r*a*c+i*l*c+n*a*d-i*o*d)+m*(+t*o*d-t*l*c+r*s*c-n*s*d+n*l*h-r*o*h)+f*(+t*l*u-t*a*d-r*s*u+i*s*d+r*a*h-i*l*h)+g*(-n*a*h-t*o*u+t*a*c+n*s*u-i*s*c+i*o*h)}transpose(){let e;let t=this.elements;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(e,t,i){let n=this.elements;return e.isVector3?(n[12]=e.x,n[13]=e.y,n[14]=e.z):(n[12]=e,n[13]=t,n[14]=i),this}invert(){// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
let e=this.elements,t=e[0],i=e[1],n=e[2],r=e[3],s=e[4],a=e[5],o=e[6],l=e[7],h=e[8],u=e[9],c=e[10],d=e[11],p=e[12],m=e[13],f=e[14],g=e[15],v=u*f*l-m*c*l+m*o*d-a*f*d-u*o*g+a*c*g,x=p*c*l-h*f*l-p*o*d+s*f*d+h*o*g-s*c*g,y=h*m*l-p*u*l+p*a*d-s*m*d-h*a*g+s*u*g,_=p*u*o-h*m*o-p*a*c+s*m*c+h*a*f-s*u*f,b=t*v+i*x+n*y+r*_;if(0===b)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);let M=1/b;return e[0]=v*M,e[1]=(m*c*r-u*f*r-m*n*d+i*f*d+u*n*g-i*c*g)*M,e[2]=(a*f*r-m*o*r+m*n*l-i*f*l-a*n*g+i*o*g)*M,e[3]=(u*o*r-a*c*r-u*n*l+i*c*l+a*n*d-i*o*d)*M,e[4]=x*M,e[5]=(h*f*r-p*c*r+p*n*d-t*f*d-h*n*g+t*c*g)*M,e[6]=(p*o*r-s*f*r-p*n*l+t*f*l+s*n*g-t*o*g)*M,e[7]=(s*c*r-h*o*r+h*n*l-t*c*l-s*n*d+t*o*d)*M,e[8]=y*M,e[9]=(p*u*r-h*m*r-p*i*d+t*m*d+h*i*g-t*u*g)*M,e[10]=(s*m*r-p*a*r+p*i*l-t*m*l-s*i*g+t*a*g)*M,e[11]=(h*a*r-s*u*r-h*i*l+t*u*l+s*i*d-t*a*d)*M,e[12]=_*M,e[13]=(h*m*n-p*u*n+p*i*c-t*m*c-h*i*f+t*u*f)*M,e[14]=(p*a*n-s*m*n-p*i*o+t*m*o+s*i*f-t*a*f)*M,e[15]=(s*u*n-h*a*n+h*i*o-t*u*o-s*i*c+t*a*c)*M,this}scale(e){let t=this.elements,i=e.x,n=e.y,r=e.z;return t[0]*=i,t[4]*=n,t[8]*=r,t[1]*=i,t[5]*=n,t[9]*=r,t[2]*=i,t[6]*=n,t[10]*=r,t[3]*=i,t[7]*=n,t[11]*=r,this}getMaxScaleOnAxis(){let e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],i=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],n=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,i,n))}makeTranslation(e,t,i){return this.set(1,0,0,e,0,1,0,t,0,0,1,i,0,0,0,1),this}makeRotationX(e){let t=Math.cos(e),i=Math.sin(e);return this.set(1,0,0,0,0,t,-i,0,0,i,t,0,0,0,0,1),this}makeRotationY(e){let t=Math.cos(e),i=Math.sin(e);return this.set(t,0,i,0,0,1,0,0,-i,0,t,0,0,0,0,1),this}makeRotationZ(e){let t=Math.cos(e),i=Math.sin(e);return this.set(t,-i,0,0,i,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){// Based on http://www.gamedev.net/reference/articles/article1199.asp
let i=Math.cos(t),n=Math.sin(t),r=1-i,s=e.x,a=e.y,o=e.z,l=r*s,h=r*a;return this.set(l*s+i,l*a-n*o,l*o+n*a,0,l*a+n*o,h*a+i,h*o-n*s,0,l*o-n*a,h*o+n*s,r*o*o+i,0,0,0,0,1),this}makeScale(e,t,i){return this.set(e,0,0,0,0,t,0,0,0,0,i,0,0,0,0,1),this}makeShear(e,t,i,n,r,s){return this.set(1,i,r,0,e,1,s,0,t,n,1,0,0,0,0,1),this}compose(e,t,i){let n=this.elements,r=t._x,s=t._y,a=t._z,o=t._w,l=r+r,h=s+s,u=a+a,c=r*l,d=r*h,p=r*u,m=s*h,f=s*u,g=a*u,v=o*l,x=o*h,y=o*u,_=i.x,b=i.y,M=i.z;return n[0]=(1-(m+g))*_,n[1]=(d+y)*_,n[2]=(p-x)*_,n[3]=0,n[4]=(d-y)*b,n[5]=(1-(c+g))*b,n[6]=(f+v)*b,n[7]=0,n[8]=(p+x)*M,n[9]=(f-v)*M,n[10]=(1-(c+m))*M,n[11]=0,n[12]=e.x,n[13]=e.y,n[14]=e.z,n[15]=1,this}decompose(e,t,i){let n=this.elements,r=eS.set(n[0],n[1],n[2]).length(),s=eS.set(n[4],n[5],n[6]).length(),a=eS.set(n[8],n[9],n[10]).length(),o=this.determinant();o<0&&(r=-r),e.x=n[12],e.y=n[13],e.z=n[14],// scale the rotation part
eT.copy(this);let l=1/r,h=1/s,u=1/a;return eT.elements[0]*=l,eT.elements[1]*=l,eT.elements[2]*=l,eT.elements[4]*=h,eT.elements[5]*=h,eT.elements[6]*=h,eT.elements[8]*=u,eT.elements[9]*=u,eT.elements[10]*=u,t.setFromRotationMatrix(eT),i.x=r,i.y=s,i.z=a,this}makePerspective(e,t,i,n,r,s){void 0===s&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");let a=this.elements;return a[0]=2*r/(t-e),a[4]=0,a[8]=(t+e)/(t-e),a[12]=0,a[1]=0,a[5]=2*r/(i-n),a[9]=(i+n)/(i-n),a[13]=0,a[2]=0,a[6]=0,a[10]=-(s+r)/(s-r),a[14]=-2*s*r/(s-r),a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(e,t,i,n,r,s){let a=this.elements,o=1/(t-e),l=1/(i-n),h=1/(s-r);return a[0]=2*o,a[4]=0,a[8]=0,a[12]=-((t+e)*o),a[1]=0,a[5]=2*l,a[9]=0,a[13]=-((i+n)*l),a[2]=0,a[6]=0,a[10]=-2*h,a[14]=-((s+r)*h),a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(e){let t=this.elements,i=e.elements;for(let e=0;e<16;e++)if(t[e]!==i[e])return!1;return!0}fromArray(e,t=0){for(let i=0;i<16;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){let i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e[t+9]=i[9],e[t+10]=i[10],e[t+11]=i[11],e[t+12]=i[12],e[t+13]=i[13],e[t+14]=i[14],e[t+15]=i[15],e}}ew.prototype.isMatrix4=!0;const eS=/*@__PURE__*/new q,eT=/*@__PURE__*/new ew,eE=/*@__PURE__*/new q(0,0,0),eA=/*@__PURE__*/new q(1,1,1),eR=/*@__PURE__*/new q,eL=/*@__PURE__*/new q,eC=/*@__PURE__*/new q,eP=/*@__PURE__*/new ew,eI=/*@__PURE__*/new j;class eD{constructor(e=0,t=0,i=0,n=eD.DefaultOrder){this._x=e,this._y=t,this._z=i,this._order=n}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,i,n=this._order){return this._x=e,this._y=t,this._z=i,this._order=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,i=!0){// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
let n=e.elements,r=n[0],s=n[4],a=n[8],o=n[1],l=n[5],h=n[9],u=n[2],c=n[6],d=n[10];switch(t){case"XYZ":this._y=Math.asin(m(a,-1,1)),.9999999>Math.abs(a)?(this._x=Math.atan2(-h,d),this._z=Math.atan2(-s,r)):(this._x=Math.atan2(c,l),this._z=0);break;case"YXZ":this._x=Math.asin(-m(h,-1,1)),.9999999>Math.abs(h)?(this._y=Math.atan2(a,d),this._z=Math.atan2(o,l)):(this._y=Math.atan2(-u,r),this._z=0);break;case"ZXY":this._x=Math.asin(m(c,-1,1)),.9999999>Math.abs(c)?(this._y=Math.atan2(-u,d),this._z=Math.atan2(-s,l)):(this._y=0,this._z=Math.atan2(o,r));break;case"ZYX":this._y=Math.asin(-m(u,-1,1)),.9999999>Math.abs(u)?(this._x=Math.atan2(c,d),this._z=Math.atan2(o,r)):(this._x=0,this._z=Math.atan2(-s,l));break;case"YZX":this._z=Math.asin(m(o,-1,1)),.9999999>Math.abs(o)?(this._x=Math.atan2(-h,l),this._y=Math.atan2(-u,r)):(this._x=0,this._y=Math.atan2(a,d));break;case"XZY":this._z=Math.asin(-m(s,-1,1)),.9999999>Math.abs(s)?(this._x=Math.atan2(c,l),this._y=Math.atan2(a,r)):(this._x=Math.atan2(-h,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,!0===i&&this._onChangeCallback(),this}setFromQuaternion(e,t,i){return eP.makeRotationFromQuaternion(e),this.setFromRotationMatrix(eP,t,i)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return(// WARNING: this discards revolution information -bhouston
eI.setFromEuler(this),this.setFromQuaternion(eI,e))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],void 0!==e[3]&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}eD.prototype.isEuler=!0,eD.DefaultOrder="XYZ",eD.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class eN{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!=0}isEnabled(e){return(this.mask&(1<<e|0))!=0}}let eO=0;const ez=/*@__PURE__*/new q,eU=/*@__PURE__*/new j,eH=/*@__PURE__*/new ew,eF=/*@__PURE__*/new q,eB=/*@__PURE__*/new q,eG=/*@__PURE__*/new q,ek=/*@__PURE__*/new j,eV=/*@__PURE__*/new q(1,0,0),eW=/*@__PURE__*/new q(0,1,0),ej=/*@__PURE__*/new q(0,0,1),eq={type:"added"},eX={type:"removed"};class eY extends l{constructor(){super(),Object.defineProperty(this,"id",{value:eO++}),this.uuid=p(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=eY.DefaultUp.clone();let e=new q,t=new eD,i=new j,n=new q(1,1,1);t._onChange(function(){i.setFromEuler(t,!1)}),i._onChange(function(){t.setFromQuaternion(i,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:n},modelViewMatrix:{value:new ew},normalMatrix:{value:new M}}),this.matrix=new ew,this.matrixWorld=new ew,this.matrixAutoUpdate=eY.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new eN,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){// assumes axis is normalized
this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){// assumes q is normalized
this.quaternion.copy(e)}rotateOnAxis(e,t){return(// rotate object on axis in object space
// axis is assumed to be normalized
eU.setFromAxisAngle(e,t),this.quaternion.multiply(eU),this)}rotateOnWorldAxis(e,t){return(// rotate object on axis in world space
// axis is assumed to be normalized
// method assumes no rotated parent
eU.setFromAxisAngle(e,t),this.quaternion.premultiply(eU),this)}rotateX(e){return this.rotateOnAxis(eV,e)}rotateY(e){return this.rotateOnAxis(eW,e)}rotateZ(e){return this.rotateOnAxis(ej,e)}translateOnAxis(e,t){return(// translate object by distance along axis in object space
// axis is assumed to be normalized
ez.copy(e).applyQuaternion(this.quaternion),this.position.add(ez.multiplyScalar(t)),this)}translateX(e){return this.translateOnAxis(eV,e)}translateY(e){return this.translateOnAxis(eW,e)}translateZ(e){return this.translateOnAxis(ej,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(eH.copy(this.matrixWorld).invert())}lookAt(e,t,i){e.isVector3?eF.copy(e):eF.set(e,t,i);let n=this.parent;this.updateWorldMatrix(!0,!1),eB.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?eH.lookAt(eB,eF,this.up):eH.lookAt(eF,eB,this.up),this.quaternion.setFromRotationMatrix(eH),n&&(eH.extractRotation(n.matrixWorld),eU.setFromRotationMatrix(eH),this.quaternion.premultiply(eU.invert()))}add(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return e===this?console.error("THREE.Object3D.add: object can't be added as a child of itself.",e):e&&e.isObject3D?(null!==e.parent&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(eq)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this}remove(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}let t=this.children.indexOf(e);return -1!==t&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(eX)),this}removeFromParent(){let e=this.parent;return null!==e&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){let t=this.children[e];t.parent=null,t.dispatchEvent(eX)}return this.children.length=0,this}attach(e){return(// adds object as a child of this, while maintaining the object's world transform
// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)
this.updateWorldMatrix(!0,!1),eH.copy(this.matrixWorld).invert(),null!==e.parent&&(e.parent.updateWorldMatrix(!0,!1),eH.multiply(e.parent.matrixWorld)),e.applyMatrix4(eH),this.add(e),e.updateWorldMatrix(!1,!0),this)}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let i=0,n=this.children.length;i<n;i++){let n=this.children[i],r=n.getObjectByProperty(e,t);if(void 0!==r)return r}}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(eB,e,eG),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(eB,ek,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);let t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);let t=this.children;for(let i=0,n=t.length;i<n;i++)t[i].traverse(e)}traverseVisible(e){if(!1===this.visible)return;e(this);let t=this.children;for(let i=0,n=t.length;i<n;i++)t[i].traverseVisible(e)}traverseAncestors(e){let t=this.parent;null!==t&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);// update children
let t=this.children;for(let i=0,n=t.length;i<n;i++)t[i].updateMatrixWorld(e)}updateWorldMatrix(e,t){let i=this.parent;// update children
if(!0===e&&null!==i&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===t){let e=this.children;for(let t=0,i=e.length;t<i;t++)e[t].updateWorldMatrix(!1,!0)}}toJSON(e){// meta is a string when called from JSON.stringify
let t=void 0===e||"string"==typeof e,i={};t&&(// initialize meta obj
e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},i.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});// standard Object3D serialization
let n={};//
function r(t,i){return void 0===t[i.uuid]&&(t[i.uuid]=i.toJSON(e)),i.uuid}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),!0===this.castShadow&&(n.castShadow=!0),!0===this.receiveShadow&&(n.receiveShadow=!0),!1===this.visible&&(n.visible=!1),!1===this.frustumCulled&&(n.frustumCulled=!1),0!==this.renderOrder&&(n.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),n.layers=this.layers.mask,n.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(n.matrixAutoUpdate=!1),this.isInstancedMesh&&(n.type="InstancedMesh",n.count=this.count,n.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(n.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?n.background=this.background.toJSON():this.background.isTexture&&(n.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&(n.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){n.geometry=r(e.geometries,this.geometry);let t=this.geometry.parameters;if(void 0!==t&&void 0!==t.shapes){let i=t.shapes;if(Array.isArray(i))for(let t=0,n=i.length;t<n;t++){let n=i[t];r(e.shapes,n)}else r(e.shapes,i)}}if(this.isSkinnedMesh&&(n.bindMode=this.bindMode,n.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(r(e.skeletons,this.skeleton),n.skeleton=this.skeleton.uuid)),void 0!==this.material){if(Array.isArray(this.material)){let t=[];for(let i=0,n=this.material.length;i<n;i++)t.push(r(e.materials,this.material[i]));n.material=t}else n.material=r(e.materials,this.material)}//
if(this.children.length>0){n.children=[];for(let t=0;t<this.children.length;t++)n.children.push(this.children[t].toJSON(e).object)}//
if(this.animations.length>0){n.animations=[];for(let t=0;t<this.animations.length;t++){let i=this.animations[t];n.animations.push(r(e.animations,i))}}if(t){let t=s(e.geometries),n=s(e.materials),r=s(e.textures),a=s(e.images),o=s(e.shapes),l=s(e.skeletons),h=s(e.animations),u=s(e.nodes);t.length>0&&(i.geometries=t),n.length>0&&(i.materials=n),r.length>0&&(i.textures=r),a.length>0&&(i.images=a),o.length>0&&(i.shapes=o),l.length>0&&(i.skeletons=l),h.length>0&&(i.animations=h),u.length>0&&(i.nodes=u)}return i.object=n,i;// extract data from the cache hash
// remove metadata on each item
// and return as array
function s(e){let t=[];for(let i in e){let n=e[i];delete n.metadata,t.push(n)}return t}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),!0===t)for(let t=0;t<e.children.length;t++){let i=e.children[t];this.add(i.clone())}return this}}eY.DefaultUp=new q(0,1,0),eY.DefaultMatrixAutoUpdate=!0,eY.prototype.isObject3D=!0;const eJ=/*@__PURE__*/new q,eZ=/*@__PURE__*/new q,eK=/*@__PURE__*/new q,eQ=/*@__PURE__*/new q,e$=/*@__PURE__*/new q,e0=/*@__PURE__*/new q,e1=/*@__PURE__*/new q,e3=/*@__PURE__*/new q,e2=/*@__PURE__*/new q,e4=/*@__PURE__*/new q;class e5{constructor(e=new q,t=new q,i=new q){this.a=e,this.b=t,this.c=i}static getNormal(e,t,i,n){n.subVectors(i,t),eJ.subVectors(e,t),n.cross(eJ);let r=n.lengthSq();return r>0?n.multiplyScalar(1/Math.sqrt(r)):n.set(0,0,0)}// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
static getBarycoord(e,t,i,n,r){eJ.subVectors(n,t),eZ.subVectors(i,t),eK.subVectors(e,t);let s=eJ.dot(eJ),a=eJ.dot(eZ),o=eJ.dot(eK),l=eZ.dot(eZ),h=eZ.dot(eK),u=s*l-a*a;// collinear or singular triangle
if(0===u)// not sure if this is the best idea, maybe should be returning undefined
return r.set(-2,-1,-1);let c=1/u,d=(l*o-a*h)*c,p=(s*h-a*o)*c;// barycentric coordinates must always sum to 1
return r.set(1-d-p,p,d)}static containsPoint(e,t,i,n){return this.getBarycoord(e,t,i,n,eQ),eQ.x>=0&&eQ.y>=0&&eQ.x+eQ.y<=1}static getUV(e,t,i,n,r,s,a,o){return this.getBarycoord(e,t,i,n,eQ),o.set(0,0),o.addScaledVector(r,eQ.x),o.addScaledVector(s,eQ.y),o.addScaledVector(a,eQ.z),o}static isFrontFacing(e,t,i,n){// strictly front facing
return eJ.subVectors(i,t),eZ.subVectors(e,t),0>eJ.cross(eZ).dot(n)}set(e,t,i){return this.a.copy(e),this.b.copy(t),this.c.copy(i),this}setFromPointsAndIndices(e,t,i,n){return this.a.copy(e[t]),this.b.copy(e[i]),this.c.copy(e[n]),this}setFromAttributeAndIndices(e,t,i,n){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,i),this.c.fromBufferAttribute(e,n),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return eJ.subVectors(this.c,this.b),eZ.subVectors(this.a,this.b),.5*eJ.cross(eZ).length()}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return e5.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return e5.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,i,n,r){return e5.getUV(e,this.a,this.b,this.c,t,i,n,r)}containsPoint(e){return e5.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return e5.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){let i,n;let r=this.a,s=this.b,a=this.c;// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
// under the accompanying license; see chapter 5.1.5 for detailed explanation.
// basically, we're distinguishing which of the voronoi regions of the triangle
// the point lies in with the minimum amount of redundant computation.
e$.subVectors(s,r),e0.subVectors(a,r),e3.subVectors(e,r);let o=e$.dot(e3),l=e0.dot(e3);if(o<=0&&l<=0)return t.copy(r);e2.subVectors(e,s);let h=e$.dot(e2),u=e0.dot(e2);if(h>=0&&u<=h)return t.copy(s);let c=o*u-h*l;if(c<=0&&o>=0&&h<=0)// edge region of AB; barycentric coords (1-v, v, 0)
return i=o/(o-h),t.copy(r).addScaledVector(e$,i);e4.subVectors(e,a);let d=e$.dot(e4),p=e0.dot(e4);if(p>=0&&d<=p)return t.copy(a);let m=d*l-o*p;if(m<=0&&l>=0&&p<=0)// edge region of AC; barycentric coords (1-w, 0, w)
return n=l/(l-p),t.copy(r).addScaledVector(e0,n);let f=h*p-d*u;if(f<=0&&u-h>=0&&d-p>=0)// edge region of BC; barycentric coords (0, 1-w, w)
return e1.subVectors(a,s),n=(u-h)/(u-h+(d-p)),t.copy(s).addScaledVector(e1,n);// edge region of BC
// face region
let g=1/(f+m+c);return(// u = va * denom
i=m*g,n=c*g,t.copy(r).addScaledVector(e$,i).addScaledVector(e0,n))}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let e6=0;class e8 extends l{constructor(){super(),Object.defineProperty(this,"id",{value:e6++}),this.uuid=p(),this.name="",this.type="Material",this.fog=!0,this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=100,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=7680,this.stencilZFail=7680,this.stencilZPass=7680,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(void 0!==e)for(let t in e){let i=e[t];if(void 0===i){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}// for backward compatibility if shading is set in the constructor
if("shading"===t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===i;continue}let n=this[t];if(void 0===n){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}n&&n.isColor?n.set(i):n&&n.isVector3&&i&&i.isVector3?n.copy(i):this[t]=i}}toJSON(e){let t=void 0===e||"string"==typeof e;t&&(e={textures:{},images:{}});let i={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};// TODO: Copied from Object3D.toJSON
function n(e){let t=[];for(let i in e){let n=e[i];delete n.metadata,t.push(n)}return t}if(// standard Material serialization
i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),void 0!==this.roughness&&(i.roughness=this.roughness),void 0!==this.metalness&&(i.metalness=this.metalness),void 0!==this.sheen&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(i.shininess=this.shininess),void 0!==this.clearcoat&&(i.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(e).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(e).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(e).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(e).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(e).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(e).uuid,void 0!==this.combine&&(i.combine=this.combine)),void 0!==this.envMapIntensity&&(i.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(i.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(e).uuid),void 0!==this.transmission&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(e).uuid),void 0!==this.thickness&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(e).uuid),void 0!==this.attenuationDistance&&(i.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(i.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(i.size=this.size),null!==this.shadowSide&&(i.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(i.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(i.blending=this.blending),0!==this.side&&(i.side=this.side),this.vertexColors&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),!0===this.transparent&&(i.transparent=this.transparent),i.depthFunc=this.depthFunc,i.depthTest=this.depthTest,i.depthWrite=this.depthWrite,i.colorWrite=this.colorWrite,i.stencilWrite=this.stencilWrite,i.stencilWriteMask=this.stencilWriteMask,i.stencilFunc=this.stencilFunc,i.stencilRef=this.stencilRef,i.stencilFuncMask=this.stencilFuncMask,i.stencilFail=this.stencilFail,i.stencilZFail=this.stencilZFail,i.stencilZPass=this.stencilZPass,void 0!==this.rotation&&0!==this.rotation&&(i.rotation=this.rotation),!0===this.polygonOffset&&(i.polygonOffset=!0),0!==this.polygonOffsetFactor&&(i.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(i.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(i.linewidth=this.linewidth),void 0!==this.dashSize&&(i.dashSize=this.dashSize),void 0!==this.gapSize&&(i.gapSize=this.gapSize),void 0!==this.scale&&(i.scale=this.scale),!0===this.dithering&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&(i.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(i.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(i.wireframe=this.wireframe),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(i.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(i.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(i.flatShading=this.flatShading),!1===this.visible&&(i.visible=!1),!1===this.toneMapped&&(i.toneMapped=!1),"{}"!==JSON.stringify(this.userData)&&(i.userData=this.userData),t){let t=n(e.textures),r=n(e.images);t.length>0&&(i.textures=t),r.length>0&&(i.images=r)}return i}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.fog=e.fog,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;let t=e.clippingPlanes,i=null;if(null!==t){let e=t.length;i=Array(e);for(let n=0;n!==e;++n)i[n]=t[n].clone()}return this.clippingPlanes=i,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){!0===e&&this.version++}}e8.prototype.isMaterial=!0,e8.fromType=function(){// TODO: Behavior added in Materials.js
return null};class e7 extends e8{constructor(e){super(),this.type="MeshBasicMaterial",this.color=new O(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}e7.prototype.isMeshBasicMaterial=!0;const e9=/*@__PURE__*/new q,te=/*@__PURE__*/new b;class tt{constructor(e,t,i){if(Array.isArray(e))throw TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=void 0!==e?e.length/t:0,this.normalized=!0===i,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){!0===e&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,i){e*=this.itemSize,i*=t.itemSize;for(let n=0,r=this.itemSize;n<r;n++)this.array[e+n]=t.array[i+n];return this}copyArray(e){return this.array.set(e),this}copyColorsArray(e){let t=this.array,i=0;for(let n=0,r=e.length;n<r;n++){let r=e[n];void 0===r&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",n),r=new O),t[i++]=r.r,t[i++]=r.g,t[i++]=r.b}return this}copyVector2sArray(e){let t=this.array,i=0;for(let n=0,r=e.length;n<r;n++){let r=e[n];void 0===r&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",n),r=new b),t[i++]=r.x,t[i++]=r.y}return this}copyVector3sArray(e){let t=this.array,i=0;for(let n=0,r=e.length;n<r;n++){let r=e[n];void 0===r&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",n),r=new q),t[i++]=r.x,t[i++]=r.y,t[i++]=r.z}return this}copyVector4sArray(e){let t=this.array,i=0;for(let n=0,r=e.length;n<r;n++){let r=e[n];void 0===r&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",n),r=new G),t[i++]=r.x,t[i++]=r.y,t[i++]=r.z,t[i++]=r.w}return this}applyMatrix3(e){if(2===this.itemSize)for(let t=0,i=this.count;t<i;t++)te.fromBufferAttribute(this,t),te.applyMatrix3(e),this.setXY(t,te.x,te.y);else if(3===this.itemSize)for(let t=0,i=this.count;t<i;t++)e9.fromBufferAttribute(this,t),e9.applyMatrix3(e),this.setXYZ(t,e9.x,e9.y,e9.z);return this}applyMatrix4(e){for(let t=0,i=this.count;t<i;t++)e9.fromBufferAttribute(this,t),e9.applyMatrix4(e),this.setXYZ(t,e9.x,e9.y,e9.z);return this}applyNormalMatrix(e){for(let t=0,i=this.count;t<i;t++)e9.fromBufferAttribute(this,t),e9.applyNormalMatrix(e),this.setXYZ(t,e9.x,e9.y,e9.z);return this}transformDirection(e){for(let t=0,i=this.count;t<i;t++)e9.fromBufferAttribute(this,t),e9.transformDirection(e),this.setXYZ(t,e9.x,e9.y,e9.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){return this.array[e*this.itemSize]}setX(e,t){return this.array[e*this.itemSize]=t,this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){return this.array[e*this.itemSize+1]=t,this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){return this.array[e*this.itemSize+2]=t,this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){return this.array[e*this.itemSize+3]=t,this}setXY(e,t,i){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=i,this}setXYZ(e,t,i,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=n,this}setXYZW(e,t,i,n,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=n,this.array[e+3]=r,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){let e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return""!==this.name&&(e.name=this.name),35044!==this.usage&&(e.usage=this.usage),(0!==this.updateRange.offset||-1!==this.updateRange.count)&&(e.updateRange=this.updateRange),e}}tt.prototype.isBufferAttribute=!0;class ti extends tt{constructor(e,t,i){super(new Uint16Array(e),t,i)}}class tn extends tt{constructor(e,t,i){super(new Uint32Array(e),t,i)}}(class extends tt{constructor(e,t,i){super(new Uint16Array(e),t,i)}}).prototype.isFloat16BufferAttribute=!0;class tr extends tt{constructor(e,t,i){super(new Float32Array(e),t,i)}}let ts=0;const ta=/*@__PURE__*/new ew,to=/*@__PURE__*/new eY,tl=/*@__PURE__*/new q,th=/*@__PURE__*/new J,tu=/*@__PURE__*/new J,tc=/*@__PURE__*/new q;class td extends l{constructor(){super(),Object.defineProperty(this,"id",{value:ts++}),this.uuid=p(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(w(e)?tn:ti)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return void 0!==this.attributes[e]}addGroup(e,t,i=0){this.groups.push({start:e,count:t,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){let t=this.attributes.position;void 0!==t&&(t.applyMatrix4(e),t.needsUpdate=!0);let i=this.attributes.normal;if(void 0!==i){let t=new M().getNormalMatrix(e);i.applyNormalMatrix(t),i.needsUpdate=!0}let n=this.attributes.tangent;return void 0!==n&&(n.transformDirection(e),n.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(e){return ta.makeRotationFromQuaternion(e),this.applyMatrix4(ta),this}rotateX(e){return(// rotate geometry around world x-axis
ta.makeRotationX(e),this.applyMatrix4(ta),this)}rotateY(e){return(// rotate geometry around world y-axis
ta.makeRotationY(e),this.applyMatrix4(ta),this)}rotateZ(e){return(// rotate geometry around world z-axis
ta.makeRotationZ(e),this.applyMatrix4(ta),this)}translate(e,t,i){return(// translate geometry
ta.makeTranslation(e,t,i),this.applyMatrix4(ta),this)}scale(e,t,i){return(// scale geometry
ta.makeScale(e,t,i),this.applyMatrix4(ta),this)}lookAt(e){return to.lookAt(e),to.updateMatrix(),this.applyMatrix4(to.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(tl).negate(),this.translate(tl.x,tl.y,tl.z),this}setFromPoints(e){let t=[];for(let i=0,n=e.length;i<n;i++){let n=e[i];t.push(n.x,n.y,n.z||0)}return this.setAttribute("position",new tr(t,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new J);let e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new q(-1/0,-1/0,-1/0),new q(1/0,1/0,1/0));return}if(void 0!==e)// process morph attributes if present
{if(this.boundingBox.setFromBufferAttribute(e),t)for(let e=0,i=t.length;e<i;e++){let i=t[e];th.setFromBufferAttribute(i),this.morphTargetsRelative?(tc.addVectors(this.boundingBox.min,th.min),this.boundingBox.expandByPoint(tc),tc.addVectors(this.boundingBox.max,th.max),this.boundingBox.expandByPoint(tc)):(this.boundingBox.expandByPoint(th.min),this.boundingBox.expandByPoint(th.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new em);let e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new q,1/0);return}if(e){// first, find the center of the bounding sphere
let i=this.boundingSphere.center;// process morph attributes if present
if(th.setFromBufferAttribute(e),t)for(let e=0,i=t.length;e<i;e++){let i=t[e];tu.setFromBufferAttribute(i),this.morphTargetsRelative?(tc.addVectors(th.min,tu.min),th.expandByPoint(tc),tc.addVectors(th.max,tu.max),th.expandByPoint(tc)):(th.expandByPoint(tu.min),th.expandByPoint(tu.max))}th.getCenter(i);// second, try to find a boundingSphere with a radius smaller than the
// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
let n=0;for(let t=0,r=e.count;t<r;t++)tc.fromBufferAttribute(e,t),n=Math.max(n,i.distanceToSquared(tc));// process morph attributes if present
if(t)for(let r=0,s=t.length;r<s;r++){let s=t[r],a=this.morphTargetsRelative;for(let t=0,r=s.count;t<r;t++)tc.fromBufferAttribute(s,t),a&&(tl.fromBufferAttribute(e,t),tc.add(tl)),n=Math.max(n,i.distanceToSquared(tc))}this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){let e=this.index,t=this.attributes;// based on http://www.terathon.com/code/tangent.html
// (per vertex tangents)
if(null===e||void 0===t.position||void 0===t.normal||void 0===t.uv){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}let i=e.array,n=t.position.array,r=t.normal.array,s=t.uv.array,a=n.length/3;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new tt(new Float32Array(4*a),4));let o=this.getAttribute("tangent").array,l=[],h=[];for(let e=0;e<a;e++)l[e]=new q,h[e]=new q;let u=new q,c=new q,d=new q,p=new b,m=new b,f=new b,g=new q,v=new q,x=this.groups;0===x.length&&(x=[{start:0,count:i.length}]);for(let e=0,t=x.length;e<t;++e){let t=x[e],r=t.start,a=t.count;for(let e=r,t=r+a;e<t;e+=3)!function(e,t,i){u.fromArray(n,3*e),c.fromArray(n,3*t),d.fromArray(n,3*i),p.fromArray(s,2*e),m.fromArray(s,2*t),f.fromArray(s,2*i),c.sub(u),d.sub(u),m.sub(p),f.sub(p);let r=1/(m.x*f.y-f.x*m.y);isFinite(r)&&(g.copy(c).multiplyScalar(f.y).addScaledVector(d,-m.y).multiplyScalar(r),v.copy(d).multiplyScalar(m.x).addScaledVector(c,-f.x).multiplyScalar(r),l[e].add(g),l[t].add(g),l[i].add(g),h[e].add(v),h[t].add(v),h[i].add(v))}(i[e+0],i[e+1],i[e+2])}let y=new q,_=new q,M=new q,w=new q;function S(e){M.fromArray(r,3*e),w.copy(M);let t=l[e];// Gram-Schmidt orthogonalize
y.copy(t),y.sub(M.multiplyScalar(M.dot(t))).normalize(),// Calculate handedness
_.crossVectors(w,t);let i=_.dot(h[e]);o[4*e]=y.x,o[4*e+1]=y.y,o[4*e+2]=y.z,o[4*e+3]=i<0?-1:1}for(let e=0,t=x.length;e<t;++e){let t=x[e],n=t.start,r=t.count;for(let e=n,t=n+r;e<t;e+=3)S(i[e+0]),S(i[e+1]),S(i[e+2])}}computeVertexNormals(){let e=this.index,t=this.getAttribute("position");if(void 0!==t){let i=this.getAttribute("normal");if(void 0===i)i=new tt(new Float32Array(3*t.count),3),this.setAttribute("normal",i);else for(let e=0,t=i.count;e<t;e++)i.setXYZ(e,0,0,0);let n=new q,r=new q,s=new q,a=new q,o=new q,l=new q,h=new q,u=new q;// indexed elements
if(e)for(let c=0,d=e.count;c<d;c+=3){let d=e.getX(c+0),p=e.getX(c+1),m=e.getX(c+2);n.fromBufferAttribute(t,d),r.fromBufferAttribute(t,p),s.fromBufferAttribute(t,m),h.subVectors(s,r),u.subVectors(n,r),h.cross(u),a.fromBufferAttribute(i,d),o.fromBufferAttribute(i,p),l.fromBufferAttribute(i,m),a.add(h),o.add(h),l.add(h),i.setXYZ(d,a.x,a.y,a.z),i.setXYZ(p,o.x,o.y,o.z),i.setXYZ(m,l.x,l.y,l.z)}else for(let e=0,a=t.count;e<a;e+=3)n.fromBufferAttribute(t,e+0),r.fromBufferAttribute(t,e+1),s.fromBufferAttribute(t,e+2),h.subVectors(s,r),u.subVectors(n,r),h.cross(u),i.setXYZ(e+0,h.x,h.y,h.z),i.setXYZ(e+1,h.x,h.y,h.z),i.setXYZ(e+2,h.x,h.y,h.z);this.normalizeNormals(),i.needsUpdate=!0}}merge(e,t){if(!(e&&e.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);return}void 0===t&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));let i=this.attributes;for(let n in i){if(void 0===e.attributes[n])continue;let r=i[n],s=r.array,a=e.attributes[n],o=a.array,l=a.itemSize*t,h=Math.min(o.length,s.length-l);for(let e=0,t=l;e<h;e++,t++)s[t]=o[e]}return this}normalizeNormals(){let e=this.attributes.normal;for(let t=0,i=e.count;t<i;t++)tc.fromBufferAttribute(e,t),tc.normalize(),e.setXYZ(t,tc.x,tc.y,tc.z)}toNonIndexed(){function e(e,t){let i=e.array,n=e.itemSize,r=e.normalized,s=new i.constructor(t.length*n),a=0,o=0;for(let r=0,l=t.length;r<l;r++){a=e.isInterleavedBufferAttribute?t[r]*e.data.stride+e.offset:t[r]*n;for(let e=0;e<n;e++)s[o++]=i[a++]}return new tt(s,n,r)}//
if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;let t=new td,i=this.index.array,n=this.attributes;// attributes
for(let r in n){let s=n[r],a=e(s,i);t.setAttribute(r,a)}// morph attributes
let r=this.morphAttributes;for(let n in r){let s=[],a=r[n];for(let t=0,n=a.length;t<n;t++){let n=a[t],r=e(n,i);s.push(r)}t.morphAttributes[n]=s}t.morphTargetsRelative=this.morphTargetsRelative;// groups
let s=this.groups;for(let e=0,i=s.length;e<i;e++){let i=s[e];t.addGroup(i.start,i.count,i.materialIndex)}return t}toJSON(){let e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(// standard BufferGeometry serialization
e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),void 0!==this.parameters){let t=this.parameters;for(let i in t)void 0!==t[i]&&(e[i]=t[i]);return e}// for simplicity the code assumes attributes are not shared across geometries, see #15811
e.data={attributes:{}};let t=this.index;null!==t&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});let i=this.attributes;for(let t in i){let n=i[t];e.data.attributes[t]=n.toJSON(e.data)}let n={},r=!1;for(let t in this.morphAttributes){let i=this.morphAttributes[t],s=[];for(let t=0,n=i.length;t<n;t++){let n=i[t];s.push(n.toJSON(e.data))}s.length>0&&(n[t]=s,r=!0)}r&&(e.data.morphAttributes=n,e.data.morphTargetsRelative=this.morphTargetsRelative);let s=this.groups;s.length>0&&(e.data.groups=JSON.parse(JSON.stringify(s)));let a=this.boundingSphere;return null!==a&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){// reset
this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;// used for storing cloned, shared data
let t={};// name
this.name=e.name;// index
let i=e.index;null!==i&&this.setIndex(i.clone(t));// attributes
let n=e.attributes;for(let e in n){let i=n[e];this.setAttribute(e,i.clone(t))}// morph attributes
let r=e.morphAttributes;for(let e in r){let i=[],n=r[e];for(let e=0,r=n.length;e<r;e++)i.push(n[e].clone(t));this.morphAttributes[e]=i}this.morphTargetsRelative=e.morphTargetsRelative;// groups
let s=e.groups;for(let e=0,t=s.length;e<t;e++){let t=s[e];this.addGroup(t.start,t.count,t.materialIndex)}// bounding box
let a=e.boundingBox;null!==a&&(this.boundingBox=a.clone());// bounding sphere
let o=e.boundingSphere;return null!==o&&(this.boundingSphere=o.clone()),// draw range
this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,// user data
this.userData=e.userData,void 0!==e.parameters&&(this.parameters=Object.assign({},e.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}td.prototype.isBufferGeometry=!0;const tp=/*@__PURE__*/new ew,tm=/*@__PURE__*/new eM,tf=/*@__PURE__*/new em,tg=/*@__PURE__*/new q,tv=/*@__PURE__*/new q,tx=/*@__PURE__*/new q,ty=/*@__PURE__*/new q,t_=/*@__PURE__*/new q,tb=/*@__PURE__*/new q,tM=/*@__PURE__*/new q,tw=/*@__PURE__*/new q,tS=/*@__PURE__*/new q,tT=/*@__PURE__*/new b,tE=/*@__PURE__*/new b,tA=/*@__PURE__*/new b,tR=/*@__PURE__*/new q,tL=/*@__PURE__*/new q;class tC extends eY{constructor(e=new td,t=new e7){super(),this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),void 0!==e.morphTargetInfluences&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),void 0!==e.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){let e=this.geometry;if(e.isBufferGeometry){let t=e.morphAttributes,i=Object.keys(t);if(i.length>0){let e=t[i[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,i=e.length;t<i;t++){let i=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=t}}}}else{let t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(e,t){let i;let n=this.geometry,r=this.material,s=this.matrixWorld;if(void 0!==r&&(null===n.boundingSphere&&n.computeBoundingSphere(),tf.copy(n.boundingSphere),tf.applyMatrix4(s),!1!==e.ray.intersectsSphere(tf))){// Check boundingBox before continuing
if(//
tp.copy(s).invert(),tm.copy(e.ray).applyMatrix4(tp),null!==n.boundingBox&&!1===tm.intersectsBox(n.boundingBox))return;if(n.isBufferGeometry){let s=n.index,a=n.attributes.position,o=n.morphAttributes.position,l=n.morphTargetsRelative,h=n.attributes.uv,u=n.attributes.uv2,c=n.groups,d=n.drawRange;if(null!==s){// indexed buffer geometry
if(Array.isArray(r))for(let n=0,p=c.length;n<p;n++){let p=c[n],m=r[p.materialIndex],f=Math.max(p.start,d.start),g=Math.min(s.count,Math.min(p.start+p.count,d.start+d.count));for(let n=f;n<g;n+=3){let r=s.getX(n),c=s.getX(n+1),d=s.getX(n+2);(i=tP(this,m,e,tm,a,o,l,h,u,r,c,d))&&(i.faceIndex=Math.floor(n/3),i.face.materialIndex=p.materialIndex,t.push(i))}}else{let n=Math.max(0,d.start),c=Math.min(s.count,d.start+d.count);for(let d=n;d<c;d+=3){let n=s.getX(d),c=s.getX(d+1),p=s.getX(d+2);(i=tP(this,r,e,tm,a,o,l,h,u,n,c,p))&&(i.faceIndex=Math.floor(d/3),t.push(i))}}}else if(void 0!==a){// non-indexed buffer geometry
if(Array.isArray(r))for(let n=0,s=c.length;n<s;n++){let s=c[n],p=r[s.materialIndex],m=Math.max(s.start,d.start),f=Math.min(a.count,Math.min(s.start+s.count,d.start+d.count));for(let n=m;n<f;n+=3){let r=n,c=n+1,d=n+2;(i=tP(this,p,e,tm,a,o,l,h,u,r,c,d))&&(i.faceIndex=Math.floor(n/3),i.face.materialIndex=s.materialIndex,t.push(i))}}else{let n=Math.max(0,d.start),s=Math.min(a.count,d.start+d.count);for(let c=n;c<s;c+=3){let n=c,s=c+1,d=c+2;(i=tP(this,r,e,tm,a,o,l,h,u,n,s,d))&&(i.faceIndex=Math.floor(c/3),t.push(i))}}}}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}}function tP(e,t,i,n,r,s,a,o,l,h,u,c){tg.fromBufferAttribute(r,h),tv.fromBufferAttribute(r,u),tx.fromBufferAttribute(r,c);let d=e.morphTargetInfluences;if(s&&d){tM.set(0,0,0),tw.set(0,0,0),tS.set(0,0,0);for(let e=0,t=s.length;e<t;e++){let t=d[e],i=s[e];0!==t&&(ty.fromBufferAttribute(i,h),t_.fromBufferAttribute(i,u),tb.fromBufferAttribute(i,c),a?(tM.addScaledVector(ty,t),tw.addScaledVector(t_,t),tS.addScaledVector(tb,t)):(tM.addScaledVector(ty.sub(tg),t),tw.addScaledVector(t_.sub(tv),t),tS.addScaledVector(tb.sub(tx),t)))}tg.add(tM),tv.add(tw),tx.add(tS)}e.isSkinnedMesh&&(e.boneTransform(h,tg),e.boneTransform(u,tv),e.boneTransform(c,tx));let p=function(e,t,i,n,r,s,a,o){if(null===(1===t.side?n.intersectTriangle(a,s,r,!0,o):n.intersectTriangle(r,s,a,2!==t.side,o)))return null;tL.copy(o),tL.applyMatrix4(e.matrixWorld);let l=i.ray.origin.distanceTo(tL);return l<i.near||l>i.far?null:{distance:l,point:tL.clone(),object:e}}(e,t,i,n,tg,tv,tx,tR);if(p){o&&(tT.fromBufferAttribute(o,h),tE.fromBufferAttribute(o,u),tA.fromBufferAttribute(o,c),p.uv=e5.getUV(tR,tg,tv,tx,tT,tE,tA,new b)),l&&(tT.fromBufferAttribute(l,h),tE.fromBufferAttribute(l,u),tA.fromBufferAttribute(l,c),p.uv2=e5.getUV(tR,tg,tv,tx,tT,tE,tA,new b));let e={a:h,b:u,c:c,normal:new q,materialIndex:0};e5.getNormal(tg,tv,tx,e.normal),p.face=e}return p}tC.prototype.isMesh=!0;class tI extends td{constructor(e=1,t=1,i=1,n=1,r=1,s=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:i,widthSegments:n,heightSegments:r,depthSegments:s};let a=this;// segments
n=Math.floor(n),r=Math.floor(r),s=Math.floor(s);// buffers
let o=[],l=[],h=[],u=[],c=0,d=0;function p(e,t,i,n,r,s,p,m,f,g,v){let x=s/f,y=p/g,_=s/2,b=p/2,M=m/2,w=f+1,S=g+1,T=0,E=0,A=new q;// generate vertices, normals and uvs
for(let s=0;s<S;s++){let a=s*y-b;for(let o=0;o<w;o++){let c=o*x-_;// set values to correct vector component
A[e]=c*n,A[t]=a*r,A[i]=M,// now apply vector to vertex buffer
l.push(A.x,A.y,A.z),// set values to correct vector component
A[e]=0,A[t]=0,A[i]=m>0?1:-1,// now apply vector to normal buffer
h.push(A.x,A.y,A.z),// uvs
u.push(o/f),u.push(1-s/g),// counters
T+=1}}// indices
// 1. you need three indices to draw a single face
// 2. a single segment consists of two faces
// 3. so we need to generate six (2*3) indices per segment
for(let e=0;e<g;e++)for(let t=0;t<f;t++){let i=c+t+w*e,n=c+t+w*(e+1),r=c+(t+1)+w*(e+1),s=c+(t+1)+w*e;// faces
o.push(i,n,s),o.push(n,r,s),// increase counter
E+=6}// add a group to the geometry. this will ensure multi material support
a.addGroup(d,E,v),// calculate new start value for groups
d+=E,// update total number of vertices
c+=T}// build each side of the box geometry
p("z","y","x",-1,-1,i,t,e,s,r,0),p("z","y","x",1,-1,i,t,-e,s,r,1),p("x","z","y",1,1,e,i,t,n,s,2),p("x","z","y",1,-1,e,i,-t,n,s,3),p("x","y","z",1,-1,e,t,i,n,r,4),p("x","y","z",-1,-1,e,t,-i,n,r,5),// build geometry
this.setIndex(o),this.setAttribute("position",new tr(l,3)),this.setAttribute("normal",new tr(h,3)),this.setAttribute("uv",new tr(u,2))}static fromJSON(e){return new tI(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}/**
 * Uniform Utilities
 */function tD(e){let t={};for(let i in e)for(let n in t[i]={},e[i]){let r=e[i][n];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?t[i][n]=r.clone():Array.isArray(r)?t[i][n]=r.slice():t[i][n]=r}return t}function tN(e){let t={};for(let i=0;i<e.length;i++){let n=tD(e[i]);for(let e in n)t[e]=n[e]}return t}// Legacy
const tO={clone:tD,merge:tN};class tz extends e8{constructor(e){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader="void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1// set to use shader texture LOD
},// When rendered geometry doesn't include these attributes but the material does,
// use these default values in WebGL. This avoids errors when buffer data is missing.
this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==e&&(void 0!==e.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=tD(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){let t=super.toJSON(e);for(let i in t.glslVersion=this.glslVersion,t.uniforms={},this.uniforms){let n=this.uniforms[i],r=n.value;r&&r.isTexture?t.uniforms[i]={type:"t",value:r.toJSON(e).uuid}:r&&r.isColor?t.uniforms[i]={type:"c",value:r.getHex()}:r&&r.isVector2?t.uniforms[i]={type:"v2",value:r.toArray()}:r&&r.isVector3?t.uniforms[i]={type:"v3",value:r.toArray()}:r&&r.isVector4?t.uniforms[i]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?t.uniforms[i]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?t.uniforms[i]={type:"m4",value:r.toArray()}:t.uniforms[i]={value:r}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;let i={};for(let e in this.extensions)!0===this.extensions[e]&&(i[e]=!0);return Object.keys(i).length>0&&(t.extensions=i),t}}tz.prototype.isShaderMaterial=!0;class tU extends eY{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new ew,this.projectionMatrix=new ew,this.projectionMatrixInverse=new ew}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);let t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}tU.prototype.isCamera=!0;class tH extends tU{constructor(e=50,t=1,i=.1,n=2e3){super(),this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=i,this.far=n,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=null===e.view?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */setFocalLength(e){/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */let t=.5*this.getFilmHeight()/e;this.fov=2*d*Math.atan(t),this.updateProjectionMatrix()}/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */getFocalLength(){let e=Math.tan(.5*c*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return 2*d*Math.atan(Math.tan(.5*c*this.fov)/this.zoom)}getFilmWidth(){// film not completely covered in portrait format (aspect < 1)
return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){// film not completely covered in landscape format (aspect > 1)
return this.filmGauge/Math.max(this.aspect,1)}/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */setViewOffset(e,t,i,n,r,s){this.aspect=e/t,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=n,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){let e=this.near,t=e*Math.tan(.5*c*this.fov)/this.zoom,i=2*t,n=this.aspect*i,r=-.5*n,s=this.view;if(null!==this.view&&this.view.enabled){let e=s.fullWidth,a=s.fullHeight;r+=s.offsetX*n/e,t-=s.offsetY*i/a,n*=s.width/e,i*=s.height/a}let a=this.filmOffset;0!==a&&(r+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+n,t,t-i,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){let t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,null!==this.view&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}tH.prototype.isPerspectiveCamera=!0;class tF extends eY{constructor(e,t,i){if(super(),this.type="CubeCamera",!0!==i.isWebGLCubeRenderTarget){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=i;let n=new tH(90,1,e,t);n.layers=this.layers,n.up.set(0,-1,0),n.lookAt(new q(1,0,0)),this.add(n);let r=new tH(90,1,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new q(-1,0,0)),this.add(r);let s=new tH(90,1,e,t);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(new q(0,1,0)),this.add(s);let a=new tH(90,1,e,t);a.layers=this.layers,a.up.set(0,0,-1),a.lookAt(new q(0,-1,0)),this.add(a);let o=new tH(90,1,e,t);o.layers=this.layers,o.up.set(0,-1,0),o.lookAt(new q(0,0,1)),this.add(o);let l=new tH(90,1,e,t);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new q(0,0,-1)),this.add(l)}update(e,t){null===this.parent&&this.updateMatrixWorld();let i=this.renderTarget,[n,r,s,a,o,l]=this.children,h=e.getRenderTarget(),u=e.outputEncoding,c=e.toneMapping,d=e.xr.enabled;e.outputEncoding=3e3,e.toneMapping=0,e.xr.enabled=!1;let p=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,e.setRenderTarget(i,0),e.render(t,n),e.setRenderTarget(i,1),e.render(t,r),e.setRenderTarget(i,2),e.render(t,s),e.setRenderTarget(i,3),e.render(t,a),e.setRenderTarget(i,4),e.render(t,o),i.texture.generateMipmaps=p,e.setRenderTarget(i,5),e.render(t,l),e.setRenderTarget(h),e.outputEncoding=u,e.toneMapping=c,e.xr.enabled=d,i.texture.needsPMREMUpdate=!0}}class tB extends B{constructor(e,t,i,n,r,s,a,o,l,h){super(e=void 0!==e?e:[],t=void 0!==t?t:301,i,n,r,s,a,o,l,h),this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}tB.prototype.isCubeTexture=!0;class tG extends k{constructor(e,t={}){super(e,e,t);let i={width:e,height:e,depth:1},n=[i,i,i,i,i,i];this.texture=new tB(n,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).
this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==t.generateMipmaps&&t.generateMipmaps,this.texture.minFilter=void 0!==t.minFilter?t.minFilter:1006}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;let i={uniforms:{tEquirect:{value:null}},vertexShader:/* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:/* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},n=new tI(5,5,5),r=new tz({name:"CubemapFromEquirect",uniforms:tD(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:1,blending:0});r.uniforms.tEquirect.value=t;let s=new tC(n,r),a=t.minFilter;1008===t.minFilter&&(t.minFilter=1006);let o=new tF(1,10,this);return o.update(e,s),t.minFilter=a,s.geometry.dispose(),s.material.dispose(),this}clear(e,t,i,n){let r=e.getRenderTarget();for(let r=0;r<6;r++)e.setRenderTarget(this,r),e.clear(t,i,n);e.setRenderTarget(r)}}tG.prototype.isWebGLCubeRenderTarget=!0;const tk=/*@__PURE__*/new q,tV=/*@__PURE__*/new q,tW=/*@__PURE__*/new M;class tj{constructor(e=new q(1,0,0),t=0){// normal is assumed to be normalized
this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,i,n){return this.normal.set(e,t,i),this.constant=n,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,i){let n=tk.subVectors(i,t).cross(tV.subVectors(e,t)).normalize();return(// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
this.setFromNormalAndCoplanarPoint(n,e),this)}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){// Note: will lead to a divide by zero if the plane is invalid.
let e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){let i=e.delta(tk),n=this.normal.dot(i);if(0===n)return(// line is coplanar, return origin
0===this.distanceToPoint(e.start)?t.copy(e.start):null);let r=-(e.start.dot(this.normal)+this.constant)/n;return r<0||r>1?null:t.copy(i).multiplyScalar(r).add(e.start)}intersectsLine(e){// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
let t=this.distanceToPoint(e.start),i=this.distanceToPoint(e.end);return t<0&&i>0||i<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){let i=t||tW.getNormalMatrix(e),n=this.coplanarPoint(tk).applyMatrix4(e),r=this.normal.applyMatrix3(i).normalize();return this.constant=-n.dot(r),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}tj.prototype.isPlane=!0;const tq=/*@__PURE__*/new em,tX=/*@__PURE__*/new q;class tY{constructor(e=new tj,t=new tj,i=new tj,n=new tj,r=new tj,s=new tj){this.planes=[e,t,i,n,r,s]}set(e,t,i,n,r,s){let a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(i),a[3].copy(n),a[4].copy(r),a[5].copy(s),this}copy(e){let t=this.planes;for(let i=0;i<6;i++)t[i].copy(e.planes[i]);return this}setFromProjectionMatrix(e){let t=this.planes,i=e.elements,n=i[0],r=i[1],s=i[2],a=i[3],o=i[4],l=i[5],h=i[6],u=i[7],c=i[8],d=i[9],p=i[10],m=i[11],f=i[12],g=i[13],v=i[14],x=i[15];return t[0].setComponents(a-n,u-o,m-c,x-f).normalize(),t[1].setComponents(a+n,u+o,m+c,x+f).normalize(),t[2].setComponents(a+r,u+l,m+d,x+g).normalize(),t[3].setComponents(a-r,u-l,m-d,x-g).normalize(),t[4].setComponents(a-s,u-h,m-p,x-v).normalize(),t[5].setComponents(a+s,u+h,m+p,x+v).normalize(),this}intersectsObject(e){let t=e.geometry;return null===t.boundingSphere&&t.computeBoundingSphere(),tq.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(tq)}intersectsSprite(e){return tq.center.set(0,0,0),tq.radius=.7071067811865476,tq.applyMatrix4(e.matrixWorld),this.intersectsSphere(tq)}intersectsSphere(e){let t=this.planes,i=e.center,n=-e.radius;for(let e=0;e<6;e++){let r=t[e].distanceToPoint(i);if(r<n)return!1}return!0}intersectsBox(e){let t=this.planes;for(let i=0;i<6;i++){let n=t[i];if(// corner at max distance
tX.x=n.normal.x>0?e.max.x:e.min.x,tX.y=n.normal.y>0?e.max.y:e.min.y,tX.z=n.normal.z>0?e.max.z:e.min.z,0>n.distanceToPoint(tX))return!1}return!0}containsPoint(e){let t=this.planes;for(let i=0;i<6;i++)if(0>t[i].distanceToPoint(e))return!1;return!0}clone(){return new this.constructor().copy(this)}}function tJ(){let e=null,t=!1,i=null,n=null;function r(t,s){i(t,s),n=e.requestAnimationFrame(r)}return{start:function(){!0!==t&&null!==i&&(n=e.requestAnimationFrame(r),t=!0)},stop:function(){e.cancelAnimationFrame(n),t=!1},setAnimationLoop:function(e){i=e},setContext:function(t){e=t}}}function tZ(e,t){let i=t.isWebGL2,n=new WeakMap;return{get://
function(e){return e.isInterleavedBufferAttribute&&(e=e.data),n.get(e)},remove:function(t){t.isInterleavedBufferAttribute&&(t=t.data);let i=n.get(t);i&&(e.deleteBuffer(i.buffer),n.delete(t))},update:function(t,r){if(t.isGLBufferAttribute){let e=n.get(t);(!e||e.version<t.version)&&n.set(t,{buffer:t.buffer,type:t.type,bytesPerElement:t.elementSize,version:t.version});return}t.isInterleavedBufferAttribute&&(t=t.data);let s=n.get(t);void 0===s?n.set(t,function(t,n){let r;let s=t.array,a=t.usage,o=e.createBuffer();if(e.bindBuffer(n,o),e.bufferData(n,s,a),t.onUploadCallback(),s instanceof Float32Array)r=5126;else if(s instanceof Uint16Array){if(t.isFloat16BufferAttribute){if(i)r=5131;else throw Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.")}else r=5123}else if(s instanceof Int16Array)r=5122;else if(s instanceof Uint32Array)r=5125;else if(s instanceof Int32Array)r=5124;else if(s instanceof Int8Array)r=5120;else if(s instanceof Uint8Array)r=5121;else if(s instanceof Uint8ClampedArray)r=5121;else throw Error("THREE.WebGLAttributes: Unsupported buffer data format: "+s);return{buffer:o,type:r,bytesPerElement:s.BYTES_PER_ELEMENT,version:t.version}}(t,r)):s.version<t.version&&(!function(t,n,r){let s=n.array,a=n.updateRange;e.bindBuffer(r,t),-1===a.count?e.bufferSubData(r,0,s):(i?e.bufferSubData(r,a.offset*s.BYTES_PER_ELEMENT,s,a.offset,a.count):e.bufferSubData(r,a.offset*s.BYTES_PER_ELEMENT,s.subarray(a.offset,a.offset+a.count)),a.count=-1)}(s.buffer,t,r),s.version=t.version)}}}class tK extends td{constructor(e=1,t=1,i=1,n=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:i,heightSegments:n};let r=e/2,s=t/2,a=Math.floor(i),o=Math.floor(n),l=a+1,h=o+1,u=e/a,c=t/o,d=[],p=[],m=[],f=[];for(let e=0;e<h;e++){let t=e*c-s;for(let i=0;i<l;i++){let n=i*u-r;p.push(n,-t,0),m.push(0,0,1),f.push(i/a),f.push(1-e/o)}}for(let e=0;e<o;e++)for(let t=0;t<a;t++){let i=t+l*e,n=t+l*(e+1),r=t+1+l*(e+1),s=t+1+l*e;d.push(i,n,s),d.push(n,r,s)}this.setIndex(d),this.setAttribute("position",new tr(p,3)),this.setAttribute("normal",new tr(m,3)),this.setAttribute("uv",new tr(f,2))}static fromJSON(e){return new tK(e.width,e.height,e.widthSegments,e.heightSegments)}}const tQ={alphamap_fragment:"#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n	varying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif",map_fragment:"#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n	uniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif",morphcolor_vertex:"#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif",output_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef texture2DLodEXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	gl_FragColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n	#endif\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}"},t$={common:{diffuse:{value:new O(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new M},uv2Transform:{value:new M},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}// basic, lambert, phong
},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new b(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new O(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new O(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new M}},sprite:{diffuse:{value:new O(16777215)},opacity:{value:1},center:{value:new b(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new M}}},t0={basic:{uniforms:tN([t$.common,t$.specularmap,t$.envmap,t$.aomap,t$.lightmap,t$.fog]),vertexShader:tQ.meshbasic_vert,fragmentShader:tQ.meshbasic_frag},lambert:{uniforms:tN([t$.common,t$.specularmap,t$.envmap,t$.aomap,t$.lightmap,t$.emissivemap,t$.fog,t$.lights,{emissive:{value:new O(0)}}]),vertexShader:tQ.meshlambert_vert,fragmentShader:tQ.meshlambert_frag},phong:{uniforms:tN([t$.common,t$.specularmap,t$.envmap,t$.aomap,t$.lightmap,t$.emissivemap,t$.bumpmap,t$.normalmap,t$.displacementmap,t$.fog,t$.lights,{emissive:{value:new O(0)},specular:{value:new O(1118481)},shininess:{value:30}}]),vertexShader:tQ.meshphong_vert,fragmentShader:tQ.meshphong_frag},standard:{uniforms:tN([t$.common,t$.envmap,t$.aomap,t$.lightmap,t$.emissivemap,t$.bumpmap,t$.normalmap,t$.displacementmap,t$.roughnessmap,t$.metalnessmap,t$.fog,t$.lights,{emissive:{value:new O(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}// temporary
}]),vertexShader:tQ.meshphysical_vert,fragmentShader:tQ.meshphysical_frag},toon:{uniforms:tN([t$.common,t$.aomap,t$.lightmap,t$.emissivemap,t$.bumpmap,t$.normalmap,t$.displacementmap,t$.gradientmap,t$.fog,t$.lights,{emissive:{value:new O(0)}}]),vertexShader:tQ.meshtoon_vert,fragmentShader:tQ.meshtoon_frag},matcap:{uniforms:tN([t$.common,t$.bumpmap,t$.normalmap,t$.displacementmap,t$.fog,{matcap:{value:null}}]),vertexShader:tQ.meshmatcap_vert,fragmentShader:tQ.meshmatcap_frag},points:{uniforms:tN([t$.points,t$.fog]),vertexShader:tQ.points_vert,fragmentShader:tQ.points_frag},dashed:{uniforms:tN([t$.common,t$.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:tQ.linedashed_vert,fragmentShader:tQ.linedashed_frag},depth:{uniforms:tN([t$.common,t$.displacementmap]),vertexShader:tQ.depth_vert,fragmentShader:tQ.depth_frag},normal:{uniforms:tN([t$.common,t$.bumpmap,t$.normalmap,t$.displacementmap,{opacity:{value:1}}]),vertexShader:tQ.meshnormal_vert,fragmentShader:tQ.meshnormal_frag},sprite:{uniforms:tN([t$.sprite,t$.fog]),vertexShader:tQ.sprite_vert,fragmentShader:tQ.sprite_frag},background:{uniforms:{uvTransform:{value:new M},t2D:{value:null}},vertexShader:tQ.background_vert,fragmentShader:tQ.background_frag},/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */cube:{uniforms:tN([t$.envmap,{opacity:{value:1}}]),vertexShader:tQ.cube_vert,fragmentShader:tQ.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:tQ.equirect_vert,fragmentShader:tQ.equirect_frag},distanceRGBA:{uniforms:tN([t$.common,t$.displacementmap,{referencePosition:{value:new q},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:tQ.distanceRGBA_vert,fragmentShader:tQ.distanceRGBA_frag},shadow:{uniforms:tN([t$.lights,t$.fog,{color:{value:new O(0)},opacity:{value:1}}]),vertexShader:tQ.shadow_vert,fragmentShader:tQ.shadow_frag}};function t1(e,t,i,n,r,s){let a,o;let l=new O(0),h=!0===r?0:1,u=null,c=0,d=null;function p(e,t){i.buffers.color.setClear(e.r,e.g,e.b,t,s)}return{getClearColor:function(){return l},setClearColor:function(e,t=1){l.set(e),p(l,h=t)},getClearAlpha:function(){return h},setClearAlpha:function(e){p(l,h=e)},render:function(i,r){let s=!1,m=!0===r.isScene?r.background:null;m&&m.isTexture&&(m=t.get(m));// Ignore background in AR
// TODO: Reconsider this.
let f=e.xr,g=f.getSession&&f.getSession();g&&"additive"===g.environmentBlendMode&&(m=null),null===m?p(l,h):m&&m.isColor&&(p(m,1),s=!0),(e.autoClear||s)&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),m&&(m.isCubeTexture||306===m.mapping)?(void 0===o&&((o=new tC(new tI(1,1,1),new tz({name:"BackgroundCubeMaterial",uniforms:tD(t0.cube.uniforms),vertexShader:t0.cube.vertexShader,fragmentShader:t0.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),o.geometry.deleteAttribute("uv"),o.onBeforeRender=function(e,t,i){this.matrixWorld.copyPosition(i.matrixWorld)},// enable code injection for non-built-in material
Object.defineProperty(o.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(o)),o.material.uniforms.envMap.value=m,o.material.uniforms.flipEnvMap.value=m.isCubeTexture&&!1===m.isRenderTargetTexture?-1:1,(u!==m||c!==m.version||d!==e.toneMapping)&&(o.material.needsUpdate=!0,u=m,c=m.version,d=e.toneMapping),// push to the pre-sorted opaque render list
i.unshift(o,o.geometry,o.material,0,0,null)):m&&m.isTexture&&(void 0===a&&((a=new tC(new tK(2,2),new tz({name:"BackgroundMaterial",uniforms:tD(t0.background.uniforms),vertexShader:t0.background.vertexShader,fragmentShader:t0.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),// enable code injection for non-built-in material
Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(a)),a.material.uniforms.t2D.value=m,!0===m.matrixAutoUpdate&&m.updateMatrix(),a.material.uniforms.uvTransform.value.copy(m.matrix),(u!==m||c!==m.version||d!==e.toneMapping)&&(a.material.needsUpdate=!0,u=m,c=m.version,d=e.toneMapping),// push to the pre-sorted opaque render list
i.unshift(a,a.geometry,a.material,0,0,null))}}}function t3(e,t,i,n){let r=e.getParameter(34921),s=n.isWebGL2?null:t.get("OES_vertex_array_object"),a=n.isWebGL2||null!==s,o={},l=p(null),h=l,u=!1;function c(t){return n.isWebGL2?e.bindVertexArray(t):s.bindVertexArrayOES(t)}function d(t){return n.isWebGL2?e.deleteVertexArray(t):s.deleteVertexArrayOES(t)}function p(e){let t=[],i=[],n=[];for(let e=0;e<r;e++)t[e]=0,i[e]=0,n[e]=0;return{// for backward compatibility on non-VAO support browser
geometry:null,program:null,wireframe:!1,newAttributes:t,enabledAttributes:i,attributeDivisors:n,object:e,attributes:{},index:null}}function m(){let e=h.newAttributes;for(let t=0,i=e.length;t<i;t++)e[t]=0}function f(e){g(e,0)}function g(i,r){let s=h.newAttributes,a=h.enabledAttributes,o=h.attributeDivisors;if(s[i]=1,0===a[i]&&(e.enableVertexAttribArray(i),a[i]=1),o[i]!==r){let s=n.isWebGL2?e:t.get("ANGLE_instanced_arrays");s[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](i,r),o[i]=r}}function v(){let t=h.newAttributes,i=h.enabledAttributes;for(let n=0,r=i.length;n<r;n++)i[n]!==t[n]&&(e.disableVertexAttribArray(n),i[n]=0)}function x(t,i,r,s,a,o){!0===n.isWebGL2&&(5124===r||5125===r)?e.vertexAttribIPointer(t,i,r,a,o):e.vertexAttribPointer(t,i,r,s,a,o)}function y(){_(),u=!0,h!==l&&c((h=l).object)}// for backward-compatibility
function _(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function(r,l,d,y,_){let b=!1;if(a){let t=function(t,i,r){let a=!0===r.wireframe,l=o[t.id];void 0===l&&(l={},o[t.id]=l);let h=l[i.id];void 0===h&&(h={},l[i.id]=h);let u=h[a];return void 0===u&&(u=p(n.isWebGL2?e.createVertexArray():s.createVertexArrayOES()),h[a]=u),u}(y,d,l);h!==t&&c((h=t).object),(b=function(e,t){let i=h.attributes,n=e.attributes,r=0;for(let e in n){let t=i[e],s=n[e];if(void 0===t||t.attribute!==s||t.data!==s.data)return!0;r++}return h.attributesNum!==r||h.index!==t}(y,_))&&function(e,t){let i={},n=e.attributes,r=0;for(let e in n){let t=n[e],s={};s.attribute=t,t.data&&(s.data=t.data),i[e]=s,r++}h.attributes=i,h.attributesNum=r,h.index=t}(y,_)}else{let e=!0===l.wireframe;(h.geometry!==y.id||h.program!==d.id||h.wireframe!==e)&&(h.geometry=y.id,h.program=d.id,h.wireframe=e,b=!0)}!0===r.isInstancedMesh&&(b=!0),null!==_&&i.update(_,34963),(b||u)&&(u=!1,function(r,s,a,o){if(!1===n.isWebGL2&&(r.isInstancedMesh||o.isInstancedBufferGeometry)&&null===t.get("ANGLE_instanced_arrays"))return;m();let l=o.attributes,h=a.getAttributes(),u=s.defaultAttributeValues;for(let t in h){let n=h[t];if(n.location>=0){let s=l[t];if(void 0===s&&("instanceMatrix"===t&&r.instanceMatrix&&(s=r.instanceMatrix),"instanceColor"===t&&r.instanceColor&&(s=r.instanceColor)),void 0!==s){let t=s.normalized,a=s.itemSize,l=i.get(s);// TODO Attribute may not be available on context restore
if(void 0===l)continue;let h=l.buffer,u=l.type,c=l.bytesPerElement;if(s.isInterleavedBufferAttribute){let i=s.data,l=i.stride,d=s.offset;if(i.isInstancedInterleavedBuffer){for(let e=0;e<n.locationSize;e++)g(n.location+e,i.meshPerAttribute);!0!==r.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=i.meshPerAttribute*i.count)}else for(let e=0;e<n.locationSize;e++)f(n.location+e);e.bindBuffer(34962,h);for(let e=0;e<n.locationSize;e++)x(n.location+e,a/n.locationSize,u,t,l*c,(d+a/n.locationSize*e)*c)}else{if(s.isInstancedBufferAttribute){for(let e=0;e<n.locationSize;e++)g(n.location+e,s.meshPerAttribute);!0!==r.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=s.meshPerAttribute*s.count)}else for(let e=0;e<n.locationSize;e++)f(n.location+e);e.bindBuffer(34962,h);for(let e=0;e<n.locationSize;e++)x(n.location+e,a/n.locationSize,u,t,a*c,a/n.locationSize*e*c)}}else if(void 0!==u){let i=u[t];if(void 0!==i)switch(i.length){case 2:e.vertexAttrib2fv(n.location,i);break;case 3:e.vertexAttrib3fv(n.location,i);break;case 4:e.vertexAttrib4fv(n.location,i);break;default:e.vertexAttrib1fv(n.location,i)}}}}v()}(r,l,d,y),null!==_&&e.bindBuffer(34963,i.get(_).buffer))},reset:y,resetDefaultState:_,dispose:function(){for(let e in y(),o){let t=o[e];for(let e in t){let i=t[e];for(let e in i)d(i[e].object),delete i[e];delete t[e]}delete o[e]}},releaseStatesOfGeometry:function(e){if(void 0===o[e.id])return;let t=o[e.id];for(let e in t){let i=t[e];for(let e in i)d(i[e].object),delete i[e];delete t[e]}delete o[e.id]},releaseStatesOfProgram:function(e){for(let t in o){let i=o[t];if(void 0===i[e.id])continue;let n=i[e.id];for(let e in n)d(n[e].object),delete n[e];delete i[e.id]}},initAttributes:m,enableAttribute:f,disableUnusedAttributes:v}}function t2(e,t,i,n){let r;let s=n.isWebGL2;//
this.setMode=function(e){r=e},this.render=function(t,n){e.drawArrays(r,t,n),i.update(n,r,1)},this.renderInstances=function(n,a,o){let l,h;if(0!==o){if(s)l=e,h="drawArraysInstanced";else if(l=t.get("ANGLE_instanced_arrays"),h="drawArraysInstancedANGLE",null===l){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}l[h](r,n,a,o),i.update(a,r,o)}}}function t4(e,t,i){let n;function r(t){if("highp"===t){if(e.getShaderPrecisionFormat(35633,36338).precision>0&&e.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";t="mediump"}return"mediump"===t&&e.getShaderPrecisionFormat(35633,36337).precision>0&&e.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}let s="undefined"!=typeof WebGL2RenderingContext&&e instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&e instanceof WebGL2ComputeRenderingContext,a=void 0!==i.precision?i.precision:"highp",o=r(a);o!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",o,"instead."),a=o);let l=s||t.has("WEBGL_draw_buffers"),h=!0===i.logarithmicDepthBuffer,u=e.getParameter(34930),c=e.getParameter(35660),d=e.getParameter(3379),p=e.getParameter(34076),m=e.getParameter(34921),f=e.getParameter(36347),g=e.getParameter(36348),v=e.getParameter(36349),x=c>0,y=s||t.has("OES_texture_float"),_=s?e.getParameter(36183):0;return{isWebGL2:s,drawBuffers:l,getMaxAnisotropy:function(){if(void 0!==n)return n;if(!0===t.has("EXT_texture_filter_anisotropic")){let i=t.get("EXT_texture_filter_anisotropic");n=e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n},getMaxPrecision:r,precision:a,logarithmicDepthBuffer:h,maxTextures:u,maxVertexTextures:c,maxTextureSize:d,maxCubemapSize:p,maxAttributes:m,maxVertexUniforms:f,maxVaryings:g,maxFragmentUniforms:v,vertexTextures:x,floatFragmentTextures:y,floatVertexTextures:x&&y,maxSamples:_}}function t5(e){let t=this,i=null,n=0,r=!1,s=!1,a=new tj,o=new M,l={value:null,needsUpdate:!1};function h(){l.value!==i&&(l.value=i,l.needsUpdate=n>0),t.numPlanes=n,t.numIntersection=0}function u(e,i,n,r){let s=null!==e?e.length:0,h=null;if(0!==s){if(h=l.value,!0!==r||null===h){let t=n+4*s,r=i.matrixWorldInverse;o.getNormalMatrix(r),(null===h||h.length<t)&&(h=new Float32Array(t));for(let t=0,i=n;t!==s;++t,i+=4)a.copy(e[t]).applyMatrix4(r,o),a.normal.toArray(h,i),h[i+3]=a.constant}l.value=h,l.needsUpdate=!0}return t.numPlanes=s,t.numIntersection=0,h}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(e,t,s){let a=0!==e.length||t||// enable state of previous frame - the clipping code has to
// run another frame in order to reset the state:
0!==n||r;return r=t,i=u(e,s,0),n=e.length,a},this.beginShadows=function(){s=!0,u(null)},this.endShadows=function(){s=!1,h()},this.setState=function(t,a,o){let c=t.clippingPlanes,d=t.clipIntersection,p=t.clipShadows,m=e.get(t);if(r&&null!==c&&0!==c.length&&(!s||p)){let e=s?0:n,t=4*e,r=m.clippingState||null;l.value=r,r=u(c,a,t,o);for(let e=0;e!==t;++e)r[e]=i[e];m.clippingState=r,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=e}else // there's no local clipping
s?u(null):h()}}function t6(e){let t=new WeakMap;function i(e,t){return 303===t?e.mapping=301:304===t&&(e.mapping=302),e}function n(e){let i=e.target;i.removeEventListener("dispose",n);let r=t.get(i);void 0!==r&&(t.delete(i),r.dispose())}return{get:function(r){if(r&&r.isTexture&&!1===r.isRenderTargetTexture){let s=r.mapping;if(303===s||304===s){if(t.has(r)){let e=t.get(r).texture;return i(e,r.mapping)}{let s=r.image;if(!s||!(s.height>0))return null;{let a=new tG(s.height/2);return a.fromEquirectangularTexture(e,r),t.set(r,a),r.addEventListener("dispose",n),i(a.texture,r.mapping)}}}}return r},dispose:function(){t=new WeakMap}}}t0.physical={uniforms:tN([t0.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new b(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenColor:{value:new O(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new b},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new O(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new O(1,1,1)},specularColorMap:{value:null}}]),vertexShader:tQ.meshphysical_vert,fragmentShader:tQ.meshphysical_frag};class t8 extends tU{constructor(e=-1,t=1,i=1,n=-1,r=.1,s=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=i,this.bottom=n,this.near=r,this.far=s,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=null===e.view?null:Object.assign({},e.view),this}setViewOffset(e,t,i,n,r,s){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=n,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){let e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,n=(this.top+this.bottom)/2,r=i-e,s=i+e,a=n+t,o=n-t;if(null!==this.view&&this.view.enabled){let e=(this.right-this.left)/this.view.fullWidth/this.zoom,t=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=e*this.view.offsetX,s=r+e*this.view.width,a-=t*this.view.offsetY,o=a-t*this.view.height}this.projectionMatrix.makeOrthographic(r,s,a,o,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){let t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,null!==this.view&&(t.object.view=Object.assign({},this.view)),t}}t8.prototype.isOrthographicCamera=!0;// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const t7=[.125,.215,.35,.446,.526,.582],t9=/*@__PURE__*/new t8,ie=/*@__PURE__*/new O;let it=null;// Golden Ratio
const ii=(1+Math.sqrt(5))/2,ir=1/ii,is=[/*@__PURE__*/new q(1,1,1),/*@__PURE__*/new q(-1,1,1),/*@__PURE__*/new q(1,1,-1),/*@__PURE__*/new q(-1,1,-1),/*@__PURE__*/new q(0,ii,ir),/*@__PURE__*/new q(0,ii,-ir),/*@__PURE__*/new q(ir,0,ii),/*@__PURE__*/new q(-ir,0,ii),/*@__PURE__*/new q(ii,ir,0),/*@__PURE__*/new q(-ii,ir,0)];/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/class ia{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */fromScene(e,t=0,i=.1,n=100){it=this._renderer.getRenderTarget(),this._setSize(256);let r=this._allocateTargets();return r.depthBuffer=!0,this._sceneToCubeUV(e,i,n,r),t>0&&this._blur(r,0,0,t),this._applyPMREM(r),this._cleanup(r),r}/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * or HDR. The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */fromEquirectangular(e,t=null){return this._fromTexture(e,t)}/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * or HDR. The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */fromCubemap(e,t=null){return this._fromTexture(e,t)}/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=iu(),this._compileMaterial(this._cubemapMaterial))}/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=ih(),this._compileMaterial(this._equirectMaterial))}/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}// private interface
_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(it),e.scissorTest=!1,il(e,0,0,e.width,e.height)}_fromTexture(e,t){301===e.mapping||302===e.mapping?this._setSize(0===e.image.length?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),it=this._renderer.getRenderTarget();let i=t||this._allocateTargets();return this._textureToCubeUV(e,i),this._applyPMREM(i),this._cleanup(i),i}_allocateTargets(){let e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize-32,i={magFilter:1006,minFilter:1006,generateMipmaps:!1,type:1016,format:1023,encoding:3e3,depthBuffer:!1},n=io(e,t,i);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==e){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=io(e,t,i);let{_lodMax:n}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=function(e){let t=[],i=[],n=[],r=e,s=e-4+1+t7.length;for(let a=0;a<s;a++){let s=Math.pow(2,r);i.push(s);let o=1/s;a>e-4?o=t7[a-e+4-1]:0===a&&(o=0),n.push(o);let l=1/(s-1),h=-l/2,u=1+l/2,c=[h,h,u,h,u,u,h,h,u,u,h,u],d=new Float32Array(108),p=new Float32Array(72),m=new Float32Array(36);for(let e=0;e<6;e++){let t=e%3*2/3-1,i=e>2?0:-1,n=[t,i,0,t+2/3,i,0,t+2/3,i+1,0,t,i,0,t+2/3,i+1,0,t,i+1,0];d.set(n,18*e),p.set(c,12*e);let r=[e,e,e,e,e,e];m.set(r,6*e)}let f=new td;f.setAttribute("position",new tt(d,3)),f.setAttribute("uv",new tt(p,2)),f.setAttribute("faceIndex",new tt(m,1)),t.push(f),r>4&&r--}return{lodPlanes:t,sizeLods:i,sigmas:n}}(n)),this._blurMaterial=function(e,t,i){let n=new Float32Array(20),r=new q(0,1,0),s=new tz({name:"SphericalGaussianBlur",defines:{n:20,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/i,CUBEUV_MAX_MIP:`${e}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:r}},vertexShader:ic(),fragmentShader:/* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:0,depthTest:!1,depthWrite:!1});return s}(n,e,t)}return n}_compileMaterial(e){let t=new tC(this._lodPlanes[0],e);this._renderer.compile(t,t9)}_sceneToCubeUV(e,t,i,n){let r=new tH(90,1,t,i),s=[1,-1,1,1,1,1],a=[1,1,1,-1,-1,-1],o=this._renderer,l=o.autoClear,h=o.toneMapping;o.getClearColor(ie),o.toneMapping=0,o.autoClear=!1;let u=new e7({name:"PMREM.Background",side:1,depthWrite:!1,depthTest:!1}),c=new tC(new tI,u),d=!1,p=e.background;p?p.isColor&&(u.color.copy(p),e.background=null,d=!0):(u.color.copy(ie),d=!0);for(let t=0;t<6;t++){let i=t%3;0===i?(r.up.set(0,s[t],0),r.lookAt(a[t],0,0)):1===i?(r.up.set(0,0,s[t]),r.lookAt(0,a[t],0)):(r.up.set(0,s[t],0),r.lookAt(0,0,a[t]));let l=this._cubeSize;il(n,i*l,t>2?l:0,l,l),o.setRenderTarget(n),d&&o.render(c,r),o.render(e,r)}c.geometry.dispose(),c.material.dispose(),o.toneMapping=h,o.autoClear=l,e.background=p}_textureToCubeUV(e,t){let i=this._renderer,n=301===e.mapping||302===e.mapping;n?(null===this._cubemapMaterial&&(this._cubemapMaterial=iu()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===e.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=ih());let r=n?this._cubemapMaterial:this._equirectMaterial,s=new tC(this._lodPlanes[0],r),a=r.uniforms;a.envMap.value=e;let o=this._cubeSize;il(t,0,0,3*o,2*o),i.setRenderTarget(t),i.render(s,t9)}_applyPMREM(e){let t=this._renderer,i=t.autoClear;t.autoClear=!1;for(let t=1;t<this._lodPlanes.length;t++){let i=Math.sqrt(this._sigmas[t]*this._sigmas[t]-this._sigmas[t-1]*this._sigmas[t-1]),n=is[(t-1)%is.length];this._blur(e,t-1,t,i,n)}t.autoClear=i}/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */_blur(e,t,i,n,r){let s=this._pingPongRenderTarget;this._halfBlur(e,s,t,i,n,"latitudinal",r),this._halfBlur(s,e,i,i,n,"longitudinal",r)}_halfBlur(e,t,i,n,r,s,a){let o=this._renderer,l=this._blurMaterial;"latitudinal"!==s&&"longitudinal"!==s&&console.error("blur direction must be either latitudinal or longitudinal!");let h=new tC(this._lodPlanes[n],l),u=l.uniforms,c=this._sizeLods[i]-1,d=isFinite(r)?Math.PI/(2*c):2*Math.PI/39,p=r/d,m=isFinite(r)?1+Math.floor(3*p):20;m>20&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`);let f=[],g=0;for(let e=0;e<20;++e){let t=e/p,i=Math.exp(-t*t/2);f.push(i),0===e?g+=i:e<m&&(g+=2*i)}for(let e=0;e<f.length;e++)f[e]=f[e]/g;u.envMap.value=e.texture,u.samples.value=m,u.weights.value=f,u.latitudinal.value="latitudinal"===s,a&&(u.poleAxis.value=a);let{_lodMax:v}=this;u.dTheta.value=d,u.mipInt.value=v-i;let x=this._sizeLods[n],y=3*x*(n>v-4?n-v+4:0),_=4*(this._cubeSize-x);il(t,y,_,3*x,2*x),o.setRenderTarget(t),o.render(h,t9)}}function io(e,t,i){let n=new k(e,t,i);return n.texture.mapping=306,n.texture.name="PMREM.cubeUv",n.scissorTest=!0,n}function il(e,t,i,n,r){e.viewport.set(t,i,n,r),e.scissor.set(t,i,n,r)}function ih(){return new tz({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:ic(),fragmentShader:/* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:0,depthTest:!1,depthWrite:!1})}function iu(){return new tz({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:ic(),fragmentShader:/* glsl */`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:0,depthTest:!1,depthWrite:!1})}function ic(){return/* glsl */`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function id(e){let t=new WeakMap,i=null;function n(e){let i=e.target;i.removeEventListener("dispose",n);let r=t.get(i);void 0!==r&&(t.delete(i),r.dispose())}return{get:function(r){if(r&&r.isTexture){let s=r.mapping,a=303===s||304===s,o=301===s||302===s;// equirect/cube map to cubeUV conversion
if(a||o){if(r.isRenderTargetTexture&&!0===r.needsPMREMUpdate){r.needsPMREMUpdate=!1;let n=t.get(r);return null===i&&(i=new ia(e)),n=a?i.fromEquirectangular(r,n):i.fromCubemap(r,n),t.set(r,n),n.texture}if(t.has(r))return t.get(r).texture;{let s=r.image;if(!(a&&s&&s.height>0||o&&s&&function(e){let t=0;for(let i=0;i<6;i++)void 0!==e[i]&&t++;return 6===t}(s)))return null;{null===i&&(i=new ia(e));let s=a?i.fromEquirectangular(r):i.fromCubemap(r);return t.set(r,s),r.addEventListener("dispose",n),s.texture}}}}return r},dispose:function(){t=new WeakMap,null!==i&&(i.dispose(),i=null)}}}function ip(e){let t={};function i(i){let n;if(void 0!==t[i])return t[i];switch(i){case"WEBGL_depth_texture":n=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":n=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":n=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":n=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:n=e.getExtension(i)}return t[i]=n,n}return{has:function(e){return null!==i(e)},init:function(e){e.isWebGL2?i("EXT_color_buffer_float"):(i("WEBGL_depth_texture"),i("OES_texture_float"),i("OES_texture_half_float"),i("OES_texture_half_float_linear"),i("OES_standard_derivatives"),i("OES_element_index_uint"),i("OES_vertex_array_object"),i("ANGLE_instanced_arrays")),i("OES_texture_float_linear"),i("EXT_color_buffer_half_float"),i("WEBGL_multisampled_render_to_texture")},get:function(e){let t=i(e);return null===t&&console.warn("THREE.WebGLRenderer: "+e+" extension not supported."),t}}}function im(e,t,i,n){let r={},s=new WeakMap;function a(e){let o=e.target;for(let e in null!==o.index&&t.remove(o.index),o.attributes)t.remove(o.attributes[e]);o.removeEventListener("dispose",a),delete r[o.id];let l=s.get(o);l&&(t.remove(l),s.delete(o)),n.releaseStatesOfGeometry(o),!0===o.isInstancedBufferGeometry&&delete o._maxInstanceCount,//
i.memory.geometries--}function o(e){let i=[],n=e.index,r=e.attributes.position,a=0;if(null!==n){let e=n.array;a=n.version;for(let t=0,n=e.length;t<n;t+=3){let n=e[t+0],r=e[t+1],s=e[t+2];i.push(n,r,r,s,s,n)}}else{let e=r.array;a=r.version;for(let t=0,n=e.length/3-1;t<n;t+=3){let e=t+0,n=t+1,r=t+2;i.push(e,n,n,r,r,e)}}let o=new(w(i)?tn:ti)(i,1);o.version=a;// Updating index buffer in VAO now. See WebGLBindingStates
//
let l=s.get(e);l&&t.remove(l),//
s.set(e,o)}return{get:function(e,t){return!0===r[t.id]||(t.addEventListener("dispose",a),r[t.id]=!0,i.memory.geometries++),t},update:function(e){let i=e.attributes;// Updating index buffer in VAO now. See WebGLBindingStates.
for(let e in i)t.update(i[e],34962);// morph targets
let n=e.morphAttributes;for(let e in n){let i=n[e];for(let e=0,n=i.length;e<n;e++)t.update(i[e],34962)}},getWireframeAttribute:function(e){let t=s.get(e);if(t){let i=e.index;null!==i&&t.version<i.version&&o(e)}else o(e);return s.get(e)}}}function ig(e,t,i,n){let r,s,a;let o=n.isWebGL2;//
this.setMode=function(e){r=e},this.setIndex=function(e){s=e.type,a=e.bytesPerElement},this.render=function(t,n){e.drawElements(r,n,s,t*a),i.update(n,r,1)},this.renderInstances=function(n,l,h){let u,c;if(0!==h){if(o)u=e,c="drawElementsInstanced";else if(u=t.get("ANGLE_instanced_arrays"),c="drawElementsInstancedANGLE",null===u){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}u[c](r,l,s,n*a,h),i.update(l,r,h)}}}function iv(e){let t={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:t,programs:null,autoReset:!0,reset:function(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0},update:function(e,i,n){switch(t.calls++,i){case 4:t.triangles+=n*(e/3);break;case 1:t.lines+=n*(e/2);break;case 3:t.lines+=n*(e-1);break;case 2:t.lines+=n*e;break;case 0:t.points+=n*e;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",i)}}}}function ix(e,t){return e[0]-t[0]}function iy(e,t){return Math.abs(t[1])-Math.abs(e[1])}function i_(e,t){let i=1,n=t.isInterleavedBufferAttribute?t.data.array:t.array;n instanceof Int8Array?i=127:n instanceof Int16Array?i=32767:n instanceof Int32Array?i=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",n),e.divideScalar(i)}function ib(e,t,i){let n={},r=new Float32Array(8),s=new WeakMap,a=new G,o=[];for(let e=0;e<8;e++)o[e]=[e,0];return{update:function(l,h,u,c){let d=l.morphTargetInfluences;if(!0===t.isWebGL2){// instead of using attributes, the WebGL 2 code path encodes morph targets
// into an array of data textures. Each layer represents a single morph target.
let n=h.morphAttributes.position||h.morphAttributes.normal||h.morphAttributes.color,r=void 0!==n?n.length:0,o=s.get(h);if(void 0===o||o.count!==r){void 0!==o&&o.texture.dispose();let e=void 0!==h.morphAttributes.position,i=void 0!==h.morphAttributes.normal,n=void 0!==h.morphAttributes.color,l=h.morphAttributes.position||[],u=h.morphAttributes.normal||[],c=h.morphAttributes.color||[],d=0;!0===e&&(d=1),!0===i&&(d=2),!0===n&&(d=3);let p=h.attributes.position.count*d,m=1;p>t.maxTextureSize&&(m=Math.ceil(p/t.maxTextureSize),p=t.maxTextureSize);let f=new Float32Array(p*m*4*r),g=new V(f,p,m,r);g.type=1015,g.needsUpdate=!0;// fill buffer
let v=4*d;for(let t=0;t<r;t++){let r=l[t],s=u[t],o=c[t],h=p*m*4*t;for(let t=0;t<r.count;t++){let l=t*v;!0===e&&(a.fromBufferAttribute(r,t),!0===r.normalized&&i_(a,r),f[h+l+0]=a.x,f[h+l+1]=a.y,f[h+l+2]=a.z,f[h+l+3]=0),!0===i&&(a.fromBufferAttribute(s,t),!0===s.normalized&&i_(a,s),f[h+l+4]=a.x,f[h+l+5]=a.y,f[h+l+6]=a.z,f[h+l+7]=0),!0===n&&(a.fromBufferAttribute(o,t),!0===o.normalized&&i_(a,o),f[h+l+8]=a.x,f[h+l+9]=a.y,f[h+l+10]=a.z,f[h+l+11]=4===o.itemSize?a.w:1)}}o={count:r,texture:g,size:new b(p,m)},s.set(h,o),h.addEventListener("dispose",function e(){g.dispose(),s.delete(h),h.removeEventListener("dispose",e)})}//
let l=0;for(let e=0;e<d.length;e++)l+=d[e];let u=h.morphTargetsRelative?1:1-l;c.getUniforms().setValue(e,"morphTargetBaseInfluence",u),c.getUniforms().setValue(e,"morphTargetInfluences",d),c.getUniforms().setValue(e,"morphTargetsTexture",o.texture,i),c.getUniforms().setValue(e,"morphTargetsTextureSize",o.size)}else{// When object doesn't have morph target influences defined, we treat it as a 0-length array
// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
let t=void 0===d?0:d.length,i=n[h.id];if(void 0===i||i.length!==t){// initialise list
i=[];for(let e=0;e<t;e++)i[e]=[e,0];n[h.id]=i}// Collect influences
for(let e=0;e<t;e++){let t=i[e];t[0]=e,t[1]=d[e]}i.sort(iy);for(let e=0;e<8;e++)e<t&&i[e][1]?(o[e][0]=i[e][0],o[e][1]=i[e][1]):(o[e][0]=Number.MAX_SAFE_INTEGER,o[e][1]=0);o.sort(ix);let s=h.morphAttributes.position,a=h.morphAttributes.normal,l=0;for(let e=0;e<8;e++){let t=o[e],i=t[0],n=t[1];i!==Number.MAX_SAFE_INTEGER&&n?(s&&h.getAttribute("morphTarget"+e)!==s[i]&&h.setAttribute("morphTarget"+e,s[i]),a&&h.getAttribute("morphNormal"+e)!==a[i]&&h.setAttribute("morphNormal"+e,a[i]),r[e]=n,l+=n):(s&&!0===h.hasAttribute("morphTarget"+e)&&h.deleteAttribute("morphTarget"+e),a&&!0===h.hasAttribute("morphNormal"+e)&&h.deleteAttribute("morphNormal"+e),r[e]=0)}// GLSL shader uses formula baseinfluence * base + sum(target * influence)
// This allows us to switch between absolute morphs and relative morphs without changing shader code
// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
let u=h.morphTargetsRelative?1:1-l;c.getUniforms().setValue(e,"morphTargetBaseInfluence",u),c.getUniforms().setValue(e,"morphTargetInfluences",r)}}}}function iM(e,t,i,n){let r=new WeakMap;function s(e){let t=e.target;t.removeEventListener("dispose",s),i.remove(t.instanceMatrix),null!==t.instanceColor&&i.remove(t.instanceColor)}return{update:function(e){let a=n.render.frame,o=e.geometry,l=t.get(e,o);return r.get(l)!==a&&(t.update(l),r.set(l,a)),e.isInstancedMesh&&(!1===e.hasEventListener("dispose",s)&&e.addEventListener("dispose",s),i.update(e.instanceMatrix,34962),null!==e.instanceColor&&i.update(e.instanceColor,34962)),l},dispose:function(){r=new WeakMap}}}/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */const iw=new B,iS=new V,iT=new W,iE=new tB,iA=[],iR=[],iL=new Float32Array(16),iC=new Float32Array(9),iP=new Float32Array(4);// Flattening for arrays of vectors and matrices
function iI(e,t,i){let n=e[0];if(n<=0||n>0)return e;// unoptimized: ! isNaN( firstElem )
// see http://jacksondunstan.com/articles/983
let r=t*i,s=iA[r];if(void 0===s&&(s=new Float32Array(r),iA[r]=s),0!==t){n.toArray(s,0);for(let n=1,r=0;n!==t;++n)r+=i,e[n].toArray(s,r)}return s}function iD(e,t){if(e.length!==t.length)return!1;for(let i=0,n=e.length;i<n;i++)if(e[i]!==t[i])return!1;return!0}function iN(e,t){for(let i=0,n=t.length;i<n;i++)e[i]=t[i]}// Texture unit allocation
function iO(e,t){let i=iR[t];void 0===i&&(i=new Int32Array(t),iR[t]=i);for(let n=0;n!==t;++n)i[n]=e.allocateTextureUnit();return i}// --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar
function iz(e,t){let i=this.cache;i[0]!==t&&(e.uniform1f(this.addr,t),i[0]=t)}// Single float vector (from flat array or THREE.VectorN)
function iU(e,t){let i=this.cache;if(void 0!==t.x)(i[0]!==t.x||i[1]!==t.y)&&(e.uniform2f(this.addr,t.x,t.y),i[0]=t.x,i[1]=t.y);else{if(iD(i,t))return;e.uniform2fv(this.addr,t),iN(i,t)}}function iH(e,t){let i=this.cache;if(void 0!==t.x)(i[0]!==t.x||i[1]!==t.y||i[2]!==t.z)&&(e.uniform3f(this.addr,t.x,t.y,t.z),i[0]=t.x,i[1]=t.y,i[2]=t.z);else if(void 0!==t.r)(i[0]!==t.r||i[1]!==t.g||i[2]!==t.b)&&(e.uniform3f(this.addr,t.r,t.g,t.b),i[0]=t.r,i[1]=t.g,i[2]=t.b);else{if(iD(i,t))return;e.uniform3fv(this.addr,t),iN(i,t)}}function iF(e,t){let i=this.cache;if(void 0!==t.x)(i[0]!==t.x||i[1]!==t.y||i[2]!==t.z||i[3]!==t.w)&&(e.uniform4f(this.addr,t.x,t.y,t.z,t.w),i[0]=t.x,i[1]=t.y,i[2]=t.z,i[3]=t.w);else{if(iD(i,t))return;e.uniform4fv(this.addr,t),iN(i,t)}}// Single matrix (from flat array or THREE.MatrixN)
function iB(e,t){let i=this.cache,n=t.elements;if(void 0===n){if(iD(i,t))return;e.uniformMatrix2fv(this.addr,!1,t),iN(i,t)}else{if(iD(i,n))return;iP.set(n),e.uniformMatrix2fv(this.addr,!1,iP),iN(i,n)}}function iG(e,t){let i=this.cache,n=t.elements;if(void 0===n){if(iD(i,t))return;e.uniformMatrix3fv(this.addr,!1,t),iN(i,t)}else{if(iD(i,n))return;iC.set(n),e.uniformMatrix3fv(this.addr,!1,iC),iN(i,n)}}function ik(e,t){let i=this.cache,n=t.elements;if(void 0===n){if(iD(i,t))return;e.uniformMatrix4fv(this.addr,!1,t),iN(i,t)}else{if(iD(i,n))return;iL.set(n),e.uniformMatrix4fv(this.addr,!1,iL),iN(i,n)}}// Single integer / boolean
function iV(e,t){let i=this.cache;i[0]!==t&&(e.uniform1i(this.addr,t),i[0]=t)}// Single integer / boolean vector (from flat array)
function iW(e,t){let i=this.cache;iD(i,t)||(e.uniform2iv(this.addr,t),iN(i,t))}function ij(e,t){let i=this.cache;iD(i,t)||(e.uniform3iv(this.addr,t),iN(i,t))}function iq(e,t){let i=this.cache;iD(i,t)||(e.uniform4iv(this.addr,t),iN(i,t))}// Single unsigned integer
function iX(e,t){let i=this.cache;i[0]!==t&&(e.uniform1ui(this.addr,t),i[0]=t)}// Single unsigned integer vector (from flat array)
function iY(e,t){let i=this.cache;iD(i,t)||(e.uniform2uiv(this.addr,t),iN(i,t))}function iJ(e,t){let i=this.cache;iD(i,t)||(e.uniform3uiv(this.addr,t),iN(i,t))}function iZ(e,t){let i=this.cache;iD(i,t)||(e.uniform4uiv(this.addr,t),iN(i,t))}// Single texture (2D / Cube)
function iK(e,t,i){let n=this.cache,r=i.allocateTextureUnit();n[0]!==r&&(e.uniform1i(this.addr,r),n[0]=r),i.setTexture2D(t||iw,r)}function iQ(e,t,i){let n=this.cache,r=i.allocateTextureUnit();n[0]!==r&&(e.uniform1i(this.addr,r),n[0]=r),i.setTexture3D(t||iT,r)}function i$(e,t,i){let n=this.cache,r=i.allocateTextureUnit();n[0]!==r&&(e.uniform1i(this.addr,r),n[0]=r),i.setTextureCube(t||iE,r)}function i0(e,t,i){let n=this.cache,r=i.allocateTextureUnit();n[0]!==r&&(e.uniform1i(this.addr,r),n[0]=r),i.setTexture2DArray(t||iS,r)}// Array of scalars
function i1(e,t){e.uniform1fv(this.addr,t)}// Array of vectors (from flat array or array of THREE.VectorN)
function i3(e,t){let i=iI(t,this.size,2);e.uniform2fv(this.addr,i)}function i2(e,t){let i=iI(t,this.size,3);e.uniform3fv(this.addr,i)}function i4(e,t){let i=iI(t,this.size,4);e.uniform4fv(this.addr,i)}// Array of matrices (from flat array or array of THREE.MatrixN)
function i5(e,t){let i=iI(t,this.size,4);e.uniformMatrix2fv(this.addr,!1,i)}function i6(e,t){let i=iI(t,this.size,9);e.uniformMatrix3fv(this.addr,!1,i)}function i8(e,t){let i=iI(t,this.size,16);e.uniformMatrix4fv(this.addr,!1,i)}// Array of integer / boolean
function i7(e,t){e.uniform1iv(this.addr,t)}// Array of integer / boolean vectors (from flat array)
function i9(e,t){e.uniform2iv(this.addr,t)}function ne(e,t){e.uniform3iv(this.addr,t)}function nt(e,t){e.uniform4iv(this.addr,t)}// Array of unsigned integer
function ni(e,t){e.uniform1uiv(this.addr,t)}// Array of unsigned integer vectors (from flat array)
function nn(e,t){e.uniform2uiv(this.addr,t)}function nr(e,t){e.uniform3uiv(this.addr,t)}function ns(e,t){e.uniform4uiv(this.addr,t)}// Array of textures (2D / 3D / Cube / 2DArray)
function na(e,t,i){let n=t.length,r=iO(i,n);e.uniform1iv(this.addr,r);for(let e=0;e!==n;++e)i.setTexture2D(t[e]||iw,r[e])}function no(e,t,i){let n=t.length,r=iO(i,n);e.uniform1iv(this.addr,r);for(let e=0;e!==n;++e)i.setTexture3D(t[e]||iT,r[e])}function nl(e,t,i){let n=t.length,r=iO(i,n);e.uniform1iv(this.addr,r);for(let e=0;e!==n;++e)i.setTextureCube(t[e]||iE,r[e])}function nh(e,t,i){let n=t.length,r=iO(i,n);e.uniform1iv(this.addr,r);for(let e=0;e!==n;++e)i.setTexture2DArray(t[e]||iS,r[e])}// --- Uniform Classes ---
function nu(e,t,i){this.id=e,this.addr=i,this.cache=[],this.setValue=// Helper to pick the right setter for the singular case
function(e){switch(e){case 5126:return iz;// FLOAT
case 35664:return iU;// _VEC2
case 35665:return iH;// _VEC3
case 35666:return iF;// _VEC4
case 35674:return iB;// _MAT2
case 35675:return iG;// _MAT3
case 35676:return ik;// _MAT4
case 5124:case 35670:return iV;// INT, BOOL
case 35667:case 35671:return iW;// _VEC2
case 35668:case 35672:return ij;// _VEC3
case 35669:case 35673:return iq;// _VEC4
case 5125:return iX;// UINT
case 36294:return iY;// _VEC2
case 36295:return iJ;// _VEC3
case 36296:return iZ;// _VEC4
case 35678:case 36198:case 36298:case 36306:case 35682:return iK;case 35679:case 36299:case 36307:return iQ;case 35680:case 36300:case 36308:case 36293:return i$;case 36289:case 36303:case 36311:case 36292:return i0}}(t.type);// this.path = activeInfo.name; // DEBUG
}function nc(e,t,i){this.id=e,this.addr=i,this.cache=[],this.size=t.size,this.setValue=// Helper to pick the right setter for a pure (bottom-level) array
function(e){switch(e){case 5126:return i1;// FLOAT
case 35664:return i3;// _VEC2
case 35665:return i2;// _VEC3
case 35666:return i4;// _VEC4
case 35674:return i5;// _MAT2
case 35675:return i6;// _MAT3
case 35676:return i8;// _MAT4
case 5124:case 35670:return i7;// INT, BOOL
case 35667:case 35671:return i9;// _VEC2
case 35668:case 35672:return ne;// _VEC3
case 35669:case 35673:return nt;// _VEC4
case 5125:return ni;// UINT
case 36294:return nn;// _VEC2
case 36295:return nr;// _VEC3
case 36296:return ns;// _VEC4
case 35678:case 36198:case 36298:case 36306:case 35682:return na;case 35679:case 36299:case 36307:return no;case 35680:case 36300:case 36308:case 36293:return nl;case 36289:case 36303:case 36311:case 36292:return nh}}(t.type);// this.path = activeInfo.name; // DEBUG
}function nd(e){this.id=e,this.seq=[],this.map={}}nc.prototype.updateCache=function(e){let t=this.cache;e instanceof Float32Array&&t.length!==e.length&&(this.cache=new Float32Array(e.length)),iN(t,e)},nd.prototype.setValue=function(e,t,i){let n=this.seq;for(let r=0,s=n.length;r!==s;++r){let s=n[r];s.setValue(e,t[s.id],i)}};// --- Top-level ---
// Parser - builds up the property tree from the path strings
const np=/(\w+)(\])?(\[|\.)?/g;// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.
function nm(e,t){e.seq.push(t),e.map[t.id]=t}// Root Container
function nf(e,t){this.seq=[],this.map={};let i=e.getProgramParameter(t,35718);for(let n=0;n<i;++n){let i=e.getActiveUniform(t,n),r=e.getUniformLocation(t,i.name);!function(e,t,i){let n=e.name,r=n.length;for(// reset RegExp object, because of the early exit of a previous run
np.lastIndex=0;;){let s=np.exec(n),a=np.lastIndex,o=s[1],l="]"===s[2],h=s[3];if(l&&(o|=0),void 0===h||"["===h&&a+2===r){// bare name or "pure" bottom-level array "[0]" suffix
nm(i,void 0===h?new nu(o,e,t):new nc(o,e,t));break}{// step into inner node / create it in case it doesn't exist
let e=i.map,t=e[o];void 0===t&&nm(i,t=new nd(o)),i=t}}}(i,r,this)}}function ng(e,t,i){let n=e.createShader(t);return e.shaderSource(n,i),e.compileShader(n),n}nf.prototype.setValue=function(e,t,i,n){let r=this.map[t];void 0!==r&&r.setValue(e,i,n)},nf.prototype.setOptional=function(e,t,i){let n=t[i];void 0!==n&&this.setValue(e,i,n)},// Static interface
nf.upload=function(e,t,i,n){for(let r=0,s=t.length;r!==s;++r){let s=t[r],a=i[s.id];!1!==a.needsUpdate&&s.setValue(e,a.value,n)}},nf.seqWithValue=function(e,t){let i=[];for(let n=0,r=e.length;n!==r;++n){let r=e[n];r.id in t&&i.push(r)}return i};let nv=0;function nx(e,t,i){let n=e.getShaderParameter(t,35713),r=e.getShaderInfoLog(t).trim();if(n&&""===r)return"";let s=parseInt(/ERROR: 0:(\d+)/.exec(r)[1]);// --enable-privileged-webgl-extension
// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
return i.toUpperCase()+"\n\n"+r+"\n\n"+function(e,t){let i=e.split("\n"),n=[],r=Math.max(t-6,0),s=Math.min(t+6,i.length);for(let e=r;e<s;e++)n.push(e+1+": "+i[e]);return n.join("\n")}(e.getShaderSource(t),s)}function ny(e){return""!==e}function n_(e,t){return e.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function nb(e,t){return e.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}// Resolve Includes
const nM=/^[ \t]*#include +<([\w\d./]+)>/gm;function nw(e){return e.replace(nM,nS)}function nS(e,t){let i=tQ[t];if(void 0===i)throw Error("Can not resolve #include <"+t+">");return nw(i)}// Unroll Loops
const nT=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,nE=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function nA(e){return e.replace(nE,nL).replace(nT,nR)}function nR(e,t,i,n){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),nL(e,t,i,n)}function nL(e,t,i,n){let r="";for(let e=parseInt(t);e<parseInt(i);e++)r+=n.replace(/\[\s*i\s*\]/g,"[ "+e+" ]").replace(/UNROLLED_LOOP_INDEX/g,e);return r}//
function nC(e){let t="precision "+e.precision+" float;\nprecision "+e.precision+" int;";return"highp"===e.precision?t+="\n#define HIGH_PRECISION":"mediump"===e.precision?t+="\n#define MEDIUM_PRECISION":"lowp"===e.precision&&(t+="\n#define LOW_PRECISION"),t}function nP(e,t,i,n){let r,s,a,l,h,u;// TODO Send this event to Three.js DevTools
// console.log( 'WebGLProgram', cacheKey );
let c=e.getContext(),d=i.defines,p=i.vertexShader,m=i.fragmentShader,f=(h="SHADOWMAP_TYPE_BASIC",1===i.shadowMapType?h="SHADOWMAP_TYPE_PCF":2===i.shadowMapType?h="SHADOWMAP_TYPE_PCF_SOFT":3===i.shadowMapType&&(h="SHADOWMAP_TYPE_VSM"),h),g=function(e){let t="ENVMAP_TYPE_CUBE";if(e.envMap)switch(e.envMapMode){case 301:case 302:t="ENVMAP_TYPE_CUBE";break;case 306:t="ENVMAP_TYPE_CUBE_UV"}return t}(i),v=(u="ENVMAP_MODE_REFLECTION",i.envMap&&302===i.envMapMode&&(u="ENVMAP_MODE_REFRACTION"),u),x=function(e){let t="ENVMAP_BLENDING_NONE";if(e.envMap)switch(e.combine){case 0:t="ENVMAP_BLENDING_MULTIPLY";break;case 1:t="ENVMAP_BLENDING_MIX";break;case 2:t="ENVMAP_BLENDING_ADD"}return t}(i),y=function(e){let t=e.envMapCubeUVHeight;if(null===t)return null;let i=Math.log2(t/32+1)+3;return{texelWidth:1/(3*Math.max(Math.pow(2,i),112)),texelHeight:1/t,maxMip:i}}(i),_=i.isWebGL2?"":function(e){let t=[e.extensionDerivatives||e.envMapCubeUVHeight||e.bumpMap||e.tangentSpaceNormalMap||e.clearcoatNormalMap||e.flatShading||"physical"===e.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(e.extensionFragDepth||e.logarithmicDepthBuffer)&&e.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",e.extensionDrawBuffers&&e.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(e.extensionShaderTextureLOD||e.envMap||e.transmission)&&e.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""];return t.filter(ny).join("\n")}(i),b=function(e){let t=[];for(let i in e){let n=e[i];!1!==n&&t.push("#define "+i+" "+n)}return t.join("\n")}(d),M=c.createProgram(),w=i.glslVersion?"#version "+i.glslVersion+"\n":"";i.isRawShaderMaterial?((r=[b].filter(ny).join("\n")).length>0&&(r+="\n"),(s=[_,b].filter(ny).join("\n")).length>0&&(s+="\n")):(r=[nC(i),"#define SHADER_NAME "+i.shaderName,b,i.instancing?"#define USE_INSTANCING":"",i.instancingColor?"#define USE_INSTANCING_COLOR":"",i.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define MAX_BONES "+i.maxBones,i.useFog&&i.fog?"#define USE_FOG":"",i.useFog&&i.fogExp2?"#define FOG_EXP2":"",i.map?"#define USE_MAP":"",i.envMap?"#define USE_ENVMAP":"",i.envMap?"#define "+v:"",i.lightMap?"#define USE_LIGHTMAP":"",i.aoMap?"#define USE_AOMAP":"",i.emissiveMap?"#define USE_EMISSIVEMAP":"",i.bumpMap?"#define USE_BUMPMAP":"",i.normalMap?"#define USE_NORMALMAP":"",i.normalMap&&i.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",i.normalMap&&i.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",i.clearcoatMap?"#define USE_CLEARCOATMAP":"",i.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",i.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",i.displacementMap&&i.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",i.specularMap?"#define USE_SPECULARMAP":"",i.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",i.specularColorMap?"#define USE_SPECULARCOLORMAP":"",i.roughnessMap?"#define USE_ROUGHNESSMAP":"",i.metalnessMap?"#define USE_METALNESSMAP":"",i.alphaMap?"#define USE_ALPHAMAP":"",i.transmission?"#define USE_TRANSMISSION":"",i.transmissionMap?"#define USE_TRANSMISSIONMAP":"",i.thicknessMap?"#define USE_THICKNESSMAP":"",i.sheenColorMap?"#define USE_SHEENCOLORMAP":"",i.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",i.vertexTangents?"#define USE_TANGENT":"",i.vertexColors?"#define USE_COLOR":"",i.vertexAlphas?"#define USE_COLOR_ALPHA":"",i.vertexUvs?"#define USE_UV":"",i.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",i.flatShading?"#define FLAT_SHADED":"",i.skinning?"#define USE_SKINNING":"",i.useVertexTexture?"#define BONE_TEXTURE":"",i.morphTargets?"#define USE_MORPHTARGETS":"",i.morphNormals&&!1===i.flatShading?"#define USE_MORPHNORMALS":"",i.morphColors&&i.isWebGL2?"#define USE_MORPHCOLORS":"",i.morphTargetsCount>0&&i.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",i.morphTargetsCount>0&&i.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+i.morphTextureStride:"",i.morphTargetsCount>0&&i.isWebGL2?"#define MORPHTARGETS_COUNT "+i.morphTargetsCount:"",i.doubleSided?"#define DOUBLE_SIDED":"",i.flipSided?"#define FLIP_SIDED":"",i.shadowMapEnabled?"#define USE_SHADOWMAP":"",i.shadowMapEnabled?"#define "+f:"",i.sizeAttenuation?"#define USE_SIZEATTENUATION":"",i.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",i.logarithmicDepthBuffer&&i.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif","\n"].filter(ny).join("\n"),s=[_,nC(i),"#define SHADER_NAME "+i.shaderName,b,i.useFog&&i.fog?"#define USE_FOG":"",i.useFog&&i.fogExp2?"#define FOG_EXP2":"",i.map?"#define USE_MAP":"",i.matcap?"#define USE_MATCAP":"",i.envMap?"#define USE_ENVMAP":"",i.envMap?"#define "+g:"",i.envMap?"#define "+v:"",i.envMap?"#define "+x:"",y?"#define CUBEUV_TEXEL_WIDTH "+y.texelWidth:"",y?"#define CUBEUV_TEXEL_HEIGHT "+y.texelHeight:"",y?"#define CUBEUV_MAX_MIP "+y.maxMip+".0":"",i.lightMap?"#define USE_LIGHTMAP":"",i.aoMap?"#define USE_AOMAP":"",i.emissiveMap?"#define USE_EMISSIVEMAP":"",i.bumpMap?"#define USE_BUMPMAP":"",i.normalMap?"#define USE_NORMALMAP":"",i.normalMap&&i.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",i.normalMap&&i.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",i.clearcoat?"#define USE_CLEARCOAT":"",i.clearcoatMap?"#define USE_CLEARCOATMAP":"",i.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",i.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",i.specularMap?"#define USE_SPECULARMAP":"",i.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",i.specularColorMap?"#define USE_SPECULARCOLORMAP":"",i.roughnessMap?"#define USE_ROUGHNESSMAP":"",i.metalnessMap?"#define USE_METALNESSMAP":"",i.alphaMap?"#define USE_ALPHAMAP":"",i.alphaTest?"#define USE_ALPHATEST":"",i.sheen?"#define USE_SHEEN":"",i.sheenColorMap?"#define USE_SHEENCOLORMAP":"",i.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",i.transmission?"#define USE_TRANSMISSION":"",i.transmissionMap?"#define USE_TRANSMISSIONMAP":"",i.thicknessMap?"#define USE_THICKNESSMAP":"",i.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",i.vertexTangents?"#define USE_TANGENT":"",i.vertexColors||i.instancingColor?"#define USE_COLOR":"",i.vertexAlphas?"#define USE_COLOR_ALPHA":"",i.vertexUvs?"#define USE_UV":"",i.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",i.gradientMap?"#define USE_GRADIENTMAP":"",i.flatShading?"#define FLAT_SHADED":"",i.doubleSided?"#define DOUBLE_SIDED":"",i.flipSided?"#define FLIP_SIDED":"",i.shadowMapEnabled?"#define USE_SHADOWMAP":"",i.shadowMapEnabled?"#define "+f:"",i.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",i.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",i.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",i.logarithmicDepthBuffer&&i.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==i.toneMapping?"#define TONE_MAPPING":"",0!==i.toneMapping?tQ.tonemapping_pars_fragment:"",0!==i.toneMapping?function(e,t){let i;switch(t){case 1:i="Linear";break;case 2:i="Reinhard";break;case 3:i="OptimizedCineon";break;case 4:i="ACESFilmic";break;case 5:i="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),i="Linear"}return"vec3 "+e+"( vec3 color ) { return "+i+"ToneMapping( color ); }"}("toneMapping",i.toneMapping):"",i.dithering?"#define DITHERING":"",i.opaque?"#define OPAQUE":"",tQ.encodings_pars_fragment,function(e,t){let i=function(e){switch(e){case 3e3:return["Linear","( value )"];case 3001:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",e),["Linear","( value )"]}}(t);return"vec4 "+e+"( vec4 value ) { return LinearTo"+i[0]+i[1]+"; }"}("linearToOutputTexel",i.outputEncoding),i.depthPacking?"#define DEPTH_PACKING "+i.depthPacking:"","\n"].filter(ny).join("\n")),p=nb(p=n_(p=nw(p),i),i),m=nb(m=n_(m=nw(m),i),i),p=nA(p),m=nA(m),i.isWebGL2&&!0!==i.isRawShaderMaterial&&(// GLSL 3.0 conversion for built-in materials and ShaderMaterial
w="#version 300 es\n",r="precision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\n"+r,s=["#define varying in",i.glslVersion===o?"":"layout(location = 0) out highp vec4 pc_fragColor;",i.glslVersion===o?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+s);let S=w+r+p,T=w+s+m,E=ng(c,35633,S),A=ng(c,35632,T);// check for link errors
if(c.attachShader(M,E),c.attachShader(M,A),void 0!==i.index0AttributeName?c.bindAttribLocation(M,0,i.index0AttributeName):!0===i.morphTargets&&c.bindAttribLocation(M,0,"position"),c.linkProgram(M),e.debug.checkShaderErrors){let e=c.getProgramInfoLog(M).trim(),t=c.getShaderInfoLog(E).trim(),i=c.getShaderInfoLog(A).trim(),n=!0,a=!0;if(!1===c.getProgramParameter(M,35714)){n=!1;let t=nx(c,E,"vertex"),i=nx(c,A,"fragment");console.error("THREE.WebGLProgram: Shader Error "+c.getError()+" - VALIDATE_STATUS "+c.getProgramParameter(M,35715)+"\n\nProgram Info Log: "+e+"\n"+t+"\n"+i)}else""!==e?console.warn("THREE.WebGLProgram: Program Info Log:",e):(""===t||""===i)&&(a=!1);a&&(this.diagnostics={runnable:n,programLog:e,vertexShader:{log:t,prefix:r},fragmentShader:{log:i,prefix:s}})}return(// Clean up
// Crashes in iOS9 and iOS10. #18402
// gl.detachShader( program, glVertexShader );
// gl.detachShader( program, glFragmentShader );
c.deleteShader(E),c.deleteShader(A),this.getUniforms=function(){return void 0===a&&(a=new nf(c,M)),a},this.getAttributes=function(){return void 0===l&&(l=function(e,t){let i={},n=e.getProgramParameter(t,35721);for(let r=0;r<n;r++){let n=e.getActiveAttrib(t,r),s=n.name,a=1;35674===n.type&&(a=2),35675===n.type&&(a=3),35676===n.type&&(a=4),// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
i[s]={type:n.type,location:e.getAttribLocation(t,s),locationSize:a}}return i}(c,M)),l},// free resource
this.destroy=function(){n.releaseStatesOfProgram(this),c.deleteProgram(M),this.program=void 0},//
this.name=i.shaderName,this.id=nv++,this.cacheKey=t,this.usedTimes=1,this.program=M,this.vertexShader=E,this.fragmentShader=A,this)}let nI=0;class nD{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){let t=e.vertexShader,i=e.fragmentShader,n=this._getShaderStage(t),r=this._getShaderStage(i),s=this._getShaderCacheForMaterial(e);return!1===s.has(n)&&(s.add(n),n.usedTimes++),!1===s.has(r)&&(s.add(r),r.usedTimes++),this}remove(e){let t=this.materialCache.get(e);for(let e of t)e.usedTimes--,0===e.usedTimes&&this.shaderCache.delete(e.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){let t=this.materialCache;return!1===t.has(e)&&t.set(e,new Set),t.get(e)}_getShaderStage(e){let t=this.shaderCache;if(!1===t.has(e)){let i=new nN(e);t.set(e,i)}return t.get(e)}}class nN{constructor(e){this.id=nI++,this.code=e,this.usedTimes=0}}function nO(e,t,i,n,r,s,a){let o=new eN,l=new nD,h=[],u=r.isWebGL2,c=r.logarithmicDepthBuffer,d=r.floatVertexTextures,p=r.maxVertexUniforms,m=r.vertexTextures,f=r.precision,g={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};return{getParameters:function(s,o,h,v,x){let y,_,b,M;let w=v.fog,S=x.geometry,T=s.isMeshStandardMaterial?v.environment:null,E=(s.isMeshStandardMaterial?i:t).get(s.envMap||T),A=E&&306===E.mapping?E.image.height:null,R=g[s.type],L=x.isSkinnedMesh?function(e){let t=e.skeleton,i=t.bones;if(d)return 1024;{let e=Math.min(Math.floor((p-20)/4),i.length);return e<i.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+i.length+" bones. This GPU supports "+e+"."),0):e}}(x):0;null!==s.precision&&(f=r.getMaxPrecision(s.precision))!==s.precision&&console.warn("THREE.WebGLProgram.getParameters:",s.precision,"not supported, using",f,"instead.");//
let C=S.morphAttributes.position||S.morphAttributes.normal||S.morphAttributes.color,P=void 0!==C?C.length:0,I=0;if(void 0!==S.morphAttributes.position&&(I=1),void 0!==S.morphAttributes.normal&&(I=2),void 0!==S.morphAttributes.color&&(I=3),R){let e=t0[R];y=e.vertexShader,_=e.fragmentShader}else y=s.vertexShader,_=s.fragmentShader,l.update(s),b=l.getVertexShaderID(s),M=l.getFragmentShaderID(s);let D=e.getRenderTarget(),N=s.alphaTest>0,O=s.clearcoat>0,z={isWebGL2:u,shaderID:R,shaderName:s.type,vertexShader:y,fragmentShader:_,defines:s.defines,customVertexShaderID:b,customFragmentShaderID:M,isRawShaderMaterial:!0===s.isRawShaderMaterial,glslVersion:s.glslVersion,precision:f,instancing:!0===x.isInstancedMesh,instancingColor:!0===x.isInstancedMesh&&null!==x.instanceColor,supportsVertexTextures:m,outputEncoding:null===D?e.outputEncoding:!0===D.isXRRenderTarget?D.texture.encoding:3e3,map:!!s.map,matcap:!!s.matcap,envMap:!!E,envMapMode:E&&E.mapping,envMapCubeUVHeight:A,lightMap:!!s.lightMap,aoMap:!!s.aoMap,emissiveMap:!!s.emissiveMap,bumpMap:!!s.bumpMap,normalMap:!!s.normalMap,objectSpaceNormalMap:1===s.normalMapType,tangentSpaceNormalMap:0===s.normalMapType,decodeVideoTexture:!!s.map&&!0===s.map.isVideoTexture&&3001===s.map.encoding,clearcoat:O,clearcoatMap:O&&!!s.clearcoatMap,clearcoatRoughnessMap:O&&!!s.clearcoatRoughnessMap,clearcoatNormalMap:O&&!!s.clearcoatNormalMap,displacementMap:!!s.displacementMap,roughnessMap:!!s.roughnessMap,metalnessMap:!!s.metalnessMap,specularMap:!!s.specularMap,specularIntensityMap:!!s.specularIntensityMap,specularColorMap:!!s.specularColorMap,opaque:!1===s.transparent&&1===s.blending,alphaMap:!!s.alphaMap,alphaTest:N,gradientMap:!!s.gradientMap,sheen:s.sheen>0,sheenColorMap:!!s.sheenColorMap,sheenRoughnessMap:!!s.sheenRoughnessMap,transmission:s.transmission>0,transmissionMap:!!s.transmissionMap,thicknessMap:!!s.thicknessMap,combine:s.combine,vertexTangents:!!s.normalMap&&!!S.attributes.tangent,vertexColors:s.vertexColors,vertexAlphas:!0===s.vertexColors&&!!S.attributes.color&&4===S.attributes.color.itemSize,vertexUvs:!!s.map||!!s.bumpMap||!!s.normalMap||!!s.specularMap||!!s.alphaMap||!!s.emissiveMap||!!s.roughnessMap||!!s.metalnessMap||!!s.clearcoatMap||!!s.clearcoatRoughnessMap||!!s.clearcoatNormalMap||!!s.displacementMap||!!s.transmissionMap||!!s.thicknessMap||!!s.specularIntensityMap||!!s.specularColorMap||!!s.sheenColorMap||!!s.sheenRoughnessMap,uvsVertexOnly:!(s.map||s.bumpMap||s.normalMap||s.specularMap||s.alphaMap||s.emissiveMap||s.roughnessMap||s.metalnessMap||s.clearcoatNormalMap||s.transmission>0||s.transmissionMap||s.thicknessMap||s.specularIntensityMap||s.specularColorMap||s.sheen>0||s.sheenColorMap||s.sheenRoughnessMap)&&!!s.displacementMap,fog:!!w,useFog:s.fog,fogExp2:w&&w.isFogExp2,flatShading:!!s.flatShading,sizeAttenuation:s.sizeAttenuation,logarithmicDepthBuffer:c,skinning:!0===x.isSkinnedMesh&&L>0,maxBones:L,useVertexTexture:d,morphTargets:void 0!==S.morphAttributes.position,morphNormals:void 0!==S.morphAttributes.normal,morphColors:void 0!==S.morphAttributes.color,morphTargetsCount:P,morphTextureStride:I,numDirLights:o.directional.length,numPointLights:o.point.length,numSpotLights:o.spot.length,numRectAreaLights:o.rectArea.length,numHemiLights:o.hemi.length,numDirLightShadows:o.directionalShadowMap.length,numPointLightShadows:o.pointShadowMap.length,numSpotLightShadows:o.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:s.dithering,shadowMapEnabled:e.shadowMap.enabled&&h.length>0,shadowMapType:e.shadowMap.type,toneMapping:s.toneMapped?e.toneMapping:0,physicallyCorrectLights:e.physicallyCorrectLights,premultipliedAlpha:s.premultipliedAlpha,doubleSided:2===s.side,flipSided:1===s.side,depthPacking:void 0!==s.depthPacking&&s.depthPacking,index0AttributeName:s.index0AttributeName,extensionDerivatives:s.extensions&&s.extensions.derivatives,extensionFragDepth:s.extensions&&s.extensions.fragDepth,extensionDrawBuffers:s.extensions&&s.extensions.drawBuffers,extensionShaderTextureLOD:s.extensions&&s.extensions.shaderTextureLOD,rendererExtensionFragDepth:u||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:u||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:u||n.has("EXT_shader_texture_lod"),customProgramCacheKey:s.customProgramCacheKey()};return z},getProgramCacheKey:function(t){let i=[];if(t.shaderID?i.push(t.shaderID):(i.push(t.customVertexShaderID),i.push(t.customFragmentShaderID)),void 0!==t.defines)for(let e in t.defines)i.push(e),i.push(t.defines[e]);return!1===t.isRawShaderMaterial&&(i.push(t.precision),i.push(t.outputEncoding),i.push(t.envMapMode),i.push(t.envMapCubeUVHeight),i.push(t.combine),i.push(t.vertexUvs),i.push(t.fogExp2),i.push(t.sizeAttenuation),i.push(t.maxBones),i.push(t.morphTargetsCount),i.push(t.morphAttributeCount),i.push(t.numDirLights),i.push(t.numPointLights),i.push(t.numSpotLights),i.push(t.numHemiLights),i.push(t.numRectAreaLights),i.push(t.numDirLightShadows),i.push(t.numPointLightShadows),i.push(t.numSpotLightShadows),i.push(t.shadowMapType),i.push(t.toneMapping),i.push(t.numClippingPlanes),i.push(t.numClipIntersection),o.disableAll(),t.isWebGL2&&o.enable(0),t.supportsVertexTextures&&o.enable(1),t.instancing&&o.enable(2),t.instancingColor&&o.enable(3),t.map&&o.enable(4),t.matcap&&o.enable(5),t.envMap&&o.enable(6),t.lightMap&&o.enable(7),t.aoMap&&o.enable(8),t.emissiveMap&&o.enable(9),t.bumpMap&&o.enable(10),t.normalMap&&o.enable(11),t.objectSpaceNormalMap&&o.enable(12),t.tangentSpaceNormalMap&&o.enable(13),t.clearcoat&&o.enable(14),t.clearcoatMap&&o.enable(15),t.clearcoatRoughnessMap&&o.enable(16),t.clearcoatNormalMap&&o.enable(17),t.displacementMap&&o.enable(18),t.specularMap&&o.enable(19),t.roughnessMap&&o.enable(20),t.metalnessMap&&o.enable(21),t.gradientMap&&o.enable(22),t.alphaMap&&o.enable(23),t.alphaTest&&o.enable(24),t.vertexColors&&o.enable(25),t.vertexAlphas&&o.enable(26),t.vertexUvs&&o.enable(27),t.vertexTangents&&o.enable(28),t.uvsVertexOnly&&o.enable(29),t.fog&&o.enable(30),i.push(o.mask),o.disableAll(),t.useFog&&o.enable(0),t.flatShading&&o.enable(1),t.logarithmicDepthBuffer&&o.enable(2),t.skinning&&o.enable(3),t.useVertexTexture&&o.enable(4),t.morphTargets&&o.enable(5),t.morphNormals&&o.enable(6),t.morphColors&&o.enable(7),t.premultipliedAlpha&&o.enable(8),t.shadowMapEnabled&&o.enable(9),t.physicallyCorrectLights&&o.enable(10),t.doubleSided&&o.enable(11),t.flipSided&&o.enable(12),t.depthPacking&&o.enable(13),t.dithering&&o.enable(14),t.specularIntensityMap&&o.enable(15),t.specularColorMap&&o.enable(16),t.transmission&&o.enable(17),t.transmissionMap&&o.enable(18),t.thicknessMap&&o.enable(19),t.sheen&&o.enable(20),t.sheenColorMap&&o.enable(21),t.sheenRoughnessMap&&o.enable(22),t.decodeVideoTexture&&o.enable(23),t.opaque&&o.enable(24),i.push(o.mask),i.push(e.outputEncoding)),i.push(t.customProgramCacheKey),i.join()},getUniforms:function(e){let t;let i=g[e.type];if(i){let e=t0[i];t=tO.clone(e.uniforms)}else t=e.uniforms;return t},acquireProgram:function(t,i){let n;// Check if code has been already compiled
for(let e=0,t=h.length;e<t;e++){let t=h[e];if(t.cacheKey===i){n=t,++n.usedTimes;break}}return void 0===n&&(n=new nP(e,i,t,s),h.push(n)),n},releaseProgram:function(e){if(0==--e.usedTimes){// Remove from unordered set
let t=h.indexOf(e);h[t]=h[h.length-1],h.pop(),// Free WebGL resources
e.destroy()}},releaseShaderCache:function(e){l.remove(e)},// Exposed for resource monitoring & error feedback via renderer.info:
programs:h,dispose:function(){l.dispose()}}}function nz(){let e=new WeakMap;return{get:function(t){let i=e.get(t);return void 0===i&&(i={},e.set(t,i)),i},remove:function(t){e.delete(t)},update:function(t,i,n){e.get(t)[i]=n},dispose:function(){e=new WeakMap}}}function nU(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.material.id!==t.material.id?e.material.id-t.material.id:e.z!==t.z?e.z-t.z:e.id-t.id}function nH(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id-t.id}function nF(){let e=[],t=0,i=[],n=[],r=[];function s(i,n,r,s,a,o){let l=e[t];return void 0===l?(l={id:i.id,object:i,geometry:n,material:r,groupOrder:s,renderOrder:i.renderOrder,z:a,group:o},e[t]=l):(l.id=i.id,l.object=i,l.geometry=n,l.material=r,l.groupOrder=s,l.renderOrder=i.renderOrder,l.z=a,l.group=o),t++,l}return{opaque:i,transmissive:n,transparent:r,init:function(){t=0,i.length=0,n.length=0,r.length=0},push:function(e,t,a,o,l,h){let u=s(e,t,a,o,l,h);a.transmission>0?n.push(u):!0===a.transparent?r.push(u):i.push(u)},unshift:function(e,t,a,o,l,h){let u=s(e,t,a,o,l,h);a.transmission>0?n.unshift(u):!0===a.transparent?r.unshift(u):i.unshift(u)},finish:function(){// Clear references from inactive renderItems in the list
for(let i=t,n=e.length;i<n;i++){let t=e[i];if(null===t.id)break;t.id=null,t.object=null,t.geometry=null,t.material=null,t.group=null}},sort:function(e,t){i.length>1&&i.sort(e||nU),n.length>1&&n.sort(t||nH),r.length>1&&r.sort(t||nH)}}}function nB(){let e=new WeakMap;return{get:function(t,i){let n;return!1===e.has(t)?(n=new nF,e.set(t,[n])):i>=e.get(t).length?(n=new nF,e.get(t).push(n)):n=e.get(t)[i],n},dispose:function(){e=new WeakMap}}}function nG(){let e={};return{get:function(t){let i;if(void 0!==e[t.id])return e[t.id];switch(t.type){case"DirectionalLight":i={direction:new q,color:new O};break;case"SpotLight":i={position:new q,direction:new q,color:new O,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":i={position:new q,color:new O,distance:0,decay:0};break;case"HemisphereLight":i={direction:new q,skyColor:new O,groundColor:new O};break;case"RectAreaLight":i={color:new O,position:new q,halfWidth:new q,halfHeight:new q}}return e[t.id]=i,i}}}let nk=0;function nV(e,t){return(t.castShadow?1:0)-(e.castShadow?1:0)}function nW(e,t){let i=new nG,n=function(){let e={};return{get:function(t){let i;if(void 0!==e[t.id])return e[t.id];switch(t.type){case"DirectionalLight":case"SpotLight":i={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new b};break;case"PointLight":i={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new b,shadowCameraNear:1,shadowCameraFar:1e3}}return e[t.id]=i,i}}}(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let e=0;e<9;e++)r.probe.push(new q);let s=new q,a=new ew,o=new ew;return{setup:function(s,a){let o=0,l=0,h=0;for(let e=0;e<9;e++)r.probe[e].set(0,0,0);let u=0,c=0,d=0,p=0,m=0,f=0,g=0,v=0;s.sort(nV);// artist-friendly light intensity scaling factor
let x=!0!==a?Math.PI:1;for(let e=0,t=s.length;e<t;e++){let t=s[e],a=t.color,y=t.intensity,_=t.distance,b=t.shadow&&t.shadow.map?t.shadow.map.texture:null;if(t.isAmbientLight)o+=a.r*y*x,l+=a.g*y*x,h+=a.b*y*x;else if(t.isLightProbe)for(let e=0;e<9;e++)r.probe[e].addScaledVector(t.sh.coefficients[e],y);else if(t.isDirectionalLight){let e=i.get(t);if(e.color.copy(t.color).multiplyScalar(t.intensity*x),t.castShadow){let e=t.shadow,i=n.get(t);i.shadowBias=e.bias,i.shadowNormalBias=e.normalBias,i.shadowRadius=e.radius,i.shadowMapSize=e.mapSize,r.directionalShadow[u]=i,r.directionalShadowMap[u]=b,r.directionalShadowMatrix[u]=t.shadow.matrix,f++}r.directional[u]=e,u++}else if(t.isSpotLight){let e=i.get(t);if(e.position.setFromMatrixPosition(t.matrixWorld),e.color.copy(a).multiplyScalar(y*x),e.distance=_,e.coneCos=Math.cos(t.angle),e.penumbraCos=Math.cos(t.angle*(1-t.penumbra)),e.decay=t.decay,t.castShadow){let e=t.shadow,i=n.get(t);i.shadowBias=e.bias,i.shadowNormalBias=e.normalBias,i.shadowRadius=e.radius,i.shadowMapSize=e.mapSize,r.spotShadow[d]=i,r.spotShadowMap[d]=b,r.spotShadowMatrix[d]=t.shadow.matrix,v++}r.spot[d]=e,d++}else if(t.isRectAreaLight){let e=i.get(t);// (a) intensity is the total visible light emitted
//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
// (b) intensity is the brightness of the light
e.color.copy(a).multiplyScalar(y),e.halfWidth.set(.5*t.width,0,0),e.halfHeight.set(0,.5*t.height,0),r.rectArea[p]=e,p++}else if(t.isPointLight){let e=i.get(t);if(e.color.copy(t.color).multiplyScalar(t.intensity*x),e.distance=t.distance,e.decay=t.decay,t.castShadow){let e=t.shadow,i=n.get(t);i.shadowBias=e.bias,i.shadowNormalBias=e.normalBias,i.shadowRadius=e.radius,i.shadowMapSize=e.mapSize,i.shadowCameraNear=e.camera.near,i.shadowCameraFar=e.camera.far,r.pointShadow[c]=i,r.pointShadowMap[c]=b,r.pointShadowMatrix[c]=t.shadow.matrix,g++}r.point[c]=e,c++}else if(t.isHemisphereLight){let e=i.get(t);e.skyColor.copy(t.color).multiplyScalar(y*x),e.groundColor.copy(t.groundColor).multiplyScalar(y*x),r.hemi[m]=e,m++}}p>0&&(t.isWebGL2?(// WebGL 2
r.rectAreaLTC1=t$.LTC_FLOAT_1,r.rectAreaLTC2=t$.LTC_FLOAT_2):!0===e.has("OES_texture_float_linear")?(r.rectAreaLTC1=t$.LTC_FLOAT_1,r.rectAreaLTC2=t$.LTC_FLOAT_2):!0===e.has("OES_texture_half_float_linear")?(r.rectAreaLTC1=t$.LTC_HALF_1,r.rectAreaLTC2=t$.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=o,r.ambient[1]=l,r.ambient[2]=h;let y=r.hash;(y.directionalLength!==u||y.pointLength!==c||y.spotLength!==d||y.rectAreaLength!==p||y.hemiLength!==m||y.numDirectionalShadows!==f||y.numPointShadows!==g||y.numSpotShadows!==v)&&(r.directional.length=u,r.spot.length=d,r.rectArea.length=p,r.point.length=c,r.hemi.length=m,r.directionalShadow.length=f,r.directionalShadowMap.length=f,r.pointShadow.length=g,r.pointShadowMap.length=g,r.spotShadow.length=v,r.spotShadowMap.length=v,r.directionalShadowMatrix.length=f,r.pointShadowMatrix.length=g,r.spotShadowMatrix.length=v,y.directionalLength=u,y.pointLength=c,y.spotLength=d,y.rectAreaLength=p,y.hemiLength=m,y.numDirectionalShadows=f,y.numPointShadows=g,y.numSpotShadows=v,r.version=nk++)},setupView:function(e,t){let i=0,n=0,l=0,h=0,u=0,c=t.matrixWorldInverse;for(let t=0,d=e.length;t<d;t++){let d=e[t];if(d.isDirectionalLight){let e=r.directional[i];e.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),e.direction.sub(s),e.direction.transformDirection(c),i++}else if(d.isSpotLight){let e=r.spot[l];e.position.setFromMatrixPosition(d.matrixWorld),e.position.applyMatrix4(c),e.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),e.direction.sub(s),e.direction.transformDirection(c),l++}else if(d.isRectAreaLight){let e=r.rectArea[h];e.position.setFromMatrixPosition(d.matrixWorld),e.position.applyMatrix4(c),// extract local rotation of light to derive width/height half vectors
o.identity(),a.copy(d.matrixWorld),a.premultiply(c),o.extractRotation(a),e.halfWidth.set(.5*d.width,0,0),e.halfHeight.set(0,.5*d.height,0),e.halfWidth.applyMatrix4(o),e.halfHeight.applyMatrix4(o),h++}else if(d.isPointLight){let e=r.point[n];e.position.setFromMatrixPosition(d.matrixWorld),e.position.applyMatrix4(c),n++}else if(d.isHemisphereLight){let e=r.hemi[u];e.direction.setFromMatrixPosition(d.matrixWorld),e.direction.transformDirection(c),e.direction.normalize(),u++}}},state:r}}function nj(e,t){let i=new nW(e,t),n=[],r=[];return{init:function(){n.length=0,r.length=0},state:{lightsArray:n,shadowsArray:r,lights:i},setupLights:function(e){i.setup(n,e)},setupLightsView:function(e){i.setupView(n,e)},pushLight:function(e){n.push(e)},pushShadow:function(e){r.push(e)}}}function nq(e,t){let i=new WeakMap;return{get:function(n,r=0){let s;return!1===i.has(n)?(s=new nj(e,t),i.set(n,[s])):r>=i.get(n).length?(s=new nj(e,t),i.get(n).push(s)):s=i.get(n)[r],s},dispose:function(){i=new WeakMap}}}class nX extends e8{constructor(e){super(),this.type="MeshDepthMaterial",this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}nX.prototype.isMeshDepthMaterial=!0;class nY extends e8{constructor(e){super(),this.type="MeshDistanceMaterial",this.referencePosition=new q,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}function nJ(e,t,i){let n=new tY,r=new b,s=new b,a=new G,o=new nX({depthPacking:3201}),l=new nY,h={},u=i.maxTextureSize,c={0:1,1:0,2:2},d=new tz({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new b},radius:{value:4}},vertexShader:"void main() {\n	gl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),p=d.clone();p.defines.HORIZONTAL_PASS=1;let m=new td;m.setAttribute("position",new tt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));let f=new tC(m,d),g=this;function v(t,i,n,r,s,a){let u=null,d=!0===n.isPointLight?t.customDistanceMaterial:t.customDepthMaterial;if(u=void 0!==d?d:!0===n.isPointLight?l:o,e.localClippingEnabled&&!0===i.clipShadows&&0!==i.clippingPlanes.length||i.displacementMap&&0!==i.displacementScale||i.alphaMap&&i.alphaTest>0){// in this case we need a unique material instance reflecting the
// appropriate state
let e=u.uuid,t=i.uuid,n=h[e];void 0===n&&(n={},h[e]=n);let r=n[t];void 0===r&&(r=u.clone(),n[t]=r),u=r}return u.visible=i.visible,u.wireframe=i.wireframe,3===a?u.side=null!==i.shadowSide?i.shadowSide:i.side:u.side=null!==i.shadowSide?i.shadowSide:c[i.side],u.alphaMap=i.alphaMap,u.alphaTest=i.alphaTest,u.clipShadows=i.clipShadows,u.clippingPlanes=i.clippingPlanes,u.clipIntersection=i.clipIntersection,u.displacementMap=i.displacementMap,u.displacementScale=i.displacementScale,u.displacementBias=i.displacementBias,u.wireframeLinewidth=i.wireframeLinewidth,u.linewidth=i.linewidth,!0===n.isPointLight&&!0===u.isMeshDistanceMaterial&&(u.referencePosition.setFromMatrixPosition(n.matrixWorld),u.nearDistance=r,u.farDistance=s),u}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(i,o,l){if(!1===g.enabled||!1===g.autoUpdate&&!1===g.needsUpdate||0===i.length)return;let h=e.getRenderTarget(),c=e.getActiveCubeFace(),m=e.getActiveMipmapLevel(),x=e.state;// Set GL state for depth map.
x.setBlending(0),x.buffers.color.setClear(1,1,1,1),x.buffers.depth.setTest(!0),x.setScissorTest(!1);// render depth map
for(let h=0,c=i.length;h<c;h++){let c=i[h],m=c.shadow;if(void 0===m){console.warn("THREE.WebGLShadowMap:",c,"has no shadow.");continue}if(!1===m.autoUpdate&&!1===m.needsUpdate)continue;r.copy(m.mapSize);let g=m.getFrameExtents();if(r.multiply(g),s.copy(m.mapSize),(r.x>u||r.y>u)&&(r.x>u&&(s.x=Math.floor(u/g.x),r.x=s.x*g.x,m.mapSize.x=s.x),r.y>u&&(s.y=Math.floor(u/g.y),r.y=s.y*g.y,m.mapSize.y=s.y)),null!==m.map||m.isPointLightShadow||3!==this.type||(m.map=new k(r.x,r.y),m.map.texture.name=c.name+".shadowMap",m.mapPass=new k(r.x,r.y),m.camera.updateProjectionMatrix()),null===m.map){let e={minFilter:1003,magFilter:1003,format:1023};m.map=new k(r.x,r.y,e),m.map.texture.name=c.name+".shadowMap",m.camera.updateProjectionMatrix()}e.setRenderTarget(m.map),e.clear();let y=m.getViewportCount();for(let i=0;i<y;i++){let r=m.getViewport(i);a.set(s.x*r.x,s.y*r.y,s.x*r.z,s.y*r.w),x.viewport(a),m.updateMatrices(c,i),n=m.getFrustum(),function i(r,s,a,o,l){if(!1===r.visible)return;let h=r.layers.test(s.layers);if(h&&(r.isMesh||r.isLine||r.isPoints)&&(r.castShadow||r.receiveShadow&&3===l)&&(!r.frustumCulled||n.intersectsObject(r))){r.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse,r.matrixWorld);let i=t.update(r),n=r.material;if(Array.isArray(n)){let t=i.groups;for(let s=0,h=t.length;s<h;s++){let h=t[s],u=n[h.materialIndex];if(u&&u.visible){let t=v(r,u,o,a.near,a.far,l);e.renderBufferDirect(a,null,i,t,r,h)}}}else if(n.visible){let t=v(r,n,o,a.near,a.far,l);e.renderBufferDirect(a,null,i,t,r,null)}}let u=r.children;for(let e=0,t=u.length;e<t;e++)i(u[e],s,a,o,l)}(o,l,m.camera,c,this.type)}m.isPointLightShadow||3!==this.type||function(i,n){let r=t.update(f);d.defines.VSM_SAMPLES!==i.blurSamples&&(d.defines.VSM_SAMPLES=i.blurSamples,p.defines.VSM_SAMPLES=i.blurSamples,d.needsUpdate=!0,p.needsUpdate=!0),// vertical pass
d.uniforms.shadow_pass.value=i.map.texture,d.uniforms.resolution.value=i.mapSize,d.uniforms.radius.value=i.radius,e.setRenderTarget(i.mapPass),e.clear(),e.renderBufferDirect(n,null,r,d,f,null),// horizontal pass
p.uniforms.shadow_pass.value=i.mapPass.texture,p.uniforms.resolution.value=i.mapSize,p.uniforms.radius.value=i.radius,e.setRenderTarget(i.map),e.clear(),e.renderBufferDirect(n,null,r,p,f,null)}(m,l),m.needsUpdate=!1}g.needsUpdate=!1,e.setRenderTarget(h,c,m)}}function nZ(e,t,i){let n=i.isWebGL2,r=new function(){let t=!1,i=new G,n=null,r=new G(0,0,0,0);return{setMask:function(i){n===i||t||(e.colorMask(i,i,i,i),n=i)},setLocked:function(e){t=e},setClear:function(t,n,s,a,o){!0===o&&(t*=a,n*=a,s*=a),i.set(t,n,s,a),!1===r.equals(i)&&(e.clearColor(t,n,s,a),r.copy(i))},reset:function(){t=!1,n=null,r.set(-1,0,0,0)}}},s=new function(){let t=!1,i=null,n=null,r=null;return{setTest:function(e){e?U(2929):H(2929)},setMask:function(n){i===n||t||(e.depthMask(n),i=n)},setFunc:function(t){if(n!==t){if(t)switch(t){case 0:e.depthFunc(512);break;case 1:e.depthFunc(519);break;case 2:e.depthFunc(513);break;case 3:default:e.depthFunc(515);break;case 4:e.depthFunc(514);break;case 5:e.depthFunc(518);break;case 6:e.depthFunc(516);break;case 7:e.depthFunc(517)}else e.depthFunc(515);n=t}},setLocked:function(e){t=e},setClear:function(t){r!==t&&(e.clearDepth(t),r=t)},reset:function(){t=!1,i=null,n=null,r=null}}},a=new function(){let t=!1,i=null,n=null,r=null,s=null,a=null,o=null,l=null,h=null;return{setTest:function(e){t||(e?U(2960):H(2960))},setMask:function(n){i===n||t||(e.stencilMask(n),i=n)},setFunc:function(t,i,a){(n!==t||r!==i||s!==a)&&(e.stencilFunc(t,i,a),n=t,r=i,s=a)},setOp:function(t,i,n){(a!==t||o!==i||l!==n)&&(e.stencilOp(t,i,n),a=t,o=i,l=n)},setLocked:function(e){t=e},setClear:function(t){h!==t&&(e.clearStencil(t),h=t)},reset:function(){t=!1,i=null,n=null,r=null,s=null,a=null,o=null,l=null,h=null}}},o={},l={},h=new WeakMap,u=[],c=null,d=!1,p=null,m=null,f=null,g=null,v=null,x=null,y=null,_=!1,b=null,M=null,w=null,S=null,T=null,E=e.getParameter(35661),A=!1,R=e.getParameter(7938);-1!==R.indexOf("WebGL")?A=parseFloat(/^WebGL (\d)/.exec(R)[1])>=1:-1!==R.indexOf("OpenGL ES")&&(A=parseFloat(/^OpenGL ES (\d)/.exec(R)[1])>=2);let L=null,C={},P=e.getParameter(3088),I=e.getParameter(2978),D=new G().fromArray(P),N=new G().fromArray(I);function O(t,i,n){let r=new Uint8Array(4),s=e.createTexture();// 4 is required to match default unpack alignment of 4.
e.bindTexture(t,s),e.texParameteri(t,10241,9728),e.texParameteri(t,10240,9728);for(let t=0;t<n;t++)e.texImage2D(i+t,0,6408,1,1,0,6408,5121,r);return s}let z={};//
function U(t){!0!==o[t]&&(e.enable(t),o[t]=!0)}function H(t){!1!==o[t]&&(e.disable(t),o[t]=!1)}z[3553]=O(3553,3553,1),z[34067]=O(34067,34069,6),// init
r.setClear(0,0,0,1),s.setClear(1),a.setClear(0),U(2929),s.setFunc(3),V(!1),W(1),U(2884),k(0);let F={100:32774,101:32778,102:32779};if(n)F[103]=32775,F[104]=32776;else{let e=t.get("EXT_blend_minmax");null!==e&&(F[103]=e.MIN_EXT,F[104]=e.MAX_EXT)}let B={200:0,201:1,202:768,204:770,210:776,208:774,206:772,203:769,205:771,209:775,207:773};function k(t,i,n,r,s,a,o,l){if(0===t){!0===d&&(H(3042),d=!1);return}if(!1===d&&(U(3042),d=!0),5!==t){if(t!==p||l!==_){if((100!==m||100!==v)&&(e.blendEquation(32774),m=100,v=100),l)switch(t){case 1:e.blendFuncSeparate(1,771,1,771);break;case 2:e.blendFunc(1,1);break;case 3:e.blendFuncSeparate(0,769,0,1);break;case 4:e.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}else switch(t){case 1:e.blendFuncSeparate(770,771,1,771);break;case 2:e.blendFunc(770,1);break;case 3:e.blendFuncSeparate(0,769,0,1);break;case 4:e.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}f=null,g=null,x=null,y=null,p=t,_=l}return}// custom blending
s=s||i,a=a||n,o=o||r,(i!==m||s!==v)&&(e.blendEquationSeparate(F[i],F[s]),m=i,v=s),(n!==f||r!==g||a!==x||o!==y)&&(e.blendFuncSeparate(B[n],B[r],B[a],B[o]),f=n,g=r,x=a,y=o),p=t,_=null}//
function V(t){b!==t&&(t?e.frontFace(2304):e.frontFace(2305),b=t)}function W(t){0!==t?(U(2884),t!==M&&(1===t?e.cullFace(1029):2===t?e.cullFace(1028):e.cullFace(1032))):H(2884),M=t}function j(t,i,n){t?(U(32823),(S!==i||T!==n)&&(e.polygonOffset(i,n),S=i,T=n)):H(32823)}// texture
function q(t){void 0===t&&(t=33984+E-1),L!==t&&(e.activeTexture(t),L=t)}return{buffers:{color:r,depth:s,stencil:a},enable:U,disable:H,bindFramebuffer:function(t,i){return l[t]!==i&&(e.bindFramebuffer(t,i),l[t]=i,n&&(36009===t&&(l[36160]=i),36160===t&&(l[36009]=i)),!0)},drawBuffers:function(n,r){let s=u,a=!1;if(n){if(void 0===(s=h.get(r))&&(s=[],h.set(r,s)),n.isWebGLMultipleRenderTargets){let e=n.texture;if(s.length!==e.length||36064!==s[0]){for(let t=0,i=e.length;t<i;t++)s[t]=36064+t;s.length=e.length,a=!0}}else 36064!==s[0]&&(s[0]=36064,a=!0)}else 1029!==s[0]&&(s[0]=1029,a=!0);a&&(i.isWebGL2?e.drawBuffers(s):t.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))},useProgram:function(t){return c!==t&&(e.useProgram(t),c=t,!0)},setBlending:k,setMaterial:function(e,t){2===e.side?H(2884):U(2884);let i=1===e.side;t&&(i=!i),V(i),1===e.blending&&!1===e.transparent?k(0):k(e.blending,e.blendEquation,e.blendSrc,e.blendDst,e.blendEquationAlpha,e.blendSrcAlpha,e.blendDstAlpha,e.premultipliedAlpha),s.setFunc(e.depthFunc),s.setTest(e.depthTest),s.setMask(e.depthWrite),r.setMask(e.colorWrite);let n=e.stencilWrite;a.setTest(n),n&&(a.setMask(e.stencilWriteMask),a.setFunc(e.stencilFunc,e.stencilRef,e.stencilFuncMask),a.setOp(e.stencilFail,e.stencilZFail,e.stencilZPass)),j(e.polygonOffset,e.polygonOffsetFactor,e.polygonOffsetUnits),!0===e.alphaToCoverage?U(32926):H(32926)},setFlipSided:V,setCullFace:W,setLineWidth:function(t){t!==w&&(A&&e.lineWidth(t),w=t)},setPolygonOffset:j,setScissorTest:function(e){e?U(3089):H(3089)},activeTexture:q,bindTexture:function(t,i){null===L&&q();let n=C[L];void 0===n&&(n={type:void 0,texture:void 0},C[L]=n),(n.type!==t||n.texture!==i)&&(e.bindTexture(t,i||z[t]),n.type=t,n.texture=i)},unbindTexture:function(){let t=C[L];void 0!==t&&void 0!==t.type&&(e.bindTexture(t.type,null),t.type=void 0,t.texture=void 0)},compressedTexImage2D:function(){try{e.compressedTexImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage2D:function(){try{e.texImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage3D:function(){try{e.texImage3D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texStorage2D:function(){try{e.texStorage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texStorage3D:function(){try{e.texStorage3D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texSubImage2D:function(){try{e.texSubImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texSubImage3D:function(){try{e.texSubImage3D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},compressedTexSubImage2D:function(){try{e.compressedTexSubImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},scissor://
function(t){!1===D.equals(t)&&(e.scissor(t.x,t.y,t.z,t.w),D.copy(t))},viewport:function(t){!1===N.equals(t)&&(e.viewport(t.x,t.y,t.z,t.w),N.copy(t))},reset://
function(){// reset state
e.disable(3042),e.disable(2884),e.disable(2929),e.disable(32823),e.disable(3089),e.disable(2960),e.disable(32926),e.blendEquation(32774),e.blendFunc(1,0),e.blendFuncSeparate(1,0,1,0),e.colorMask(!0,!0,!0,!0),e.clearColor(0,0,0,0),e.depthMask(!0),e.depthFunc(513),e.clearDepth(1),e.stencilMask(4294967295),e.stencilFunc(519,0,4294967295),e.stencilOp(7680,7680,7680),e.clearStencil(0),e.cullFace(1029),e.frontFace(2305),e.polygonOffset(0,0),e.activeTexture(33984),e.bindFramebuffer(36160,null),!0===n&&(e.bindFramebuffer(36009,null),e.bindFramebuffer(36008,null)),e.useProgram(null),e.lineWidth(1),e.scissor(0,0,e.canvas.width,e.canvas.height),e.viewport(0,0,e.canvas.width,e.canvas.height),// reset internals
o={},L=null,C={},l={},h=new WeakMap,u=[],c=null,d=!1,p=null,m=null,f=null,g=null,v=null,x=null,y=null,_=!1,b=null,M=null,w=null,S=null,T=null,D.set(0,0,e.canvas.width,e.canvas.height),N.set(0,0,e.canvas.width,e.canvas.height),r.reset(),s.reset(),a.reset()}}}function nK(e,t,i,n,r,s,a){let o;let l=r.isWebGL2,h=r.maxTextures,u=r.maxCubemapSize,c=r.maxTextureSize,d=r.maxSamples,p=t.has("WEBGL_multisampled_render_to_texture")?t.get("WEBGL_multisampled_render_to_texture"):null,m=/OculusBrowser/g.test(navigator.userAgent),f=new WeakMap,g=new WeakMap,x=!1;try{x="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(e){// Ignore any errors
}function _(e,t){// Use OffscreenCanvas when available. Specially needed in web workers
return x?new OffscreenCanvas(e,t):S("canvas")}function b(e,t,i,n){let r=1;// only perform resize if necessary
if((e.width>n||e.height>n)&&(r=n/Math.max(e.width,e.height)),r<1||!0===t){// only perform resize for certain image types
if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap){let n=t?y:Math.floor,s=n(r*e.width),a=n(r*e.height);void 0===o&&(o=_(s,a));// cube textures can't reuse the same canvas
let l=i?_(s,a):o;l.width=s,l.height=a;let h=l.getContext("2d");return h.drawImage(e,0,0,s,a),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+e.width+"x"+e.height+") to ("+s+"x"+a+")."),l}"data"in e&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+e.width+"x"+e.height+").")}return e}function M(e){return v(e.width)&&v(e.height)}function w(e,t){return e.generateMipmaps&&t&&1003!==e.minFilter&&1006!==e.minFilter}function T(t){e.generateMipmap(t)}function E(i,n,r,s,a=!1){if(!1===l)return n;if(null!==i){if(void 0!==e[i])return e[i];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+i+"'")}let o=n;return 6403===n&&(5126===r&&(o=33326),5131===r&&(o=33325),5121===r&&(o=33321)),33319===n&&(5126===r&&(o=33328),5131===r&&(o=33327),5121===r&&(o=33323)),6408===n&&(5126===r&&(o=34836),5131===r&&(o=34842),5121===r&&(o=3001===s&&!1===a?35907:32856),32819===r&&(o=32854),32820===r&&(o=32855)),(33325===o||33326===o||33327===o||33328===o||34842===o||34836===o)&&t.get("EXT_color_buffer_float"),o}function A(e,t,i){return!0===w(e,i)||e.isFramebufferTexture&&1003!==e.minFilter&&1006!==e.minFilter?Math.log2(Math.max(t.width,t.height))+1:void 0!==e.mipmaps&&e.mipmaps.length>0?e.mipmaps.length:e.isCompressedTexture&&Array.isArray(e.image)?t.mipmaps.length:1}// Fallback filters for non-power-of-2 textures
function R(e){return 1003===e||1004===e||1005===e?9728:9729}//
function L(e){let t=e.target;t.removeEventListener("dispose",L),//
function(e){let t=n.get(e);if(void 0===t.__webglInit)return;// check if it's necessary to remove the WebGLTexture object
let i=e.source,r=g.get(i);if(r){let n=r[t.__cacheKey];n.usedTimes--,0===n.usedTimes&&P(e),0===Object.keys(r).length&&g.delete(i)}n.remove(e)}(t),t.isVideoTexture&&f.delete(t)}function C(t){let i=t.target;i.removeEventListener("dispose",C),function(t){let i=t.texture,r=n.get(t),s=n.get(i);if(void 0!==s.__webglTexture&&(e.deleteTexture(s.__webglTexture),a.memory.textures--),t.depthTexture&&t.depthTexture.dispose(),t.isWebGLCubeRenderTarget)for(let t=0;t<6;t++)e.deleteFramebuffer(r.__webglFramebuffer[t]),r.__webglDepthbuffer&&e.deleteRenderbuffer(r.__webglDepthbuffer[t]);else e.deleteFramebuffer(r.__webglFramebuffer),r.__webglDepthbuffer&&e.deleteRenderbuffer(r.__webglDepthbuffer),r.__webglMultisampledFramebuffer&&e.deleteFramebuffer(r.__webglMultisampledFramebuffer),r.__webglColorRenderbuffer&&e.deleteRenderbuffer(r.__webglColorRenderbuffer),r.__webglDepthRenderbuffer&&e.deleteRenderbuffer(r.__webglDepthRenderbuffer);if(t.isWebGLMultipleRenderTargets)for(let t=0,r=i.length;t<r;t++){let r=n.get(i[t]);r.__webglTexture&&(e.deleteTexture(r.__webglTexture),a.memory.textures--),n.remove(i[t])}n.remove(i),n.remove(t)}(i)}function P(t){let i=n.get(t);e.deleteTexture(i.__webglTexture);let r=t.source,s=g.get(r);delete s[i.__cacheKey],a.memory.textures--}//
let I=0;//
function D(e,t){let r=n.get(e);if(e.isVideoTexture&&function(e){let t=a.render.frame;// Check the last frame we updated the VideoTexture
f.get(e)!==t&&(f.set(e,t),e.update())}(e),!1===e.isRenderTargetTexture&&e.version>0&&r.__version!==e.version){let i=e.image;if(null===i)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(!1===i.complete)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{F(r,e,t);return}}i.activeTexture(33984+t),i.bindTexture(3553,r.__webglTexture)}let N={1e3:10497,1001:33071,1002:33648},O={1003:9728,1004:9984,1005:9986,1006:9729,1007:9985,1008:9987};function U(i,s,a){if(a?(e.texParameteri(i,10242,N[s.wrapS]),e.texParameteri(i,10243,N[s.wrapT]),(32879===i||35866===i)&&e.texParameteri(i,32882,N[s.wrapR]),e.texParameteri(i,10240,O[s.magFilter]),e.texParameteri(i,10241,O[s.minFilter])):(e.texParameteri(i,10242,33071),e.texParameteri(i,10243,33071),(32879===i||35866===i)&&e.texParameteri(i,32882,33071),(1001!==s.wrapS||1001!==s.wrapT)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),e.texParameteri(i,10240,R(s.magFilter)),e.texParameteri(i,10241,R(s.minFilter)),1003!==s.minFilter&&1006!==s.minFilter&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===t.has("EXT_texture_filter_anisotropic")){let a=t.get("EXT_texture_filter_anisotropic");(1015!==s.type||!1!==t.has("OES_texture_float_linear"))&&(!1!==l||1016!==s.type||!1!==t.has("OES_texture_half_float_linear"))&&(s.anisotropy>1||n.get(s).__currentAnisotropy)&&(e.texParameterf(i,a.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(s.anisotropy,r.getMaxAnisotropy())),n.get(s).__currentAnisotropy=s.anisotropy);// verify extension for WebGL 1 and WebGL 2
}}function H(t,i){let n=!1;void 0===t.__webglInit&&(t.__webglInit=!0,i.addEventListener("dispose",L));// create Source <-> WebGLTextures mapping if necessary
let r=i.source,s=g.get(r);void 0===s&&(s={},g.set(r,s));// check if there is already a WebGLTexture object for the given texture parameters
let o=function(e){let t=[];return t.push(e.wrapS),t.push(e.wrapT),t.push(e.magFilter),t.push(e.minFilter),t.push(e.anisotropy),t.push(e.internalFormat),t.push(e.format),t.push(e.type),t.push(e.generateMipmaps),t.push(e.premultiplyAlpha),t.push(e.flipY),t.push(e.unpackAlignment),t.push(e.encoding),t.join()}(i);if(o!==t.__cacheKey){void 0===s[o]&&(// create new entry
s[o]={texture:e.createTexture(),usedTimes:0},a.memory.textures++,// when a new instance of WebGLTexture was created, a texture upload is required
// even if the image contents are identical
n=!0),s[o].usedTimes++;// every time the texture cache key changes, it's necessary to check if an instance of
// WebGLTexture can be deleted in order to avoid a memory leak.
let r=s[t.__cacheKey];void 0!==r&&(s[t.__cacheKey].usedTimes--,0===r.usedTimes&&P(i)),// store references to cache key and WebGLTexture object
t.__cacheKey=o,t.__webglTexture=s[o].texture}return n}function F(t,n,r){let a=3553;n.isDataArrayTexture&&(a=35866),n.isData3DTexture&&(a=32879);let o=H(t,n),h=n.source;if(i.activeTexture(33984+r),i.bindTexture(a,t.__webglTexture),h.version!==h.__currentVersion||!0===o){let r;e.pixelStorei(37440,n.flipY),e.pixelStorei(37441,n.premultiplyAlpha),e.pixelStorei(3317,n.unpackAlignment),e.pixelStorei(37443,0);let o=!l&&(1001!==n.wrapS||1001!==n.wrapT||1003!==n.minFilter&&1006!==n.minFilter)&&!1===M(n.image),u=b(n.image,o,!1,c);u=j(n,u);let d=M(u)||l,p=s.convert(n.format,n.encoding),m=s.convert(n.type),f=E(n.internalFormat,p,m,n.encoding,n.isVideoTexture);U(a,n,d);let g=n.mipmaps,v=l&&!0!==n.isVideoTexture,x=void 0===t.__version,y=A(n,u,d);if(n.isDepthTexture)// populate depth texture with dummy data
f=6402,l?f=1015===n.type?36012:1014===n.type?33190:1020===n.type?35056:33189:1015===n.type&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),1026===n.format&&6402===f&&1012!==n.type&&1014!==n.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),n.type=1012,m=s.convert(n.type)),1027===n.format&&6402===f&&(// Depth stencil textures need the DEPTH_STENCIL internal format
// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
f=34041,1020!==n.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),n.type=1020,m=s.convert(n.type))),v&&x?i.texStorage2D(3553,1,f,u.width,u.height):i.texImage2D(3553,0,f,u.width,u.height,0,p,m,null);else if(n.isDataTexture){// use manually created mipmaps if available
// if there are no manual mipmaps
// set 0 level mipmap and then use GL to generate other mipmap levels
if(g.length>0&&d){v&&x&&i.texStorage2D(3553,y,f,g[0].width,g[0].height);for(let e=0,t=g.length;e<t;e++)r=g[e],v?i.texSubImage2D(3553,e,0,0,r.width,r.height,p,m,r.data):i.texImage2D(3553,e,f,r.width,r.height,0,p,m,r.data);n.generateMipmaps=!1}else v?(x&&i.texStorage2D(3553,y,f,u.width,u.height),i.texSubImage2D(3553,0,0,0,u.width,u.height,p,m,u.data)):i.texImage2D(3553,0,f,u.width,u.height,0,p,m,u.data)}else if(n.isCompressedTexture){v&&x&&i.texStorage2D(3553,y,f,g[0].width,g[0].height);for(let e=0,t=g.length;e<t;e++)r=g[e],1023!==n.format?null!==p?v?i.compressedTexSubImage2D(3553,e,0,0,r.width,r.height,p,r.data):i.compressedTexImage2D(3553,e,f,r.width,r.height,0,r.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):v?i.texSubImage2D(3553,e,0,0,r.width,r.height,p,m,r.data):i.texImage2D(3553,e,f,r.width,r.height,0,p,m,r.data)}else if(n.isDataArrayTexture)v?(x&&i.texStorage3D(35866,y,f,u.width,u.height,u.depth),i.texSubImage3D(35866,0,0,0,0,u.width,u.height,u.depth,p,m,u.data)):i.texImage3D(35866,0,f,u.width,u.height,u.depth,0,p,m,u.data);else if(n.isData3DTexture)v?(x&&i.texStorage3D(32879,y,f,u.width,u.height,u.depth),i.texSubImage3D(32879,0,0,0,0,u.width,u.height,u.depth,p,m,u.data)):i.texImage3D(32879,0,f,u.width,u.height,u.depth,0,p,m,u.data);else if(n.isFramebufferTexture)v&&x?i.texStorage2D(3553,y,f,u.width,u.height):i.texImage2D(3553,0,f,u.width,u.height,0,p,m,null);else // regular Texture (image, video, canvas)
// use manually created mipmaps if available
// if there are no manual mipmaps
// set 0 level mipmap and then use GL to generate other mipmap levels
if(g.length>0&&d){v&&x&&i.texStorage2D(3553,y,f,g[0].width,g[0].height);for(let e=0,t=g.length;e<t;e++)r=g[e],v?i.texSubImage2D(3553,e,0,0,p,m,r):i.texImage2D(3553,e,f,p,m,r);n.generateMipmaps=!1}else v?(x&&i.texStorage2D(3553,y,f,u.width,u.height),i.texSubImage2D(3553,0,0,0,p,m,u)):i.texImage2D(3553,0,f,p,m,u);w(n,d)&&T(a),h.__currentVersion=h.version,n.onUpdate&&n.onUpdate(n)}t.__version=n.version}// Render targets
// Setup storage for target texture and bind it to correct framebuffer
function B(t,r,a,o,l){let h=s.convert(a.format,a.encoding),u=s.convert(a.type),c=E(a.internalFormat,h,u,a.encoding),d=n.get(r);d.__hasExternalTextures||(32879===l||35866===l?i.texImage3D(l,0,c,r.width,r.height,r.depth,0,h,u,null):i.texImage2D(l,0,c,r.width,r.height,0,h,u,null)),i.bindFramebuffer(36160,t),W(r)?p.framebufferTexture2DMultisampleEXT(36160,o,l,n.get(a).__webglTexture,0,V(r)):e.framebufferTexture2D(36160,o,l,n.get(a).__webglTexture,0),i.bindFramebuffer(36160,null)}// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
function G(t,i,n){if(e.bindRenderbuffer(36161,t),i.depthBuffer&&!i.stencilBuffer){let r=33189;if(n||W(i)){let t=i.depthTexture;t&&t.isDepthTexture&&(1015===t.type?r=36012:1014===t.type&&(r=33190));let n=V(i);W(i)?p.renderbufferStorageMultisampleEXT(36161,n,r,i.width,i.height):e.renderbufferStorageMultisample(36161,n,r,i.width,i.height)}else e.renderbufferStorage(36161,r,i.width,i.height);e.framebufferRenderbuffer(36160,36096,36161,t)}else if(i.depthBuffer&&i.stencilBuffer){let r=V(i);n&&!1===W(i)?e.renderbufferStorageMultisample(36161,r,35056,i.width,i.height):W(i)?p.renderbufferStorageMultisampleEXT(36161,r,35056,i.width,i.height):e.renderbufferStorage(36161,34041,i.width,i.height),e.framebufferRenderbuffer(36160,33306,36161,t)}else{// Use the first texture for MRT so far
let t=!0===i.isWebGLMultipleRenderTargets?i.texture[0]:i.texture,r=s.convert(t.format,t.encoding),a=s.convert(t.type),o=E(t.internalFormat,r,a,t.encoding),l=V(i);n&&!1===W(i)?e.renderbufferStorageMultisample(36161,l,o,i.width,i.height):W(i)?p.renderbufferStorageMultisampleEXT(36161,l,o,i.width,i.height):e.renderbufferStorage(36161,o,i.width,i.height)}e.bindRenderbuffer(36161,null)}// Setup GL resources for a non-texture depth buffer
function k(t){let r=n.get(t),s=!0===t.isWebGLCubeRenderTarget;if(t.depthTexture&&!r.__autoAllocateDepthBuffer){if(s)throw Error("target.depthTexture not supported in Cube render targets");!// Setup resources for a Depth Texture for a FBO (needs an extension)
function(t,r){let s=r&&r.isWebGLCubeRenderTarget;if(s)throw Error("Depth Texture with cube render targets is not supported");if(i.bindFramebuffer(36160,t),!(r.depthTexture&&r.depthTexture.isDepthTexture))throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");n.get(r.depthTexture).__webglTexture&&r.depthTexture.image.width===r.width&&r.depthTexture.image.height===r.height||(r.depthTexture.image.width=r.width,r.depthTexture.image.height=r.height,r.depthTexture.needsUpdate=!0),D(r.depthTexture,0);let a=n.get(r.depthTexture).__webglTexture,o=V(r);if(1026===r.depthTexture.format)W(r)?p.framebufferTexture2DMultisampleEXT(36160,36096,3553,a,0,o):e.framebufferTexture2D(36160,36096,3553,a,0);else if(1027===r.depthTexture.format)W(r)?p.framebufferTexture2DMultisampleEXT(36160,33306,3553,a,0,o):e.framebufferTexture2D(36160,33306,3553,a,0);else throw Error("Unknown depthTexture format")}(r.__webglFramebuffer,t)}else if(s){r.__webglDepthbuffer=[];for(let n=0;n<6;n++)i.bindFramebuffer(36160,r.__webglFramebuffer[n]),r.__webglDepthbuffer[n]=e.createRenderbuffer(),G(r.__webglDepthbuffer[n],t,!1)}else i.bindFramebuffer(36160,r.__webglFramebuffer),r.__webglDepthbuffer=e.createRenderbuffer(),G(r.__webglDepthbuffer,t,!1);i.bindFramebuffer(36160,null)}function V(e){return Math.min(d,e.samples)}function W(e){let i=n.get(e);return l&&e.samples>0&&!0===t.has("WEBGL_multisampled_render_to_texture")&&!1!==i.__useRenderToTexture}function j(e,i){let n=e.encoding,r=e.format,s=e.type;return!0===e.isCompressedTexture||!0===e.isVideoTexture||1035===e.format||3e3!==n&&(3001===n?!1===l?!0===t.has("EXT_sRGB")&&1023===r?(e.format=1035,// it's not possible to generate mips in WebGL 1 with this extension
e.minFilter=1006,e.generateMipmaps=!1):i=z.sRGBToLinear(i):(1023!==r||1009!==s)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",n)),i}//
this.allocateTextureUnit=function(){let e=I;return e>=h&&console.warn("THREE.WebGLTextures: Trying to use "+e+" texture units while this GPU supports only "+h),I+=1,e},this.resetTextureUnits=function(){I=0},this.setTexture2D=D,this.setTexture2DArray=function(e,t){let r=n.get(e);if(e.version>0&&r.__version!==e.version){F(r,e,t);return}i.activeTexture(33984+t),i.bindTexture(35866,r.__webglTexture)},this.setTexture3D=function(e,t){let r=n.get(e);if(e.version>0&&r.__version!==e.version){F(r,e,t);return}i.activeTexture(33984+t),i.bindTexture(32879,r.__webglTexture)},this.setTextureCube=function(t,r){let a=n.get(t);if(t.version>0&&a.__version!==t.version){(function(t,n,r){if(6!==n.image.length)return;let a=H(t,n),o=n.source;if(i.activeTexture(33984+r),i.bindTexture(34067,t.__webglTexture),o.version!==o.__currentVersion||!0===a){let r;e.pixelStorei(37440,n.flipY),e.pixelStorei(37441,n.premultiplyAlpha),e.pixelStorei(3317,n.unpackAlignment),e.pixelStorei(37443,0);let a=n.isCompressedTexture||n.image[0].isCompressedTexture,h=n.image[0]&&n.image[0].isDataTexture,c=[];for(let e=0;e<6;e++)a||h?c[e]=h?n.image[e].image:n.image[e]:c[e]=b(n.image[e],!1,!0,u),c[e]=j(n,c[e]);let d=c[0],p=M(d)||l,m=s.convert(n.format,n.encoding),f=s.convert(n.type),g=E(n.internalFormat,m,f,n.encoding),v=l&&!0!==n.isVideoTexture,x=void 0===t.__version,y=A(n,d,p);if(U(34067,n,p),a){v&&x&&i.texStorage2D(34067,y,g,d.width,d.height);for(let e=0;e<6;e++){r=c[e].mipmaps;for(let t=0;t<r.length;t++){let s=r[t];1023!==n.format?null!==m?v?i.compressedTexSubImage2D(34069+e,t,0,0,s.width,s.height,m,s.data):i.compressedTexImage2D(34069+e,t,g,s.width,s.height,0,s.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):v?i.texSubImage2D(34069+e,t,0,0,s.width,s.height,m,f,s.data):i.texImage2D(34069+e,t,g,s.width,s.height,0,m,f,s.data)}}}else{r=n.mipmaps,v&&x&&(r.length>0&&y++,i.texStorage2D(34067,y,g,c[0].width,c[0].height));for(let e=0;e<6;e++)if(h){v?i.texSubImage2D(34069+e,0,0,0,c[e].width,c[e].height,m,f,c[e].data):i.texImage2D(34069+e,0,g,c[e].width,c[e].height,0,m,f,c[e].data);for(let t=0;t<r.length;t++){let n=r[t],s=n.image[e].image;v?i.texSubImage2D(34069+e,t+1,0,0,s.width,s.height,m,f,s.data):i.texImage2D(34069+e,t+1,g,s.width,s.height,0,m,f,s.data)}}else{v?i.texSubImage2D(34069+e,0,0,0,m,f,c[e]):i.texImage2D(34069+e,0,g,m,f,c[e]);for(let t=0;t<r.length;t++){let n=r[t];v?i.texSubImage2D(34069+e,t+1,0,0,m,f,n.image[e]):i.texImage2D(34069+e,t+1,g,m,f,n.image[e])}}}w(n,p)&&T(34067),o.__currentVersion=o.version,n.onUpdate&&n.onUpdate(n)}t.__version=n.version})(a,t,r);return}i.activeTexture(33984+r),i.bindTexture(34067,a.__webglTexture)},this.rebindTextures=// rebind framebuffer with external textures
function(e,t,i){let r=n.get(e);void 0!==t&&B(r.__webglFramebuffer,e,e.texture,36064,3553),void 0!==i&&k(e)},this.setupRenderTarget=// Set up GL resources for the render target
function(t){let o=t.texture,h=n.get(t),u=n.get(o);t.addEventListener("dispose",C),!0!==t.isWebGLMultipleRenderTargets&&(void 0===u.__webglTexture&&(u.__webglTexture=e.createTexture()),u.__version=o.version,a.memory.textures++);let c=!0===t.isWebGLCubeRenderTarget,d=!0===t.isWebGLMultipleRenderTargets,p=M(t)||l;// Setup framebuffer
if(c){h.__webglFramebuffer=[];for(let t=0;t<6;t++)h.__webglFramebuffer[t]=e.createFramebuffer()}else if(h.__webglFramebuffer=e.createFramebuffer(),d){if(r.drawBuffers){let i=t.texture;for(let t=0,r=i.length;t<r;t++){let r=n.get(i[t]);void 0===r.__webglTexture&&(r.__webglTexture=e.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.")}else if(l&&t.samples>0&&!1===W(t)){h.__webglMultisampledFramebuffer=e.createFramebuffer(),h.__webglColorRenderbuffer=e.createRenderbuffer(),e.bindRenderbuffer(36161,h.__webglColorRenderbuffer);let n=s.convert(o.format,o.encoding),r=s.convert(o.type),a=E(o.internalFormat,n,r,o.encoding),l=V(t);e.renderbufferStorageMultisample(36161,l,a,t.width,t.height),i.bindFramebuffer(36160,h.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(36160,36064,36161,h.__webglColorRenderbuffer),e.bindRenderbuffer(36161,null),t.depthBuffer&&(h.__webglDepthRenderbuffer=e.createRenderbuffer(),G(h.__webglDepthRenderbuffer,t,!0)),i.bindFramebuffer(36160,null)}// Setup color buffer
if(c){i.bindTexture(34067,u.__webglTexture),U(34067,o,p);for(let e=0;e<6;e++)B(h.__webglFramebuffer[e],t,o,36064,34069+e);w(o,p)&&T(34067),i.unbindTexture()}else if(d){let e=t.texture;for(let r=0,s=e.length;r<s;r++){let s=e[r],a=n.get(s);i.bindTexture(3553,a.__webglTexture),U(3553,s,p),B(h.__webglFramebuffer,t,s,36064+r,3553),w(s,p)&&T(3553)}i.unbindTexture()}else{let e=3553;(t.isWebGL3DRenderTarget||t.isWebGLArrayRenderTarget)&&(l?e=t.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),i.bindTexture(e,u.__webglTexture),U(e,o,p),B(h.__webglFramebuffer,t,o,36064,e),w(o,p)&&T(e),i.unbindTexture()}t.depthBuffer&&k(t)},this.updateRenderTargetMipmap=function(e){let t=M(e)||l,r=!0===e.isWebGLMultipleRenderTargets?e.texture:[e.texture];for(let s=0,a=r.length;s<a;s++){let a=r[s];if(w(a,t)){let t=e.isWebGLCubeRenderTarget?34067:3553,r=n.get(a).__webglTexture;i.bindTexture(t,r),T(t),i.unbindTexture()}}},this.updateMultisampleRenderTarget=function(t){if(l&&t.samples>0&&!1===W(t)){let r=t.width,s=t.height,a=16384,o=[36064],l=t.stencilBuffer?33306:36096;t.depthBuffer&&o.push(l);let h=n.get(t),u=void 0!==h.__ignoreDepthValues&&h.__ignoreDepthValues;!1===u&&(t.depthBuffer&&(a|=256),t.stencilBuffer&&(a|=1024)),i.bindFramebuffer(36008,h.__webglMultisampledFramebuffer),i.bindFramebuffer(36009,h.__webglFramebuffer),!0===u&&(e.invalidateFramebuffer(36008,[l]),e.invalidateFramebuffer(36009,[l])),e.blitFramebuffer(0,0,r,s,0,0,r,s,a,9728),m&&e.invalidateFramebuffer(36008,o),i.bindFramebuffer(36008,null),i.bindFramebuffer(36009,h.__webglMultisampledFramebuffer)}},this.setupDepthRenderbuffer=k,this.setupFrameBufferTexture=B,this.useMultisampledRTT=W}function nQ(e,t,i){let n=i.isWebGL2;return{convert:function(e,i=null){let r;if(1009===e)return 5121;if(1017===e)return 32819;if(1018===e)return 32820;if(1010===e)return 5120;if(1011===e)return 5122;if(1012===e)return 5123;if(1013===e)return 5124;if(1014===e)return 5125;if(1015===e)return 5126;if(1016===e)return n?5131:null!==(r=t.get("OES_texture_half_float"))?r.HALF_FLOAT_OES:null;if(1021===e)return 6406;if(1023===e)return 6408;if(1024===e)return 6409;if(1025===e)return 6410;if(1026===e)return 6402;if(1027===e)return 34041;if(1028===e)return 6403;if(1022===e)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;// WebGL 1 sRGB fallback
if(1035===e)return null!==(r=t.get("EXT_sRGB"))?r.SRGB_ALPHA_EXT:null;// WebGL2 formats.
if(1029===e)return 36244;if(1030===e)return 33319;if(1031===e)return 33320;if(1033===e)return 36249;// S3TC
if(33776===e||33777===e||33778===e||33779===e){if(3001===i){if(null===(r=t.get("WEBGL_compressed_texture_s3tc_srgb")))return null;if(33776===e)return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(33777===e)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(33778===e)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(33779===e)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(null===(r=t.get("WEBGL_compressed_texture_s3tc")))return null;if(33776===e)return r.COMPRESSED_RGB_S3TC_DXT1_EXT;if(33777===e)return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(33778===e)return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(33779===e)return r.COMPRESSED_RGBA_S3TC_DXT5_EXT}}// PVRTC
if(35840===e||35841===e||35842===e||35843===e){if(null===(r=t.get("WEBGL_compressed_texture_pvrtc")))return null;if(35840===e)return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(35841===e)return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(35842===e)return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(35843===e)return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}// ETC1
if(36196===e)return null!==(r=t.get("WEBGL_compressed_texture_etc1"))?r.COMPRESSED_RGB_ETC1_WEBGL:null;// ETC2
if(37492===e||37496===e){if(null===(r=t.get("WEBGL_compressed_texture_etc")))return null;if(37492===e)return 3001===i?r.COMPRESSED_SRGB8_ETC2:r.COMPRESSED_RGB8_ETC2;if(37496===e)return 3001===i?r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:r.COMPRESSED_RGBA8_ETC2_EAC}// ASTC
if(37808===e||37809===e||37810===e||37811===e||37812===e||37813===e||37814===e||37815===e||37816===e||37817===e||37818===e||37819===e||37820===e||37821===e){if(null===(r=t.get("WEBGL_compressed_texture_astc")))return null;if(37808===e)return 3001===i?r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:r.COMPRESSED_RGBA_ASTC_4x4_KHR;if(37809===e)return 3001===i?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:r.COMPRESSED_RGBA_ASTC_5x4_KHR;if(37810===e)return 3001===i?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:r.COMPRESSED_RGBA_ASTC_5x5_KHR;if(37811===e)return 3001===i?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:r.COMPRESSED_RGBA_ASTC_6x5_KHR;if(37812===e)return 3001===i?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:r.COMPRESSED_RGBA_ASTC_6x6_KHR;if(37813===e)return 3001===i?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:r.COMPRESSED_RGBA_ASTC_8x5_KHR;if(37814===e)return 3001===i?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:r.COMPRESSED_RGBA_ASTC_8x6_KHR;if(37815===e)return 3001===i?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:r.COMPRESSED_RGBA_ASTC_8x8_KHR;if(37816===e)return 3001===i?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:r.COMPRESSED_RGBA_ASTC_10x5_KHR;if(37817===e)return 3001===i?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:r.COMPRESSED_RGBA_ASTC_10x6_KHR;if(37818===e)return 3001===i?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:r.COMPRESSED_RGBA_ASTC_10x8_KHR;if(37819===e)return 3001===i?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:r.COMPRESSED_RGBA_ASTC_10x10_KHR;if(37820===e)return 3001===i?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:r.COMPRESSED_RGBA_ASTC_12x10_KHR;if(37821===e)return 3001===i?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:r.COMPRESSED_RGBA_ASTC_12x12_KHR}// BPTC
if(36492===e){if(null===(r=t.get("EXT_texture_compression_bptc")))return null;if(36492===e)return 3001===i?r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:r.COMPRESSED_RGBA_BPTC_UNORM_EXT}//
if(1020===e)return n?34042:null!==(r=t.get("WEBGL_depth_texture"))?r.UNSIGNED_INT_24_8_WEBGL:null}}}nY.prototype.isMeshDistanceMaterial=!0;class n$ extends tH{constructor(e=[]){super(),this.cameras=e}}n$.prototype.isArrayCamera=!0;class n0 extends eY{constructor(){super(),this.type="Group"}}n0.prototype.isGroup=!0;const n1={type:"move"};class n3{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new n0,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new n0,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new q,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new q),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new n0,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new q,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new q),this._grip}dispatchEvent(e){return null!==this._targetRay&&this._targetRay.dispatchEvent(e),null!==this._grip&&this._grip.dispatchEvent(e),null!==this._hand&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(e,t,i){let n=null,r=null,s=null,a=this._targetRay,o=this._grip,l=this._hand;if(e&&"visible-blurred"!==t.session.visibilityState){if(null!==a&&null!==(n=t.getPose(e.targetRaySpace,i))&&(a.matrix.fromArray(n.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),n.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(n.linearVelocity)):a.hasLinearVelocity=!1,n.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(n.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(n1)),l&&e.hand){for(let n of(s=!0,e.hand.values())){// Update the joints groups with the XRJoint poses
let e=t.getJointPose(n,i);if(void 0===l.joints[n.jointName]){// The transform of this joint will be updated with the joint pose on each frame
let e=new n0;e.matrixAutoUpdate=!1,e.visible=!1,l.joints[n.jointName]=e,// ??
l.add(e)}let r=l.joints[n.jointName];null!==e&&(r.matrix.fromArray(e.transform.matrix),r.matrix.decompose(r.position,r.rotation,r.scale),r.jointRadius=e.radius),r.visible=null!==e}// Custom events
// Check pinchz
let n=l.joints["index-finger-tip"],r=l.joints["thumb-tip"],a=n.position.distanceTo(r.position);l.inputState.pinching&&a>.025?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!l.inputState.pinching&&a<=.015&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else null!==o&&e.gripSpace&&null!==(r=t.getPose(e.gripSpace,i))&&(o.matrix.fromArray(r.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),r.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(r.linearVelocity)):o.hasLinearVelocity=!1,r.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(r.angularVelocity)):o.hasAngularVelocity=!1)}return null!==a&&(a.visible=null!==n),null!==o&&(o.visible=null!==r),null!==l&&(l.visible=null!==s),this}}class n2 extends B{constructor(e,t,i,n,r,s,a,o,l,h){if(1026!==(h=void 0!==h?h:1026)&&1027!==h)throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===i&&1026===h&&(i=1012),void 0===i&&1027===h&&(i=1020),super(null,n,r,s,a,o,h,i,l),this.image={width:e,height:t},this.magFilter=void 0!==a?a:1003,this.minFilter=void 0!==o?o:1003,this.flipY=!1,this.generateMipmaps=!1}}n2.prototype.isDepthTexture=!0;class n4 extends l{constructor(e,t){super();let i=this,n=null,r=1,s=null,a="local-floor",o=null,l=null,h=null,u=null,c=null,d=t.getContextAttributes(),p=null,m=null,f=[],g=new Map,v=new tH;v.layers.enable(1),v.viewport=new G;let x=new tH;x.layers.enable(2),x.viewport=new G;let y=[v,x],_=new n$;_.layers.enable(1),_.layers.enable(2);let b=null,M=null;//
function w(e){let t=g.get(e.inputSource);t&&t.dispatchEvent({type:e.type,data:e.inputSource})}function S(){g.forEach(function(e,t){e.disconnect(t)}),g.clear(),b=null,M=null,// restore framebuffer/rendering state
e.setRenderTarget(p),u=null,h=null,l=null,n=null,m=null,//
C.stop(),i.isPresenting=!1,i.dispatchEvent({type:"sessionend"})}function T(e){let t=n.inputSources;// Assign inputSources to available controllers
for(let e=0;e<f.length;e++)g.set(t[e],f[e]);// Notify disconnected
for(let t=0;t<e.removed.length;t++){let i=e.removed[t],n=g.get(i);n&&(n.dispatchEvent({type:"disconnected",data:i}),g.delete(i))}// Notify connected
for(let t=0;t<e.added.length;t++){let i=e.added[t],n=g.get(i);n&&n.dispatchEvent({type:"connected",data:i})}}//
this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(e){let t=f[e];return void 0===t&&(t=new n3,f[e]=t),t.getTargetRaySpace()},this.getControllerGrip=function(e){let t=f[e];return void 0===t&&(t=new n3,f[e]=t),t.getGripSpace()},this.getHand=function(e){let t=f[e];return void 0===t&&(t=new n3,f[e]=t),t.getHandSpace()},this.setFramebufferScaleFactor=function(e){r=e,!0===i.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(e){a=e,!0===i.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return s},this.getBaseLayer=function(){return null!==h?h:u},this.getBinding=function(){return l},this.getFrame=function(){return c},this.getSession=function(){return n},this.setSession=async function(o){if(null!==(n=o)){if(p=e.getRenderTarget(),n.addEventListener("select",w),n.addEventListener("selectstart",w),n.addEventListener("selectend",w),n.addEventListener("squeeze",w),n.addEventListener("squeezestart",w),n.addEventListener("squeezeend",w),n.addEventListener("end",S),n.addEventListener("inputsourceschange",T),!0!==d.xrCompatible&&await t.makeXRCompatible(),void 0===n.renderState.layers||!1===e.capabilities.isWebGL2){let i={antialias:void 0!==n.renderState.layers||d.antialias,alpha:d.alpha,depth:d.depth,stencil:d.stencil,framebufferScaleFactor:r};u=new XRWebGLLayer(n,t,i),n.updateRenderState({baseLayer:u}),m=new k(u.framebufferWidth,u.framebufferHeight,{format:1023,type:1009,encoding:e.outputEncoding})}else{let i=null,s=null,a=null;d.depth&&(a=d.stencil?35056:33190,i=d.stencil?1027:1026,s=d.stencil?1020:1012);let o={colorFormat:3001===e.outputEncoding?35907:32856,depthFormat:a,scaleFactor:r};h=(l=new XRWebGLBinding(n,t)).createProjectionLayer(o),n.updateRenderState({layers:[h]}),m=new k(h.textureWidth,h.textureHeight,{format:1023,type:1009,depthTexture:new n2(h.textureWidth,h.textureHeight,s,void 0,void 0,void 0,void 0,void 0,void 0,i),stencilBuffer:d.stencil,encoding:e.outputEncoding,samples:d.antialias?4:0});let u=e.properties.get(m);u.__ignoreDepthValues=h.ignoreDepthValues}m.isXRRenderTarget=!0,// Set foveation to maximum.
this.setFoveation(1),s=await n.requestReferenceSpace(a),C.setContext(n),C.start(),i.isPresenting=!0,i.dispatchEvent({type:"sessionstart"})}};//
let E=new q,A=new q;function R(e,t){null===t?e.matrixWorld.copy(e.matrix):e.matrixWorld.multiplyMatrices(t.matrixWorld,e.matrix),e.matrixWorldInverse.copy(e.matrixWorld).invert()}this.updateCamera=function(e){if(null===n)return;_.near=x.near=v.near=e.near,_.far=x.far=v.far=e.far,(b!==_.near||M!==_.far)&&(// Note that the new renderState won't apply until the next frame. See #18320
n.updateRenderState({depthNear:_.near,depthFar:_.far}),b=_.near,M=_.far);let t=e.parent,i=_.cameras;R(_,t);for(let e=0;e<i.length;e++)R(i[e],t);_.matrixWorld.decompose(_.position,_.quaternion,_.scale),// update user camera and its children
e.position.copy(_.position),e.quaternion.copy(_.quaternion),e.scale.copy(_.scale),e.matrix.copy(_.matrix),e.matrixWorld.copy(_.matrixWorld);let r=e.children;for(let e=0,t=r.length;e<t;e++)r[e].updateMatrixWorld(!0);2===i.length?/**
		 * Assumes 2 cameras that are parallel and share an X-axis, and that
		 * the cameras' projection and world matrices have already been set.
		 * And that near and far planes are identical for both cameras.
		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		 */function(e,t,i){E.setFromMatrixPosition(t.matrixWorld),A.setFromMatrixPosition(i.matrixWorld);let n=E.distanceTo(A),r=t.projectionMatrix.elements,s=i.projectionMatrix.elements,a=r[14]/(r[10]-1),o=r[14]/(r[10]+1),l=(r[9]+1)/r[5],h=(r[9]-1)/r[5],u=(r[8]-1)/r[0],c=(s[8]+1)/s[0],d=n/(-u+c),p=-(d*u);// TODO: Better way to apply this offset?
t.matrixWorld.decompose(e.position,e.quaternion,e.scale),e.translateX(p),e.translateZ(d),e.matrixWorld.compose(e.position,e.quaternion,e.scale),e.matrixWorldInverse.copy(e.matrixWorld).invert();// Find the union of the frustum values of the cameras and scale
// the values so that the near plane's position does not change in world space,
// although must now be relative to the new union camera.
let m=a+d,f=o+d,g=a*u-p,v=a*c+(n-p),x=l*o/f*m,y=h*o/f*m;e.projectionMatrix.makePerspective(g,v,x,y,m,f)}(_,v,x):_.projectionMatrix.copy(v.projectionMatrix)},this.getCamera=function(){return _},this.getFoveation=function(){return null!==h?h.fixedFoveation:null!==u?u.fixedFoveation:void 0},this.setFoveation=function(e){null!==h&&(h.fixedFoveation=e),null!==u&&void 0!==u.fixedFoveation&&(u.fixedFoveation=e)};// Animation Loop
let L=null,C=new tJ;C.setAnimationLoop(function(t,i){if(o=i.getViewerPose(s),c=i,null!==o){let t=o.views;null!==u&&(e.setRenderTargetFramebuffer(m,u.framebuffer),e.setRenderTarget(m));let i=!1;// check if it's necessary to rebuild cameraVR's camera list
t.length!==_.cameras.length&&(_.cameras.length=0,i=!0);for(let n=0;n<t.length;n++){let r=t[n],s=null;if(null!==u)s=u.getViewport(r);else{let t=l.getViewSubImage(h,r);s=t.viewport,0===n&&(e.setRenderTargetTextures(m,t.colorTexture,h.ignoreDepthValues?void 0:t.depthStencilTexture),e.setRenderTarget(m))}let a=y[n];a.matrix.fromArray(r.transform.matrix),a.projectionMatrix.fromArray(r.projectionMatrix),a.viewport.set(s.x,s.y,s.width,s.height),0===n&&_.matrix.copy(a.matrix),!0===i&&_.cameras.push(a)}}//
let r=n.inputSources;for(let e=0;e<f.length;e++){let t=f[e],n=r[e];t.update(n,i,s)}L&&L(t,i),c=null}),this.setAnimationLoop=function(e){L=e},this.dispose=function(){}}}function n5(e,t){function i(i,n){let r,s;i.opacity.value=n.opacity,n.color&&i.diffuse.value.copy(n.color),n.emissive&&i.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),n.map&&(i.map.value=n.map),n.alphaMap&&(i.alphaMap.value=n.alphaMap),n.bumpMap&&(i.bumpMap.value=n.bumpMap,i.bumpScale.value=n.bumpScale,1===n.side&&(i.bumpScale.value*=-1)),n.displacementMap&&(i.displacementMap.value=n.displacementMap,i.displacementScale.value=n.displacementScale,i.displacementBias.value=n.displacementBias),n.emissiveMap&&(i.emissiveMap.value=n.emissiveMap),n.normalMap&&(i.normalMap.value=n.normalMap,i.normalScale.value.copy(n.normalScale),1===n.side&&i.normalScale.value.negate()),n.specularMap&&(i.specularMap.value=n.specularMap),n.alphaTest>0&&(i.alphaTest.value=n.alphaTest);let a=t.get(n).envMap;if(a&&(i.envMap.value=a,i.flipEnvMap.value=a.isCubeTexture&&!1===a.isRenderTargetTexture?-1:1,i.reflectivity.value=n.reflectivity,i.ior.value=n.ior,i.refractionRatio.value=n.refractionRatio),n.lightMap){i.lightMap.value=n.lightMap;// artist-friendly light intensity scaling factor
let t=!0!==e.physicallyCorrectLights?Math.PI:1;i.lightMapIntensity.value=n.lightMapIntensity*t}n.aoMap&&(i.aoMap.value=n.aoMap,i.aoMapIntensity.value=n.aoMapIntensity),n.map?r=n.map:n.specularMap?r=n.specularMap:n.displacementMap?r=n.displacementMap:n.normalMap?r=n.normalMap:n.bumpMap?r=n.bumpMap:n.roughnessMap?r=n.roughnessMap:n.metalnessMap?r=n.metalnessMap:n.alphaMap?r=n.alphaMap:n.emissiveMap?r=n.emissiveMap:n.clearcoatMap?r=n.clearcoatMap:n.clearcoatNormalMap?r=n.clearcoatNormalMap:n.clearcoatRoughnessMap?r=n.clearcoatRoughnessMap:n.specularIntensityMap?r=n.specularIntensityMap:n.specularColorMap?r=n.specularColorMap:n.transmissionMap?r=n.transmissionMap:n.thicknessMap?r=n.thicknessMap:n.sheenColorMap?r=n.sheenColorMap:n.sheenRoughnessMap&&(r=n.sheenRoughnessMap),void 0!==r&&(r.isWebGLRenderTarget&&(r=r.texture),!0===r.matrixAutoUpdate&&r.updateMatrix(),i.uvTransform.value.copy(r.matrix)),n.aoMap?s=n.aoMap:n.lightMap&&(s=n.lightMap),void 0!==s&&(s.isWebGLRenderTarget&&(s=s.texture),!0===s.matrixAutoUpdate&&s.updateMatrix(),i.uv2Transform.value.copy(s.matrix))}return{refreshFogUniforms:function(e,t){e.fogColor.value.copy(t.color),t.isFog?(e.fogNear.value=t.near,e.fogFar.value=t.far):t.isFogExp2&&(e.fogDensity.value=t.density)},refreshMaterialUniforms:function(e,n,r,s,a){let o,l;n.isMeshBasicMaterial?i(e,n):n.isMeshLambertMaterial?i(e,n):n.isMeshToonMaterial?(i(e,n),n.gradientMap&&(e.gradientMap.value=n.gradientMap)):n.isMeshPhongMaterial?(i(e,n),e.specular.value.copy(n.specular),e.shininess.value=Math.max(n.shininess,1e-4)):n.isMeshStandardMaterial?(i(e,n),function(e,i){e.roughness.value=i.roughness,e.metalness.value=i.metalness,i.roughnessMap&&(e.roughnessMap.value=i.roughnessMap),i.metalnessMap&&(e.metalnessMap.value=i.metalnessMap);let n=t.get(i).envMap;n&&(e.envMapIntensity.value=i.envMapIntensity)}(e,n),n.isMeshPhysicalMaterial&&(e.ior.value=n.ior,n.sheen>0&&(e.sheenColor.value.copy(n.sheenColor).multiplyScalar(n.sheen),e.sheenRoughness.value=n.sheenRoughness,n.sheenColorMap&&(e.sheenColorMap.value=n.sheenColorMap),n.sheenRoughnessMap&&(e.sheenRoughnessMap.value=n.sheenRoughnessMap)),n.clearcoat>0&&(e.clearcoat.value=n.clearcoat,e.clearcoatRoughness.value=n.clearcoatRoughness,n.clearcoatMap&&(e.clearcoatMap.value=n.clearcoatMap),n.clearcoatRoughnessMap&&(e.clearcoatRoughnessMap.value=n.clearcoatRoughnessMap),n.clearcoatNormalMap&&(e.clearcoatNormalScale.value.copy(n.clearcoatNormalScale),e.clearcoatNormalMap.value=n.clearcoatNormalMap,1===n.side&&e.clearcoatNormalScale.value.negate())),n.transmission>0&&(e.transmission.value=n.transmission,e.transmissionSamplerMap.value=a.texture,e.transmissionSamplerSize.value.set(a.width,a.height),n.transmissionMap&&(e.transmissionMap.value=n.transmissionMap),e.thickness.value=n.thickness,n.thicknessMap&&(e.thicknessMap.value=n.thicknessMap),e.attenuationDistance.value=n.attenuationDistance,e.attenuationColor.value.copy(n.attenuationColor)),e.specularIntensity.value=n.specularIntensity,e.specularColor.value.copy(n.specularColor),n.specularIntensityMap&&(e.specularIntensityMap.value=n.specularIntensityMap),n.specularColorMap&&(e.specularColorMap.value=n.specularColorMap))):n.isMeshMatcapMaterial?(i(e,n),n.matcap&&(e.matcap.value=n.matcap)):n.isMeshDepthMaterial?i(e,n):n.isMeshDistanceMaterial?(i(e,n),e.referencePosition.value.copy(n.referencePosition),e.nearDistance.value=n.nearDistance,e.farDistance.value=n.farDistance):n.isMeshNormalMaterial?i(e,n):n.isLineBasicMaterial?(e.diffuse.value.copy(n.color),e.opacity.value=n.opacity,n.isLineDashedMaterial&&(e.dashSize.value=n.dashSize,e.totalSize.value=n.dashSize+n.gapSize,e.scale.value=n.scale)):n.isPointsMaterial?(e.diffuse.value.copy(n.color),e.opacity.value=n.opacity,e.size.value=n.size*r,e.scale.value=.5*s,n.map&&(e.map.value=n.map),n.alphaMap&&(e.alphaMap.value=n.alphaMap),n.alphaTest>0&&(e.alphaTest.value=n.alphaTest),n.map?o=n.map:n.alphaMap&&(o=n.alphaMap),void 0!==o&&(!0===o.matrixAutoUpdate&&o.updateMatrix(),e.uvTransform.value.copy(o.matrix))):n.isSpriteMaterial?(e.diffuse.value.copy(n.color),e.opacity.value=n.opacity,e.rotation.value=n.rotation,n.map&&(e.map.value=n.map),n.alphaMap&&(e.alphaMap.value=n.alphaMap),n.alphaTest>0&&(e.alphaTest.value=n.alphaTest),n.map?l=n.map:n.alphaMap&&(l=n.alphaMap),void 0!==l&&(!0===l.matrixAutoUpdate&&l.updateMatrix(),e.uvTransform.value.copy(l.matrix))):n.isShadowMaterial?(e.color.value.copy(n.color),e.opacity.value=n.opacity):n.isShaderMaterial&&(n.uniformsNeedUpdate=!1);// #15581
}}}function n6(e={}){let t,i,n,r,s,a,o,l,h,u,c,d,p,m,f,g,v,x,_,M,w,T,E,A;let R=void 0!==e.canvas?e.canvas:function(){let e=S("canvas");return e.style.display="block",e}(),L=void 0!==e.context?e.context:null,C=void 0===e.depth||e.depth,P=void 0===e.stencil||e.stencil,I=void 0!==e.antialias&&e.antialias,D=void 0===e.premultipliedAlpha||e.premultipliedAlpha,N=void 0!==e.preserveDrawingBuffer&&e.preserveDrawingBuffer,O=void 0!==e.powerPreference?e.powerPreference:"default",z=void 0!==e.failIfMajorPerformanceCaveat&&e.failIfMajorPerformanceCaveat;t=void 0!==e.context?L.getContextAttributes().alpha:void 0!==e.alpha&&e.alpha;let U=null,H=null,F=[],B=[];// public properties
this.domElement=R,// Debug configuration container
this.debug={/**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */checkShaderErrors:!0},// clearing
this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,// scene graph
this.sortObjects=!0,// user-defined clipping
this.clippingPlanes=[],this.localClippingEnabled=!1,// physically based shading
this.outputEncoding=3e3,// physical lights
this.physicallyCorrectLights=!1,// tone mapping
this.toneMapping=0,this.toneMappingExposure=1;// internal properties
let V=this,W=!1,j=0,X=0,Y=null,J=-1,Z=null,K=new G,Q=new G,$=null,ee=R.width,et=R.height,ei=1,en=null,er=null,es=new G(0,0,ee,et),ea=new G(0,0,ee,et),eo=!1,el=new tY,eh=!1,eu=!1,ec=null,ed=new ew,ep=new b,em=new q,ef={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function eg(){return null===Y?ei:1}// initialize
let ev=L;function ex(e,t){for(let i=0;i<e.length;i++){let n=e[i],r=R.getContext(n,t);if(null!==r)return r}return null}try{if("setAttribute"in R&&R.setAttribute("data-engine","three.js r139"),// event listeners must be registered before WebGL context is created, see #12753
R.addEventListener("webglcontextlost",eb,!1),R.addEventListener("webglcontextrestored",eM,!1),null===ev){let e=["webgl2","webgl","experimental-webgl"];if(!0===V.isWebGL1Renderer&&e.shift(),ev=ex(e,{alpha:!0,depth:C,stencil:P,antialias:I,premultipliedAlpha:D,preserveDrawingBuffer:N,powerPreference:O,failIfMajorPerformanceCaveat:z}),null===ev){if(ex(e))throw Error("Error creating WebGL context with your selected attributes.");throw Error("Error creating WebGL context.")}}void 0===ev.getShaderPrecisionFormat&&(ev.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(e){throw console.error("THREE.WebGLRenderer: "+e.message),e}function ey(){i=new ip(ev),n=new t4(ev,i,e),i.init(n),E=new nQ(ev,i,n),r=new nZ(ev,i,n),s=new iv(ev),a=new nz,o=new nK(ev,i,r,a,n,E,s),l=new t6(V),h=new id(V),u=new tZ(ev,n),A=new t3(ev,i,u,n),c=new im(ev,u,s,A),d=new iM(ev,c,u,s),M=new ib(ev,n,o),v=new t5(a),p=new nO(V,l,h,i,n,A,v),m=new n5(V,a),f=new nB,g=new nq(i,n),_=new t1(V,l,r,d,t,D),x=new nJ(V,d,n),w=new t2(ev,i,s,n),T=new ig(ev,i,s,n),s.programs=p.programs,V.capabilities=n,V.extensions=i,V.properties=a,V.renderLists=f,V.shadowMap=x,V.state=r,V.info=s}ey();// xr
let e_=new n4(V,ev);// Events
function eb(e){e.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),W=!0}function eM(){console.log("THREE.WebGLRenderer: Context Restored."),W=!1;let e=s.autoReset,t=x.enabled,i=x.autoUpdate,n=x.needsUpdate,r=x.type;ey(),s.autoReset=e,x.enabled=t,x.autoUpdate=i,x.needsUpdate=n,x.type=r}function eS(e){let t=e.target;t.removeEventListener("dispose",eS),function(e){let t=a.get(e).programs;void 0!==t&&(t.forEach(function(e){p.releaseProgram(e)}),e.isShaderMaterial&&p.releaseShaderCache(e))}(t),a.remove(t)}this.xr=e_,// API
this.getContext=function(){return ev},this.getContextAttributes=function(){return ev.getContextAttributes()},this.forceContextLoss=function(){let e=i.get("WEBGL_lose_context");e&&e.loseContext()},this.forceContextRestore=function(){let e=i.get("WEBGL_lose_context");e&&e.restoreContext()},this.getPixelRatio=function(){return ei},this.setPixelRatio=function(e){void 0!==e&&(ei=e,this.setSize(ee,et,!1))},this.getSize=function(e){return e.set(ee,et)},this.setSize=function(e,t,i){if(e_.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}ee=e,et=t,R.width=Math.floor(e*ei),R.height=Math.floor(t*ei),!1!==i&&(R.style.width=e+"px",R.style.height=t+"px"),this.setViewport(0,0,e,t)},this.getDrawingBufferSize=function(e){return e.set(ee*ei,et*ei).floor()},this.setDrawingBufferSize=function(e,t,i){ee=e,et=t,ei=i,R.width=Math.floor(e*i),R.height=Math.floor(t*i),this.setViewport(0,0,e,t)},this.getCurrentViewport=function(e){return e.copy(K)},this.getViewport=function(e){return e.copy(es)},this.setViewport=function(e,t,i,n){e.isVector4?es.set(e.x,e.y,e.z,e.w):es.set(e,t,i,n),r.viewport(K.copy(es).multiplyScalar(ei).floor())},this.getScissor=function(e){return e.copy(ea)},this.setScissor=function(e,t,i,n){e.isVector4?ea.set(e.x,e.y,e.z,e.w):ea.set(e,t,i,n),r.scissor(Q.copy(ea).multiplyScalar(ei).floor())},this.getScissorTest=function(){return eo},this.setScissorTest=function(e){r.setScissorTest(eo=e)},this.setOpaqueSort=function(e){en=e},this.setTransparentSort=function(e){er=e},// Clearing
this.getClearColor=function(e){return e.copy(_.getClearColor())},this.setClearColor=function(){_.setClearColor.apply(_,arguments)},this.getClearAlpha=function(){return _.getClearAlpha()},this.setClearAlpha=function(){_.setClearAlpha.apply(_,arguments)},this.clear=function(e=!0,t=!0,i=!0){let n=0;e&&(n|=16384),t&&(n|=256),i&&(n|=1024),ev.clear(n)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},//
this.dispose=function(){R.removeEventListener("webglcontextlost",eb,!1),R.removeEventListener("webglcontextrestored",eM,!1),f.dispose(),g.dispose(),a.dispose(),l.dispose(),h.dispose(),d.dispose(),A.dispose(),p.dispose(),e_.dispose(),e_.removeEventListener("sessionstart",eE),e_.removeEventListener("sessionend",eA),ec&&(ec.dispose(),ec=null),eR.stop()},// Buffer rendering
this.renderBufferDirect=function(e,t,i,s,d,p){let f;null===t&&(t=ef);let g=d.isMesh&&0>d.matrixWorld.determinant(),x=function(e,t,i,s,u){var c;!0!==t.isScene&&(t=ef),o.resetTextureUnits();let d=t.fog,p=s.isMeshStandardMaterial?t.environment:null,f=null===Y?V.outputEncoding:!0===Y.isXRRenderTarget?Y.texture.encoding:3e3,g=(s.isMeshStandardMaterial?h:l).get(s.envMap||p),x=!0===s.vertexColors&&!!i.attributes.color&&4===i.attributes.color.itemSize,y=!!s.normalMap&&!!i.attributes.tangent,_=!!i.morphAttributes.position,b=!!i.morphAttributes.normal,w=!!i.morphAttributes.color,S=s.toneMapped?V.toneMapping:0,T=i.morphAttributes.position||i.morphAttributes.normal||i.morphAttributes.color,E=void 0!==T?T.length:0,A=a.get(s),R=H.state.lights;if(!0===eh&&(!0===eu||e!==Z)){let t=e===Z&&s.id===J;// we might want to call this function with some ClippingGroup
// object instead of the material, once it becomes feasible
// (#8465, #8379)
v.setState(s,e,t)}//
let L=!1;s.version===A.__version?A.needsLights&&A.lightsStateVersion!==R.state.version?L=!0:A.outputEncoding!==f?L=!0:u.isInstancedMesh&&!1===A.instancing?L=!0:u.isInstancedMesh||!0!==A.instancing?u.isSkinnedMesh&&!1===A.skinning?L=!0:u.isSkinnedMesh||!0!==A.skinning?A.envMap!==g?L=!0:s.fog&&A.fog!==d?L=!0:void 0!==A.numClippingPlanes&&(A.numClippingPlanes!==v.numPlanes||A.numIntersection!==v.numIntersection)?L=!0:A.vertexAlphas!==x?L=!0:A.vertexTangents!==y?L=!0:A.morphTargets!==_?L=!0:A.morphNormals!==b?L=!0:A.morphColors!==w?L=!0:A.toneMapping!==S?L=!0:!0===n.isWebGL2&&A.morphTargetsCount!==E&&(L=!0):L=!0:L=!0:(L=!0,A.__version=s.version);//
let C=A.currentProgram;!0===L&&(C=eP(s,t,u));let P=!1,I=!1,D=!1,N=C.getUniforms(),O=A.uniforms;if(r.useProgram(C.program)&&(P=!0,I=!0,D=!0),s.id!==J&&(J=s.id,I=!0),P||Z!==e){// load material specific uniforms
// (shader material also gets them for the sake of genericity)
if(N.setValue(ev,"projectionMatrix",e.projectionMatrix),n.logarithmicDepthBuffer&&N.setValue(ev,"logDepthBufFC",2/(Math.log(e.far+1)/Math.LN2)),Z!==e&&(Z=e,// lighting uniforms depend on the camera so enforce an update
// now, in case this material supports lights - or later, when
// the next material that does gets activated:
I=!0,D=!0),s.isShaderMaterial||s.isMeshPhongMaterial||s.isMeshToonMaterial||s.isMeshStandardMaterial||s.envMap){let t=N.map.cameraPosition;void 0!==t&&t.setValue(ev,em.setFromMatrixPosition(e.matrixWorld))}(s.isMeshPhongMaterial||s.isMeshToonMaterial||s.isMeshLambertMaterial||s.isMeshBasicMaterial||s.isMeshStandardMaterial||s.isShaderMaterial)&&N.setValue(ev,"isOrthographic",!0===e.isOrthographicCamera),(s.isMeshPhongMaterial||s.isMeshToonMaterial||s.isMeshLambertMaterial||s.isMeshBasicMaterial||s.isMeshStandardMaterial||s.isShaderMaterial||s.isShadowMaterial||u.isSkinnedMesh)&&N.setValue(ev,"viewMatrix",e.matrixWorldInverse)}// skinning and morph target uniforms must be set even if material didn't change
// auto-setting of texture unit for bone and morph texture must go before other textures
// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures
if(u.isSkinnedMesh){N.setOptional(ev,u,"bindMatrix"),N.setOptional(ev,u,"bindMatrixInverse");let e=u.skeleton;e&&(n.floatVertexTextures?(null===e.boneTexture&&e.computeBoneTexture(),N.setValue(ev,"boneTexture",e.boneTexture,o),N.setValue(ev,"boneTextureSize",e.boneTextureSize)):N.setOptional(ev,e,"boneMatrices"))}let z=i.morphAttributes;return(void 0!==z.position||void 0!==z.normal||void 0!==z.color&&!0===n.isWebGL2)&&M.update(u,i,s,C),(I||A.receiveShadow!==u.receiveShadow)&&(A.receiveShadow=u.receiveShadow,N.setValue(ev,"receiveShadow",u.receiveShadow)),I&&(N.setValue(ev,"toneMappingExposure",V.toneMappingExposure),A.needsLights&&(c=D,O.ambientLightColor.needsUpdate=c,O.lightProbe.needsUpdate=c,O.directionalLights.needsUpdate=c,O.directionalLightShadows.needsUpdate=c,O.pointLights.needsUpdate=c,O.pointLightShadows.needsUpdate=c,O.spotLights.needsUpdate=c,O.spotLightShadows.needsUpdate=c,O.rectAreaLights.needsUpdate=c,O.hemisphereLights.needsUpdate=c),d&&s.fog&&m.refreshFogUniforms(O,d),m.refreshMaterialUniforms(O,s,ei,et,ec),nf.upload(ev,A.uniformsList,O,o)),s.isShaderMaterial&&!0===s.uniformsNeedUpdate&&(nf.upload(ev,A.uniformsList,O,o),s.uniformsNeedUpdate=!1),s.isSpriteMaterial&&N.setValue(ev,"center",u.center),// common matrices
N.setValue(ev,"modelViewMatrix",u.modelViewMatrix),N.setValue(ev,"normalMatrix",u.normalMatrix),N.setValue(ev,"modelMatrix",u.matrixWorld),C}(e,t,i,s,d);r.setMaterial(s,g);//
let y=i.index,_=i.attributes.position;//
if(null===y){if(void 0===_||0===_.count)return}else if(0===y.count)return;//
let b=1;!0===s.wireframe&&(y=c.getWireframeAttribute(i),b=2),A.setup(d,s,x,i,y);let S=w;null!==y&&(f=u.get(y),(S=T).setIndex(f));//
let E=null!==y?y.count:_.count,R=i.drawRange.start*b,L=i.drawRange.count*b,C=null!==p?p.start*b:0,P=null!==p?p.count*b:1/0,I=Math.max(R,C),D=Math.max(0,Math.min(E,R+L,C+P)-1-I+1);if(0!==D){//
if(d.isMesh)!0===s.wireframe?(r.setLineWidth(s.wireframeLinewidth*eg()),S.setMode(1)):S.setMode(4);else if(d.isLine){let e=s.linewidth;void 0===e&&(e=1),r.setLineWidth(e*eg()),d.isLineSegments?S.setMode(1):d.isLineLoop?S.setMode(2):S.setMode(3)}else d.isPoints?S.setMode(0):d.isSprite&&S.setMode(4);if(d.isInstancedMesh)S.renderInstances(I,D,d.count);else if(i.isInstancedBufferGeometry){let e=Math.min(i.instanceCount,i._maxInstanceCount);S.renderInstances(I,D,e)}else S.render(I,D)}},// Compile
this.compile=function(e,t){(H=g.get(e)).init(),B.push(H),e.traverseVisible(function(e){e.isLight&&e.layers.test(t.layers)&&(H.pushLight(e),e.castShadow&&H.pushShadow(e))}),H.setupLights(V.physicallyCorrectLights),e.traverse(function(t){let i=t.material;if(i){if(Array.isArray(i))for(let n=0;n<i.length;n++){let r=i[n];eP(r,e,t)}else eP(i,e,t)}}),B.pop(),H=null};// Animation Loop
let eT=null;function eE(){eR.stop()}function eA(){eR.start()}let eR=new tJ;function eL(e,t,i,s){let a=e.opaque,l=e.transmissive,h=e.transparent;H.setupLightsView(i),l.length>0&&function(e,t,i){let r=n.isWebGL2;null===ec&&(ec=new k(1,1,{generateMipmaps:!0,type:null!==E.convert(1016)?1016:1009,minFilter:1008,samples:r&&!0===I?4:0})),V.getDrawingBufferSize(ep),r?ec.setSize(ep.x,ep.y):ec.setSize(y(ep.x),y(ep.y));//
let s=V.getRenderTarget();V.setRenderTarget(ec),V.clear();// Turn off the features which can affect the frag color for opaque objects pass.
// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
let a=V.toneMapping;V.toneMapping=0,eC(e,t,i),V.toneMapping=a,o.updateMultisampleRenderTarget(ec),o.updateRenderTargetMipmap(ec),V.setRenderTarget(s)}(a,t,i),s&&r.viewport(K.copy(s)),a.length>0&&eC(a,t,i),l.length>0&&eC(l,t,i),h.length>0&&eC(h,t,i),// Ensure depth buffer writing is enabled so it can be cleared on next render
r.buffers.depth.setTest(!0),r.buffers.depth.setMask(!0),r.buffers.color.setMask(!0),r.setPolygonOffset(!1)}function eC(e,t,i){let n=!0===t.isScene?t.overrideMaterial:null;for(let r=0,s=e.length;r<s;r++){let s=e[r],a=s.object,o=s.geometry,l=null===n?s.material:n,h=s.group;a.layers.test(i.layers)&&(a.onBeforeRender(V,t,i,o,l,h),a.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse,a.matrixWorld),a.normalMatrix.getNormalMatrix(a.modelViewMatrix),l.onBeforeRender(V,t,i,o,a,h),!0===l.transparent&&2===l.side?(l.side=1,l.needsUpdate=!0,V.renderBufferDirect(i,t,o,l,a,h),l.side=0,l.needsUpdate=!0,V.renderBufferDirect(i,t,o,l,a,h),l.side=2):V.renderBufferDirect(i,t,o,l,a,h),a.onAfterRender(V,t,i,o,l,h))}}function eP(e,t,i){!0!==t.isScene&&(t=ef);let n=a.get(e),r=H.state.lights,s=H.state.shadowsArray,o=r.state.version,u=p.getParameters(e,r.state,s,t,i),c=p.getProgramCacheKey(u),d=n.programs;// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change
n.environment=e.isMeshStandardMaterial?t.environment:null,n.fog=t.fog,n.envMap=(e.isMeshStandardMaterial?h:l).get(e.envMap||n.environment),void 0===d&&(// new material
e.addEventListener("dispose",eS),d=new Map,n.programs=d);let m=d.get(c);if(void 0!==m){if(n.currentProgram===m&&n.lightsStateVersion===o)return eI(e,u),m}else u.uniforms=p.getUniforms(e),e.onBuild(i,u,V),e.onBeforeCompile(u,V),m=p.acquireProgram(u,c),d.set(c,m),n.uniforms=u.uniforms;let f=n.uniforms;(e.isShaderMaterial||e.isRawShaderMaterial)&&!0!==e.clipping||(f.clippingPlanes=v.uniform),eI(e,u),// store the light setup it was created for
n.needsLights=e.isMeshLambertMaterial||e.isMeshToonMaterial||e.isMeshPhongMaterial||e.isMeshStandardMaterial||e.isShadowMaterial||e.isShaderMaterial&&!0===e.lights,n.lightsStateVersion=o,n.needsLights&&(// wire up the material to this renderer's lighting state
f.ambientLightColor.value=r.state.ambient,f.lightProbe.value=r.state.probe,f.directionalLights.value=r.state.directional,f.directionalLightShadows.value=r.state.directionalShadow,f.spotLights.value=r.state.spot,f.spotLightShadows.value=r.state.spotShadow,f.rectAreaLights.value=r.state.rectArea,f.ltc_1.value=r.state.rectAreaLTC1,f.ltc_2.value=r.state.rectAreaLTC2,f.pointLights.value=r.state.point,f.pointLightShadows.value=r.state.pointShadow,f.hemisphereLights.value=r.state.hemi,f.directionalShadowMap.value=r.state.directionalShadowMap,f.directionalShadowMatrix.value=r.state.directionalShadowMatrix,f.spotShadowMap.value=r.state.spotShadowMap,f.spotShadowMatrix.value=r.state.spotShadowMatrix,f.pointShadowMap.value=r.state.pointShadowMap,f.pointShadowMatrix.value=r.state.pointShadowMatrix);let g=m.getUniforms(),x=nf.seqWithValue(g.seq,f);return n.currentProgram=m,n.uniformsList=x,m}function eI(e,t){let i=a.get(e);i.outputEncoding=t.outputEncoding,i.instancing=t.instancing,i.skinning=t.skinning,i.morphTargets=t.morphTargets,i.morphNormals=t.morphNormals,i.morphColors=t.morphColors,i.morphTargetsCount=t.morphTargetsCount,i.numClippingPlanes=t.numClippingPlanes,i.numIntersection=t.numClipIntersection,i.vertexAlphas=t.vertexAlphas,i.vertexTangents=t.vertexTangents,i.toneMapping=t.toneMapping}eR.setAnimationLoop(function(e){eT&&eT(e)}),"undefined"!=typeof self&&eR.setContext(self),this.setAnimationLoop=function(e){eT=e,e_.setAnimationLoop(e),null===e?eR.stop():eR.start()},e_.addEventListener("sessionstart",eE),e_.addEventListener("sessionend",eA),// Rendering
this.render=function(e,t){if(void 0!==t&&!0!==t.isCamera){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(!0===W)return;!0===e.autoUpdate&&e.updateMatrixWorld(),null===t.parent&&t.updateMatrixWorld(),!0===e_.enabled&&!0===e_.isPresenting&&(!0===e_.cameraAutoUpdate&&e_.updateCamera(t),t=e_.getCamera()),!0===e.isScene&&e.onBeforeRender(V,e,t,Y),(H=g.get(e,B.length)).init(),B.push(H),ed.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),el.setFromProjectionMatrix(ed),eu=this.localClippingEnabled,eh=v.init(this.clippingPlanes,eu,t),(U=f.get(e,F.length)).init(),F.push(U),function e(t,i,n,r){if(!1===t.visible)return;let a=t.layers.test(i.layers);if(a){if(t.isGroup)n=t.renderOrder;else if(t.isLOD)!0===t.autoUpdate&&t.update(i);else if(t.isLight)H.pushLight(t),t.castShadow&&H.pushShadow(t);else if(t.isSprite){if(!t.frustumCulled||el.intersectsSprite(t)){r&&em.setFromMatrixPosition(t.matrixWorld).applyMatrix4(ed);let e=d.update(t),i=t.material;i.visible&&U.push(t,e,i,n,em.z,null)}}else if((t.isMesh||t.isLine||t.isPoints)&&(t.isSkinnedMesh&&t.skeleton.frame!==s.render.frame&&(t.skeleton.update(),t.skeleton.frame=s.render.frame),!t.frustumCulled||el.intersectsObject(t))){r&&em.setFromMatrixPosition(t.matrixWorld).applyMatrix4(ed);let e=d.update(t),i=t.material;if(Array.isArray(i)){let r=e.groups;for(let s=0,a=r.length;s<a;s++){let a=r[s],o=i[a.materialIndex];o&&o.visible&&U.push(t,e,o,n,em.z,a)}}else i.visible&&U.push(t,e,i,n,em.z,null)}}let o=t.children;for(let t=0,s=o.length;t<s;t++)e(o[t],i,n,r)}(e,t,0,V.sortObjects),U.finish(),!0===V.sortObjects&&U.sort(en,er),!0===eh&&v.beginShadows();let i=H.state.shadowsArray;if(x.render(i,e,t),!0===eh&&v.endShadows(),!0===this.info.autoReset&&this.info.reset(),//
_.render(U,e),// render scene
H.setupLights(V.physicallyCorrectLights),t.isArrayCamera){let i=t.cameras;for(let t=0,n=i.length;t<n;t++){let n=i[t];eL(U,e,n,n.viewport)}}else eL(U,e,t);null!==Y&&(// resolve multisample renderbuffers to a single-sample texture if necessary
o.updateMultisampleRenderTarget(Y),// Generate mipmap if we're using any kind of mipmap filtering
o.updateRenderTargetMipmap(Y)),!0===e.isScene&&e.onAfterRender(V,e,t),// _gl.finish();
A.resetDefaultState(),J=-1,Z=null,B.pop(),H=B.length>0?B[B.length-1]:null,F.pop(),U=F.length>0?F[F.length-1]:null},this.getActiveCubeFace=function(){return j},this.getActiveMipmapLevel=function(){return X},this.getRenderTarget=function(){return Y},this.setRenderTargetTextures=function(e,t,n){a.get(e.texture).__webglTexture=t,a.get(e.depthTexture).__webglTexture=n;let r=a.get(e);r.__hasExternalTextures=!0,r.__hasExternalTextures&&(r.__autoAllocateDepthBuffer=void 0===n,r.__autoAllocateDepthBuffer||!0!==i.has("WEBGL_multisampled_render_to_texture")||(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),r.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(e,t){let i=a.get(e);i.__webglFramebuffer=t,i.__useDefaultFramebuffer=void 0===t},this.setRenderTarget=function(e,t=0,i=0){Y=e,j=t,X=i;let s=!0;if(e){let t=a.get(e);void 0!==t.__useDefaultFramebuffer?(// We need to make sure to rebind the framebuffer.
r.bindFramebuffer(36160,null),s=!1):void 0===t.__webglFramebuffer?o.setupRenderTarget(e):t.__hasExternalTextures&&o.rebindTextures(e,a.get(e.texture).__webglTexture,a.get(e.depthTexture).__webglTexture)}let l=null,h=!1,u=!1;if(e){let i=e.texture;(i.isData3DTexture||i.isDataArrayTexture)&&(u=!0);let r=a.get(e).__webglFramebuffer;e.isWebGLCubeRenderTarget?(l=r[t],h=!0):l=n.isWebGL2&&e.samples>0&&!1===o.useMultisampledRTT(e)?a.get(e).__webglMultisampledFramebuffer:r,K.copy(e.viewport),Q.copy(e.scissor),$=e.scissorTest}else K.copy(es).multiplyScalar(ei).floor(),Q.copy(ea).multiplyScalar(ei).floor(),$=eo;let c=r.bindFramebuffer(36160,l);if(c&&n.drawBuffers&&s&&r.drawBuffers(e,l),r.viewport(K),r.scissor(Q),r.setScissorTest($),h){let n=a.get(e.texture);ev.framebufferTexture2D(36160,36064,34069+t,n.__webglTexture,i)}else if(u){let n=a.get(e.texture),r=t||0;ev.framebufferTextureLayer(36160,36064,n.__webglTexture,i||0,r)}J=-1},this.readRenderTargetPixels=function(e,t,s,o,l,h,u){if(!(e&&e.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let c=a.get(e).__webglFramebuffer;if(e.isWebGLCubeRenderTarget&&void 0!==u&&(c=c[u]),c){r.bindFramebuffer(36160,c);try{let r=e.texture,a=r.format,u=r.type;if(1023!==a&&E.convert(a)!==ev.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}let c=1016===u&&(i.has("EXT_color_buffer_half_float")||n.isWebGL2&&i.has("EXT_color_buffer_float"));if(1009!==u&&E.convert(u)!==ev.getParameter(35738)&&// Edge and Chrome Mac < 52 (#9513)
!(1015===u&&(n.isWebGL2||i.has("OES_texture_float")||i.has("WEBGL_color_buffer_float")))&&// Chrome Mac >= 52 and Firefox
!c){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
t>=0&&t<=e.width-o&&s>=0&&s<=e.height-l&&ev.readPixels(t,s,o,l,E.convert(a),E.convert(u),h)}finally{// restore framebuffer of current render target if necessary
let e=null!==Y?a.get(Y).__webglFramebuffer:null;r.bindFramebuffer(36160,e)}}},this.copyFramebufferToTexture=function(e,t,i=0){if(!0!==t.isFramebufferTexture){console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");return}let n=Math.pow(2,-i),s=Math.floor(t.image.width*n),a=Math.floor(t.image.height*n);o.setTexture2D(t,0),ev.copyTexSubImage2D(3553,i,0,0,e.x,e.y,s,a),r.unbindTexture()},this.copyTextureToTexture=function(e,t,i,n=0){let s=t.image.width,a=t.image.height,l=E.convert(i.format),h=E.convert(i.type);o.setTexture2D(i,0),// As another texture upload may have changed pixelStorei
// parameters, make sure they are correct for the dstTexture
ev.pixelStorei(37440,i.flipY),ev.pixelStorei(37441,i.premultiplyAlpha),ev.pixelStorei(3317,i.unpackAlignment),t.isDataTexture?ev.texSubImage2D(3553,n,e.x,e.y,s,a,l,h,t.image.data):t.isCompressedTexture?ev.compressedTexSubImage2D(3553,n,e.x,e.y,t.mipmaps[0].width,t.mipmaps[0].height,l,t.mipmaps[0].data):ev.texSubImage2D(3553,n,e.x,e.y,l,h,t.image),0===n&&i.generateMipmaps&&ev.generateMipmap(3553),r.unbindTexture()},this.copyTextureToTexture3D=function(e,t,i,n,s=0){let a;if(V.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}let l=e.max.x-e.min.x+1,h=e.max.y-e.min.y+1,u=e.max.z-e.min.z+1,c=E.convert(n.format),d=E.convert(n.type);if(n.isData3DTexture)o.setTexture3D(n,0),a=32879;else if(n.isDataArrayTexture)o.setTexture2DArray(n,0),a=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}ev.pixelStorei(37440,n.flipY),ev.pixelStorei(37441,n.premultiplyAlpha),ev.pixelStorei(3317,n.unpackAlignment);let p=ev.getParameter(3314),m=ev.getParameter(32878),f=ev.getParameter(3316),g=ev.getParameter(3315),v=ev.getParameter(32877),x=i.isCompressedTexture?i.mipmaps[0]:i.image;ev.pixelStorei(3314,x.width),ev.pixelStorei(32878,x.height),ev.pixelStorei(3316,e.min.x),ev.pixelStorei(3315,e.min.y),ev.pixelStorei(32877,e.min.z),i.isDataTexture||i.isData3DTexture?ev.texSubImage3D(a,s,t.x,t.y,t.z,l,h,u,c,d,x.data):i.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),ev.compressedTexSubImage3D(a,s,t.x,t.y,t.z,l,h,u,c,x.data)):ev.texSubImage3D(a,s,t.x,t.y,t.z,l,h,u,c,d,x),ev.pixelStorei(3314,p),ev.pixelStorei(32878,m),ev.pixelStorei(3316,f),ev.pixelStorei(3315,g),ev.pixelStorei(32877,v),0===s&&n.generateMipmaps&&ev.generateMipmap(a),r.unbindTexture()},this.initTexture=function(e){o.setTexture2D(e,0),r.unbindTexture()},this.resetState=function(){j=0,X=0,Y=null,r.reset(),A.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}n6.prototype.isWebGLRenderer=!0,(class extends n6{}).prototype.isWebGL1Renderer=!0;class n8{constructor(e,t=25e-5){this.name="",this.color=new O(e),this.density=t}clone(){return new n8(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}n8.prototype.isFogExp2=!0;class n7{constructor(e,t=1,i=1e3){this.name="",this.color=new O(e),this.near=t,this.far=i}clone(){return new n7(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}n7.prototype.isFog=!0;class n9 extends eY{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),null!==e.background&&(this.background=e.background.clone()),null!==e.environment&&(this.environment=e.environment.clone()),null!==e.fog&&(this.fog=e.fog.clone()),null!==e.overrideMaterial&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){let t=super.toJSON(e);return null!==this.fog&&(t.object.fog=this.fog.toJSON()),t}}n9.prototype.isScene=!0;class re{constructor(e,t){this.array=e,this.stride=t,this.count=void 0!==e?e.length/t:0,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=p()}onUploadCallback(){}set needsUpdate(e){!0===e&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,i){e*=this.stride,i*=t.stride;for(let n=0,r=this.stride;n<r;n++)this.array[e+n]=t.array[i+n];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=p()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);let t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),i=new this.constructor(t,this.stride);return i.setUsage(this.usage),i}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){//
return void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=p()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}re.prototype.isInterleavedBuffer=!0;const rt=/*@__PURE__*/new q;class ri{constructor(e,t,i,n=!1){this.name="",this.data=e,this.itemSize=t,this.offset=i,this.normalized=!0===n}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,i=this.data.count;t<i;t++)rt.fromBufferAttribute(this,t),rt.applyMatrix4(e),this.setXYZ(t,rt.x,rt.y,rt.z);return this}applyNormalMatrix(e){for(let t=0,i=this.count;t<i;t++)rt.fromBufferAttribute(this,t),rt.applyNormalMatrix(e),this.setXYZ(t,rt.x,rt.y,rt.z);return this}transformDirection(e){for(let t=0,i=this.count;t<i;t++)rt.fromBufferAttribute(this,t),rt.transformDirection(e),this.setXYZ(t,rt.x,rt.y,rt.z);return this}setX(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){return this.data.array[e*this.data.stride+this.offset]}getY(e){return this.data.array[e*this.data.stride+this.offset+1]}getZ(e){return this.data.array[e*this.data.stride+this.offset+2]}getW(e){return this.data.array[e*this.data.stride+this.offset+3]}setXY(e,t,i){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=i,this}setXYZ(e,t,i,n){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=i,this.data.array[e+2]=n,this}setXYZW(e,t,i,n,r){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=i,this.data.array[e+2]=n,this.data.array[e+3]=r,this}clone(e){if(void 0!==e)return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new ri(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized);{console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");let e=[];for(let t=0;t<this.count;t++){let i=t*this.data.stride+this.offset;for(let t=0;t<this.itemSize;t++)e.push(this.data.array[i+t])}return new tt(new this.array.constructor(e),this.itemSize,this.normalized)}}toJSON(e){if(void 0!==e)return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized};{console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");let e=[];for(let t=0;t<this.count;t++){let i=t*this.data.stride+this.offset;for(let t=0;t<this.itemSize;t++)e.push(this.data.array[i+t])}// deinterleave data and save it as an ordinary buffer attribute for now
return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}}}ri.prototype.isInterleavedBufferAttribute=!0;class rn extends e8{constructor(e){super(),this.type="SpriteMaterial",this.color=new O(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this}}rn.prototype.isSpriteMaterial=!0;const rr=/*@__PURE__*/new q,rs=/*@__PURE__*/new q,ra=/*@__PURE__*/new q,ro=/*@__PURE__*/new b,rl=/*@__PURE__*/new b,rh=/*@__PURE__*/new ew,ru=/*@__PURE__*/new q,rc=/*@__PURE__*/new q,rd=/*@__PURE__*/new q,rp=/*@__PURE__*/new b,rm=/*@__PURE__*/new b,rf=/*@__PURE__*/new b;function rg(e,t,i,n,r,s){// compute position in camera space
ro.subVectors(e,i).addScalar(.5).multiply(n),void 0!==r?(rl.x=s*ro.x-r*ro.y,rl.y=r*ro.x+s*ro.y):rl.copy(ro),e.copy(t),e.x+=rl.x,e.y+=rl.y,// transform to world space
e.applyMatrix4(rh)}(class extends eY{constructor(e){if(super(),this.type="Sprite",void 0===t){t=new td;let e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),i=new re(e,5);t.setIndex([0,1,2,0,2,3]),t.setAttribute("position",new ri(i,3,0,!1)),t.setAttribute("uv",new ri(i,2,3,!1))}this.geometry=t,this.material=void 0!==e?e:new rn,this.center=new b(.5,.5)}raycast(e,t){let i,n;null===e.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),rs.setFromMatrixScale(this.matrixWorld),rh.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),ra.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&rs.multiplyScalar(-ra.z);let r=this.material.rotation;0!==r&&(n=Math.cos(r),i=Math.sin(r));let s=this.center;rg(ru.set(-.5,-.5,0),ra,s,rs,i,n),rg(rc.set(.5,-.5,0),ra,s,rs,i,n),rg(rd.set(.5,.5,0),ra,s,rs,i,n),rp.set(0,0),rm.set(1,0),rf.set(1,1);// check first triangle
let a=e.ray.intersectTriangle(ru,rc,rd,!1,rr);if(null===a&&(// check second triangle
rg(rc.set(-.5,.5,0),ra,s,rs,i,n),rm.set(0,1),null===(a=e.ray.intersectTriangle(ru,rd,rc,!1,rr))))return;let o=e.ray.origin.distanceTo(rr);o<e.near||o>e.far||t.push({distance:o,point:rr.clone(),uv:e5.getUV(rr,ru,rc,rd,rp,rm,rf,new b),face:null,object:this})}copy(e){return super.copy(e),void 0!==e.center&&this.center.copy(e.center),this.material=e.material,this}}).prototype.isSprite=!0;const rv=/*@__PURE__*/new q,rx=/*@__PURE__*/new G,ry=/*@__PURE__*/new G,r_=/*@__PURE__*/new q,rb=/*@__PURE__*/new ew;class rM extends tC{constructor(e,t){super(e,t),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new ew,this.bindMatrixInverse=new ew}copy(e){return super.copy(e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this}bind(e,t){this.skeleton=e,void 0===t&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){let e=new G,t=this.geometry.attributes.skinWeight;for(let i=0,n=t.count;i<n;i++){e.fromBufferAttribute(t,i);let n=1/e.manhattanLength();n!==1/0?e.multiplyScalar(n):e.set(1,0,0,0),t.setXYZW(i,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(e,t){let i=this.skeleton,n=this.geometry;rx.fromBufferAttribute(n.attributes.skinIndex,e),ry.fromBufferAttribute(n.attributes.skinWeight,e),rv.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let e=0;e<4;e++){let n=ry.getComponent(e);if(0!==n){let r=rx.getComponent(e);rb.multiplyMatrices(i.bones[r].matrixWorld,i.boneInverses[r]),t.addScaledVector(r_.copy(rv).applyMatrix4(rb),n)}}return t.applyMatrix4(this.bindMatrixInverse)}}rM.prototype.isSkinnedMesh=!0;class rw extends eY{constructor(){super(),this.type="Bone"}}rw.prototype.isBone=!0;class rS extends B{constructor(e=null,t=1,i=1,n,r,s,a,o,l=1003,h=1003,u,c){super(null,s,a,o,l,h,n,r,u,c),this.image={data:e,width:t,height:i},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}rS.prototype.isDataTexture=!0;const rT=/*@__PURE__*/new ew,rE=/*@__PURE__*/new ew;class rA{constructor(e=[],t=[]){this.uuid=p(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){let e=this.bones,t=this.boneInverses;// calculate inverse bone matrices if necessary
if(this.boneMatrices=new Float32Array(16*e.length),0===t.length)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let e=0,t=this.bones.length;e<t;e++)this.boneInverses.push(new ew)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){let t=new ew;this.bones[e]&&t.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(t)}}pose(){// recover the bind-time world matrices
for(let e=0,t=this.bones.length;e<t;e++){let t=this.bones[e];t&&t.matrixWorld.copy(this.boneInverses[e]).invert()}// compute the local matrices, positions, rotations and scales
for(let e=0,t=this.bones.length;e<t;e++){let t=this.bones[e];t&&(t.parent&&t.parent.isBone?(t.matrix.copy(t.parent.matrixWorld).invert(),t.matrix.multiply(t.matrixWorld)):t.matrix.copy(t.matrixWorld),t.matrix.decompose(t.position,t.quaternion,t.scale))}}update(){let e=this.bones,t=this.boneInverses,i=this.boneMatrices,n=this.boneTexture;// flatten bone matrices to array
for(let n=0,r=e.length;n<r;n++){// compute the offset between the current and the original transform
let r=e[n]?e[n].matrixWorld:rE;rT.multiplyMatrices(r,t[n]),rT.toArray(i,16*n)}null!==n&&(n.needsUpdate=!0)}clone(){return new rA(this.bones,this.boneInverses)}computeBoneTexture(){// layout (1 matrix = 4 pixels)
//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
let e=Math.sqrt(4*this.bones.length);// 4 pixels needed for 1 matrix
e=Math.max(e=x(e),4);let t=new Float32Array(e*e*4);// 4 floats per RGBA pixel
t.set(this.boneMatrices);let i=new rS(t,e,e,1023,1015);return i.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=i,this.boneTextureSize=e,this}getBoneByName(e){for(let t=0,i=this.bones.length;t<i;t++){let i=this.bones[t];if(i.name===e)return i}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let i=0,n=e.bones.length;i<n;i++){let n=e.bones[i],r=t[n];void 0===r&&(console.warn("THREE.Skeleton: No bone found with UUID:",n),r=new rw),this.bones.push(r),this.boneInverses.push(new ew().fromArray(e.boneInverses[i]))}return this.init(),this}toJSON(){let e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;let t=this.bones,i=this.boneInverses;for(let n=0,r=t.length;n<r;n++){let r=t[n];e.bones.push(r.uuid);let s=i[n];e.boneInverses.push(s.toArray())}return e}}class rR extends tt{constructor(e,t,i,n=1){"number"==typeof i&&(n=i,i=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(e,t,i),this.meshPerAttribute=n}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){let e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}rR.prototype.isInstancedBufferAttribute=!0;const rL=/*@__PURE__*/new ew,rC=/*@__PURE__*/new ew,rP=[],rI=/*@__PURE__*/new tC;(class extends tC{constructor(e,t,i){super(e,t),this.instanceMatrix=new rR(new Float32Array(16*i),16),this.instanceColor=null,this.count=i,this.frustumCulled=!1}copy(e){return super.copy(e),this.instanceMatrix.copy(e.instanceMatrix),null!==e.instanceColor&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,this}getColorAt(e,t){t.fromArray(this.instanceColor.array,3*e)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,16*e)}raycast(e,t){let i=this.matrixWorld,n=this.count;if(rI.geometry=this.geometry,rI.material=this.material,void 0!==rI.material)for(let r=0;r<n;r++){// calculate the world matrix for each instance
this.getMatrixAt(r,rL),rC.multiplyMatrices(i,rL),// the mesh represents this single instance
rI.matrixWorld=rC,rI.raycast(e,rP);// process the result of raycast
for(let e=0,i=rP.length;e<i;e++){let i=rP[e];i.instanceId=r,i.object=this,t.push(i)}rP.length=0}}setColorAt(e,t){null===this.instanceColor&&(this.instanceColor=new rR(new Float32Array(3*this.instanceMatrix.count),3)),t.toArray(this.instanceColor.array,3*e)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,16*e)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}).prototype.isInstancedMesh=!0;class rD extends e8{constructor(e){super(),this.type="LineBasicMaterial",this.color=new O(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this}}rD.prototype.isLineBasicMaterial=!0;const rN=/*@__PURE__*/new q,rO=/*@__PURE__*/new q,rz=/*@__PURE__*/new ew,rU=/*@__PURE__*/new eM,rH=/*@__PURE__*/new em;class rF extends eY{constructor(e=new td,t=new rD){super(),this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){let e=this.geometry;if(e.isBufferGeometry){// we assume non-indexed geometry
if(null===e.index){let t=e.attributes.position,i=[0];for(let e=1,n=t.count;e<n;e++)rN.fromBufferAttribute(t,e-1),rO.fromBufferAttribute(t,e),i[e]=i[e-1],i[e]+=rN.distanceTo(rO);e.setAttribute("lineDistance",new tr(i,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.")}else e.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(e,t){let i=this.geometry,n=this.matrixWorld,r=e.params.Line.threshold,s=i.drawRange;if(null===i.boundingSphere&&i.computeBoundingSphere(),rH.copy(i.boundingSphere),rH.applyMatrix4(n),rH.radius+=r,!1===e.ray.intersectsSphere(rH))return;//
rz.copy(n).invert(),rU.copy(e.ray).applyMatrix4(rz);let a=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a,l=new q,h=new q,u=new q,c=new q,d=this.isLineSegments?2:1;if(i.isBufferGeometry){let n=i.index,r=i.attributes,a=r.position;if(null!==n){let i=Math.max(0,s.start),r=Math.min(n.count,s.start+s.count);for(let s=i,p=r-1;s<p;s+=d){let i=n.getX(s),r=n.getX(s+1);l.fromBufferAttribute(a,i),h.fromBufferAttribute(a,r);let d=rU.distanceSqToSegment(l,h,c,u);if(d>o)continue;c.applyMatrix4(this.matrixWorld);let p=e.ray.origin.distanceTo(c);p<e.near||p>e.far||t.push({distance:p,// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:u.clone().applyMatrix4(this.matrixWorld),index:s,face:null,faceIndex:null,object:this})}}else{let i=Math.max(0,s.start),n=Math.min(a.count,s.start+s.count);for(let r=i,s=n-1;r<s;r+=d){l.fromBufferAttribute(a,r),h.fromBufferAttribute(a,r+1);let i=rU.distanceSqToSegment(l,h,c,u);if(i>o)continue;c.applyMatrix4(this.matrixWorld);let n=e.ray.origin.distanceTo(c);n<e.near||n>e.far||t.push({distance:n,// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:u.clone().applyMatrix4(this.matrixWorld),index:r,face:null,faceIndex:null,object:this})}}}else i.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){let e=this.geometry;if(e.isBufferGeometry){let t=e.morphAttributes,i=Object.keys(t);if(i.length>0){let e=t[i[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,i=e.length;t<i;t++){let i=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=t}}}}else{let t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}rF.prototype.isLine=!0;const rB=/*@__PURE__*/new q,rG=/*@__PURE__*/new q;class rk extends rF{constructor(e,t){super(e,t),this.type="LineSegments"}computeLineDistances(){let e=this.geometry;if(e.isBufferGeometry){// we assume non-indexed geometry
if(null===e.index){let t=e.attributes.position,i=[];for(let e=0,n=t.count;e<n;e+=2)rB.fromBufferAttribute(t,e),rG.fromBufferAttribute(t,e+1),i[e]=0===e?0:i[e-1],i[e+1]=i[e]+rB.distanceTo(rG);e.setAttribute("lineDistance",new tr(i,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.")}else e.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}rk.prototype.isLineSegments=!0;class rV extends rF{constructor(e,t){super(e,t),this.type="LineLoop"}}rV.prototype.isLineLoop=!0;class rW extends e8{constructor(e){super(),this.type="PointsMaterial",this.color=new O(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this}}rW.prototype.isPointsMaterial=!0;const rj=/*@__PURE__*/new ew,rq=/*@__PURE__*/new eM,rX=/*@__PURE__*/new em,rY=/*@__PURE__*/new q;class rJ extends eY{constructor(e=new td,t=new rW){super(),this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}raycast(e,t){let i=this.geometry,n=this.matrixWorld,r=e.params.Points.threshold,s=i.drawRange;if(null===i.boundingSphere&&i.computeBoundingSphere(),rX.copy(i.boundingSphere),rX.applyMatrix4(n),rX.radius+=r,!1===e.ray.intersectsSphere(rX))return;//
rj.copy(n).invert(),rq.copy(e.ray).applyMatrix4(rj);let a=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a;if(i.isBufferGeometry){let r=i.index,a=i.attributes,l=a.position;if(null!==r){let i=Math.max(0,s.start),a=Math.min(r.count,s.start+s.count);for(let s=i;s<a;s++){let i=r.getX(s);rY.fromBufferAttribute(l,i),rZ(rY,i,o,n,e,t,this)}}else{let i=Math.max(0,s.start),r=Math.min(l.count,s.start+s.count);for(let s=i;s<r;s++)rY.fromBufferAttribute(l,s),rZ(rY,s,o,n,e,t,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){let e=this.geometry;if(e.isBufferGeometry){let t=e.morphAttributes,i=Object.keys(t);if(i.length>0){let e=t[i[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,i=e.length;t<i;t++){let i=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=t}}}}else{let t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}function rZ(e,t,i,n,r,s,a){let o=rq.distanceSqToPoint(e);if(o<i){let i=new q;rq.closestPointToPoint(e,i),i.applyMatrix4(n);let l=r.ray.origin.distanceTo(i);if(l<r.near||l>r.far)return;s.push({distance:l,distanceToRay:Math.sqrt(o),point:i,index:t,face:null,object:a})}}rJ.prototype.isPoints=!0,(class extends B{constructor(e,t,i,n,r,s,a,o,l){super(e,t,i,n,r,s,a,o,l),this.minFilter=void 0!==s?s:1006,this.magFilter=void 0!==r?r:1006,this.generateMipmaps=!1;let h=this;"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(function t(){h.needsUpdate=!0,e.requestVideoFrameCallback(t)})}clone(){return new this.constructor(this.image).copy(this)}update(){let e=this.image;!1=="requestVideoFrameCallback"in e&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}).prototype.isVideoTexture=!0,(class extends B{constructor(e,t,i){super({width:e,height:t}),this.format=i,this.magFilter=1003,this.minFilter=1003,this.generateMipmaps=!1,this.needsUpdate=!0}}).prototype.isFramebufferTexture=!0,(class extends B{constructor(e,t,i,n,r,s,a,o,l,h,u,c){super(null,s,a,o,l,h,n,r,u,c),this.image={width:t,height:i},this.mipmaps=e,// no flipping for cube textures
// (also flipping doesn't work for compressed textures )
this.flipY=!1,// can't generate mipmaps for compressed textures
// mips must be embedded in DDS files
this.generateMipmaps=!1}}).prototype.isCompressedTexture=!0,(class extends B{constructor(e,t,i,n,r,s,a,o,l){super(e,t,i,n,r,s,a,o,l),this.needsUpdate=!0}}).prototype.isCanvasTexture=!0;/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/class rK{constructor(){this.type="Curve",this.arcLengthDivisions=200}// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]
getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}// Get point at relative position in curve according to arc length
// - u [0 .. 1]
getPointAt(e,t){let i=this.getUtoTmapping(e);return this.getPoint(i,t)}// Get sequence of points using getPoint( t )
getPoints(e=5){let t=[];for(let i=0;i<=e;i++)t.push(this.getPoint(i/e));return t}// Get sequence of points using getPointAt( u )
getSpacedPoints(e=5){let t=[];for(let i=0;i<=e;i++)t.push(this.getPointAt(i/e));return t}// Get total curve arc length
getLength(){let e=this.getLengths();return e[e.length-1]}// Get list of cumulative segment lengths
getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;let t=[],i,n=this.getPoint(0),r=0;t.push(0);for(let s=1;s<=e;s++)t.push(r+=(i=this.getPoint(s/e)).distanceTo(n)),n=i;return this.cacheArcLengths=t,t;// { sums: cache, sum: sum }; Sum is in the last element.
}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
getUtoTmapping(e,t){let i;let n=this.getLengths(),r=0,s=n.length;i=t||e*n[s-1];// binary search for the index with largest value smaller than target u distance
let a=0,o=s-1,l;for(;a<=o;)if((l=n[r=Math.floor(a+(o-a)/2)]-i)<0)a=r+1;else if(l>0)o=r-1;else{o=r;break;// DONE
}if(n[r=o]===i)return r/(s-1);// we could get finer grain at lengths, or use simple interpolation between two points
let h=n[r],u=n[r+1],c=(r+(i-h)/(u-h))/(s-1);return c}// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation
getTangent(e,t){let i=e-1e-4,n=e+1e-4;i<0&&(i=0),n>1&&(n=1);let r=this.getPoint(i),s=this.getPoint(n),a=t||(r.isVector2?new b:new q);return a.copy(s).sub(r).normalize(),a}getTangentAt(e,t){let i=this.getUtoTmapping(e);return this.getTangent(i,t)}computeFrenetFrames(e,t){// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
let i=new q,n=[],r=[],s=[],a=new q,o=new ew;// compute the tangent vectors for each segment on the curve
for(let t=0;t<=e;t++){let i=t/e;n[t]=this.getTangentAt(i,new q)}// select an initial normal vector perpendicular to the first tangent vector,
// and in the direction of the minimum tangent xyz component
r[0]=new q,s[0]=new q;let l=Number.MAX_VALUE,h=Math.abs(n[0].x),u=Math.abs(n[0].y),c=Math.abs(n[0].z);h<=l&&(l=h,i.set(1,0,0)),u<=l&&(l=u,i.set(0,1,0)),c<=l&&i.set(0,0,1),a.crossVectors(n[0],i).normalize(),r[0].crossVectors(n[0],a),s[0].crossVectors(n[0],r[0]);// compute the slowly-varying normal and binormal vectors for each segment on the curve
for(let t=1;t<=e;t++){if(r[t]=r[t-1].clone(),s[t]=s[t-1].clone(),a.crossVectors(n[t-1],n[t]),a.length()>Number.EPSILON){a.normalize();let e=Math.acos(m(n[t-1].dot(n[t]),-1,1));// clamp for floating pt errors
r[t].applyMatrix4(o.makeRotationAxis(a,e))}s[t].crossVectors(n[t],r[t])}// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
if(!0===t){let t=Math.acos(m(r[0].dot(r[e]),-1,1));t/=e,n[0].dot(a.crossVectors(r[0],r[e]))>0&&(t=-t);for(let i=1;i<=e;i++)// twist a little...
r[i].applyMatrix4(o.makeRotationAxis(n[i],t*i)),s[i].crossVectors(n[i],r[i])}return{tangents:n,normals:r,binormals:s}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){let e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class rQ extends rK{constructor(e=0,t=0,i=1,n=1,r=0,s=2*Math.PI,a=!1,o=0){super(),this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=i,this.yRadius=n,this.aStartAngle=r,this.aEndAngle=s,this.aClockwise=a,this.aRotation=o}getPoint(e,t){let i=t||new b,n=2*Math.PI,r=this.aEndAngle-this.aStartAngle,s=Math.abs(r)<Number.EPSILON;// ensures that deltaAngle is 0 .. 2 PI
for(;r<0;)r+=n;for(;r>n;)r-=n;r<Number.EPSILON&&(r=s?0:n),!0!==this.aClockwise||s||(r===n?r=-n:r-=n);let a=this.aStartAngle+e*r,o=this.aX+this.xRadius*Math.cos(a),l=this.aY+this.yRadius*Math.sin(a);if(0!==this.aRotation){let e=Math.cos(this.aRotation),t=Math.sin(this.aRotation),i=o-this.aX,n=l-this.aY;// Rotate the point about the center of the ellipse.
o=i*e-n*t+this.aX,l=i*t+n*e+this.aY}return i.set(o,l)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){let e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}rQ.prototype.isEllipseCurve=!0;class r$ extends rQ{constructor(e,t,i,n,r,s){super(e,t,i,i,n,r,s),this.type="ArcCurve"}}/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 *//*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/function r0(){let e=0,t=0,i=0,n=0;/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */function r(r,s,a,o){e=r,t=a,i=-3*r+3*s-2*a-o,n=2*r-2*s+a+o}return{initCatmullRom:function(e,t,i,n,s){r(t,i,s*(i-e),s*(n-t))},initNonuniformCatmullRom:function(e,t,i,n,s,a,o){// compute tangents when parameterized in [t1,t2]
let l=(t-e)/s-(i-e)/(s+a)+(i-t)/a,h=(i-t)/a-(n-t)/(a+o)+(n-i)/o;r(t,i,// rescale tangents for parametrization in [0,1]
l*=a,h*=a)},calc:function(r){let s=r*r;return e+t*r+i*s+n*(s*r)}}}r$.prototype.isArcCurve=!0;//
const r1=new q,r3=new r0,r2=new r0,r4=new r0;class r5 extends rK{constructor(e=[],t=!1,i="centripetal",n=.5){super(),this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=i,this.tension=n}getPoint(e,t=new q){let i,n;let r=this.points,s=r.length,a=(s-(this.closed?0:1))*e,o=Math.floor(a),l=a-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/s)+1)*s:0===l&&o===s-1&&(o=s-2,l=1),this.closed||o>0?i=r[(o-1)%s]:(// extrapolate first point
r1.subVectors(r[0],r[1]).add(r[0]),i=r1);let h=r[o%s],u=r[(o+1)%s];if(this.closed||o+2<s?n=r[(o+2)%s]:(// extrapolate last point
r1.subVectors(r[s-1],r[s-2]).add(r[s-1]),n=r1),"centripetal"===this.curveType||"chordal"===this.curveType){// init Centripetal / Chordal Catmull-Rom
let e="chordal"===this.curveType?.5:.25,t=Math.pow(i.distanceToSquared(h),e),r=Math.pow(h.distanceToSquared(u),e),s=Math.pow(u.distanceToSquared(n),e);r<1e-4&&(r=1),t<1e-4&&(t=r),s<1e-4&&(s=r),r3.initNonuniformCatmullRom(i.x,h.x,u.x,n.x,t,r,s),r2.initNonuniformCatmullRom(i.y,h.y,u.y,n.y,t,r,s),r4.initNonuniformCatmullRom(i.z,h.z,u.z,n.z,t,r,s)}else"catmullrom"===this.curveType&&(r3.initCatmullRom(i.x,h.x,u.x,n.x,this.tension),r2.initCatmullRom(i.y,h.y,u.y,n.y,this.tension),r4.initCatmullRom(i.z,h.z,u.z,n.z,this.tension));return t.set(r3.calc(l),r2.calc(l),r4.calc(l)),t}copy(e){super.copy(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){let i=e.points[t];this.points.push(i.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){let e=super.toJSON();e.points=[];for(let t=0,i=this.points.length;t<i;t++){let i=this.points[t];e.points.push(i.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){let i=e.points[t];this.points.push(new q().fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}/**
 * Bezier Curves formulas obtained from
 * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
 */function r6(e,t,i,n,r){let s=(n-t)*.5,a=(r-i)*.5,o=e*e;return(2*i-2*n+s+a)*(e*o)+(-3*i+3*n-2*s-a)*o+s*e+i}function r8(e,t,i,n){return(//
function(e,t){let i=1-e;return i*i*t}(e,t)+2*(1-e)*e*i+e*e*n)}function r7(e,t,i,n,r){return(//
function(e,t){let i=1-e;return i*i*i*t}(e,t)+function(e,t){let i=1-e;return 3*i*i*e*t}(e,i)+3*(1-e)*e*e*n+e*e*e*r)}r5.prototype.isCatmullRomCurve3=!0;class r9 extends rK{constructor(e=new b,t=new b,i=new b,n=new b){super(),this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=i,this.v3=n}getPoint(e,t=new b){let i=this.v0,n=this.v1,r=this.v2,s=this.v3;return t.set(r7(e,i.x,n.x,r.x,s.x),r7(e,i.y,n.y,r.y,s.y)),t}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){let e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}r9.prototype.isCubicBezierCurve=!0;class se extends rK{constructor(e=new q,t=new q,i=new q,n=new q){super(),this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=i,this.v3=n}getPoint(e,t=new q){let i=this.v0,n=this.v1,r=this.v2,s=this.v3;return t.set(r7(e,i.x,n.x,r.x,s.x),r7(e,i.y,n.y,r.y,s.y),r7(e,i.z,n.z,r.z,s.z)),t}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){let e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}se.prototype.isCubicBezierCurve3=!0;class st extends rK{constructor(e=new b,t=new b){super(),this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new b){return 1===e?t.copy(this.v2):(t.copy(this.v2).sub(this.v1),t.multiplyScalar(e).add(this.v1)),t}// Line curve is linear, so we can overwrite default getPointAt
getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t){let i=t||new b;return i.copy(this.v2).sub(this.v1).normalize(),i}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){let e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}st.prototype.isLineCurve=!0;class si extends rK{constructor(e=new b,t=new b,i=new b){super(),this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=i}getPoint(e,t=new b){let i=this.v0,n=this.v1,r=this.v2;return t.set(r8(e,i.x,n.x,r.x),r8(e,i.y,n.y,r.y)),t}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){let e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}si.prototype.isQuadraticBezierCurve=!0;class sn extends rK{constructor(e=new q,t=new q,i=new q){super(),this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=i}getPoint(e,t=new q){let i=this.v0,n=this.v1,r=this.v2;return t.set(r8(e,i.x,n.x,r.x),r8(e,i.y,n.y,r.y),r8(e,i.z,n.z,r.z)),t}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){let e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}sn.prototype.isQuadraticBezierCurve3=!0;class sr extends rK{constructor(e=[]){super(),this.type="SplineCurve",this.points=e}getPoint(e,t=new b){let i=this.points,n=(i.length-1)*e,r=Math.floor(n),s=n-r,a=i[0===r?r:r-1],o=i[r],l=i[r>i.length-2?i.length-1:r+1],h=i[r>i.length-3?i.length-1:r+2];return t.set(r6(s,a.x,o.x,l.x,h.x),r6(s,a.y,o.y,l.y,h.y)),t}copy(e){super.copy(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){let i=e.points[t];this.points.push(i.clone())}return this}toJSON(){let e=super.toJSON();e.points=[];for(let t=0,i=this.points.length;t<i;t++){let i=this.points[t];e.points.push(i.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){let i=e.points[t];this.points.push(new b().fromArray(i))}return this}}sr.prototype.isSplineCurve=!0;var ss=/*#__PURE__*/Object.freeze({__proto__:null,ArcCurve:r$,CatmullRomCurve3:r5,CubicBezierCurve:r9,CubicBezierCurve3:se,EllipseCurve:rQ,LineCurve:st,LineCurve3:class extends rK{constructor(e=new q,t=new q){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=e,this.v2=t}getPoint(e,t=new q){return 1===e?t.copy(this.v2):(t.copy(this.v2).sub(this.v1),t.multiplyScalar(e).add(this.v1)),t}// Line curve is linear, so we can overwrite default getPointAt
getPointAt(e,t){return this.getPoint(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){let e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}},QuadraticBezierCurve:si,QuadraticBezierCurve3:sn,SplineCurve:sr});/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/class sa extends rK{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){// Add a line curve if start and end of lines are not connected
let e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new st(t,e))}// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:
// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')
getPoint(e,t){let i=e*this.getLength(),n=this.getCurveLengths(),r=0;// To think about boundaries points.
for(;r<n.length;){if(n[r]>=i){let e=n[r]-i,s=this.curves[r],a=s.getLength(),o=0===a?0:1-e/a;return s.getPointAt(o,t)}r++}return null;// loop where sum != 0, sum > d , sum+1 <d
}// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength
getLength(){let e=this.getCurveLengths();return e[e.length-1]}// cacheLengths must be recalculated.
updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.
getCurveLengths(){// We use cache values if curves and cache array are same length
if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;// Get length of sub-curve
// Push sums into cached array
let e=[],t=0;for(let i=0,n=this.curves.length;i<n;i++)e.push(t+=this.curves[i].getLength());return this.cacheLengths=e,e}getSpacedPoints(e=40){let t=[];for(let i=0;i<=e;i++)t.push(this.getPoint(i/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){let t;let i=[];for(let n=0,r=this.curves;n<r.length;n++){let s=r[n],a=s.isEllipseCurve?2*e:s.isLineCurve||s.isLineCurve3?1:s.isSplineCurve?e*s.points.length:e,o=s.getPoints(a);for(let e=0;e<o.length;e++){let n=o[e];t&&t.equals(n)||(i.push(n),t=n);// ensures no consecutive points are duplicates
}}return this.autoClose&&i.length>1&&!i[i.length-1].equals(i[0])&&i.push(i[0]),i}copy(e){super.copy(e),this.curves=[];for(let t=0,i=e.curves.length;t<i;t++){let i=e.curves[t];this.curves.push(i.clone())}return this.autoClose=e.autoClose,this}toJSON(){let e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,i=this.curves.length;t<i;t++){let i=this.curves[t];e.curves.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,i=e.curves.length;t<i;t++){let i=e.curves[t];this.curves.push(new ss[i.type]().fromJSON(i))}return this}}class so extends sa{constructor(e){super(),this.type="Path",this.currentPoint=new b,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,i=e.length;t<i;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){let i=new st(this.currentPoint.clone(),new b(e,t));return this.curves.push(i),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,i,n){let r=new si(this.currentPoint.clone(),new b(e,t),new b(i,n));return this.curves.push(r),this.currentPoint.set(i,n),this}bezierCurveTo(e,t,i,n,r,s){let a=new r9(this.currentPoint.clone(),new b(e,t),new b(i,n),new b(r,s));return this.curves.push(a),this.currentPoint.set(r,s),this}splineThru(e/*Array of Vector*/){let t=[this.currentPoint.clone()].concat(e),i=new sr(t);return this.curves.push(i),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,i,n,r,s){let a=this.currentPoint.x,o=this.currentPoint.y;return this.absarc(e+a,t+o,i,n,r,s),this}absarc(e,t,i,n,r,s){return this.absellipse(e,t,i,i,n,r,s),this}ellipse(e,t,i,n,r,s,a,o){let l=this.currentPoint.x,h=this.currentPoint.y;return this.absellipse(e+l,t+h,i,n,r,s,a,o),this}absellipse(e,t,i,n,r,s,a,o){let l=new rQ(e,t,i,n,r,s,a,o);if(this.curves.length>0){// if a previous curve is present, attempt to join
let e=l.getPoint(0);e.equals(this.currentPoint)||this.lineTo(e.x,e.y)}this.curves.push(l);let h=l.getPoint(1);return this.currentPoint.copy(h),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){let e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class sl extends td{constructor(e=[new b(0,.5),new b(.5,0),new b(0,-.5)],t=12,i=0,n=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:i,phiLength:n},t=Math.floor(t),// clamp phiLength so it's in range of [ 0, 2PI ]
n=m(n,0,2*Math.PI);// buffers
let r=[],s=[],a=[],o=[],l=[],h=1/t,u=new q,c=new b,d=new q,p=new q,f=new q,g=0,v=0;// pre-compute normals for initial "meridian"
for(let t=0;t<=e.length-1;t++)switch(t){case 0:g=e[t+1].x-e[t].x,v=e[t+1].y-e[t].y,d.x=1*v,d.y=-g,d.z=0*v,f.copy(d),d.normalize(),o.push(d.x,d.y,d.z);break;case e.length-1:o.push(f.x,f.y,f.z);break;default:g=e[t+1].x-e[t].x,v=e[t+1].y-e[t].y,d.x=1*v,d.y=-g,d.z=0*v,p.copy(d),d.x+=f.x,d.y+=f.y,d.z+=f.z,d.normalize(),o.push(d.x,d.y,d.z),f.copy(p)}// generate vertices, uvs and normals
for(let r=0;r<=t;r++){let d=i+r*h*n,p=Math.sin(d),m=Math.cos(d);for(let i=0;i<=e.length-1;i++){// vertex
u.x=e[i].x*p,u.y=e[i].y,u.z=e[i].x*m,s.push(u.x,u.y,u.z),// uv
c.x=r/t,c.y=i/(e.length-1),a.push(c.x,c.y);// normal
let n=o[3*i+0]*p,h=o[3*i+1],d=o[3*i+0]*m;l.push(n,h,d)}}// indices
for(let i=0;i<t;i++)for(let t=0;t<e.length-1;t++){let n=t+i*e.length,s=n+e.length,a=n+e.length+1,o=n+1;// faces
r.push(n,s,o),r.push(a,o,s)}// build geometry
this.setIndex(r),this.setAttribute("position",new tr(s,3)),this.setAttribute("uv",new tr(a,2)),this.setAttribute("normal",new tr(l,3))}static fromJSON(e){return new sl(e.points,e.segments,e.phiStart,e.phiLength)}}class sh extends sl{constructor(e=1,t=1,i=4,n=8){let r=new so;r.absarc(0,-t/2,e,1.5*Math.PI,0),r.absarc(0,t/2,e,0,.5*Math.PI),super(r.getPoints(i),n),this.type="CapsuleGeometry",this.parameters={radius:e,height:t,capSegments:i,radialSegments:n}}static fromJSON(e){return new sh(e.radius,e.length,e.capSegments,e.radialSegments)}}class su extends td{constructor(e=1,t=8,i=0,n=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:i,thetaLength:n},t=Math.max(3,t);// buffers
let r=[],s=[],a=[],o=[],l=new q,h=new b;// center point
s.push(0,0,0),a.push(0,0,1),o.push(.5,.5);for(let r=0,u=3;r<=t;r++,u+=3){let c=i+r/t*n;// vertex
l.x=e*Math.cos(c),l.y=e*Math.sin(c),s.push(l.x,l.y,l.z),// normal
a.push(0,0,1),// uvs
h.x=(s[u]/e+1)/2,h.y=(s[u+1]/e+1)/2,o.push(h.x,h.y)}// indices
for(let e=1;e<=t;e++)r.push(e,e+1,0);// build geometry
this.setIndex(r),this.setAttribute("position",new tr(s,3)),this.setAttribute("normal",new tr(a,3)),this.setAttribute("uv",new tr(o,2))}static fromJSON(e){return new su(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class sc extends td{constructor(e=1,t=1,i=1,n=8,r=1,s=!1,a=0,o=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:i,radialSegments:n,heightSegments:r,openEnded:s,thetaStart:a,thetaLength:o};let l=this;n=Math.floor(n),r=Math.floor(r);// buffers
let h=[],u=[],c=[],d=[],p=0,m=[],f=i/2,g=0;function v(i){// save the index of the first center vertex
let r=p,s=new b,m=new q,v=0,x=!0===i?e:t,y=!0===i?1:-1;// first we generate the center vertex data of the cap.
// because the geometry needs one set of uvs per face,
// we must generate a center vertex per face/segment
for(let e=1;e<=n;e++)// vertex
u.push(0,f*y,0),// normal
c.push(0,y,0),// uv
d.push(.5,.5),// increase index
p++;// save the index of the last center vertex
let _=p;// now we generate the surrounding vertices, normals and uvs
for(let e=0;e<=n;e++){let t=e/n,i=t*o+a,r=Math.cos(i),l=Math.sin(i);// vertex
m.x=x*l,m.y=f*y,m.z=x*r,u.push(m.x,m.y,m.z),// normal
c.push(0,y,0),// uv
s.x=.5*r+.5,s.y=.5*l*y+.5,d.push(s.x,s.y),// increase index
p++}// generate indices
for(let e=0;e<n;e++){let t=r+e,n=_+e;!0===i?h.push(n,n+1,t):h.push(n+1,n,t),v+=3}// add a group to the geometry. this will ensure multi material support
l.addGroup(g,v,!0===i?1:2),// calculate new start value for groups
g+=v}// generate geometry
(function(){let s=new q,v=new q,x=0,y=(t-e)/i;// generate vertices, normals and uvs
for(let l=0;l<=r;l++){let h=[],g=l/r,x=g*(t-e)+e;for(let e=0;e<=n;e++){let t=e/n,r=t*o+a,l=Math.sin(r),m=Math.cos(r);// vertex
v.x=x*l,v.y=-g*i+f,v.z=x*m,u.push(v.x,v.y,v.z),// normal
s.set(l,y,m).normalize(),c.push(s.x,s.y,s.z),// uv
d.push(t,1-g),// save index of vertex in respective row
h.push(p++)}// now save vertices of the row in our index array
m.push(h)}// generate indices
for(let e=0;e<n;e++)for(let t=0;t<r;t++){// we use the index array to access the correct indices
let i=m[t][e],n=m[t+1][e],r=m[t+1][e+1],s=m[t][e+1];// faces
h.push(i,n,s),h.push(n,r,s),// update group counter
x+=6}// add a group to the geometry. this will ensure multi material support
l.addGroup(g,x,0),// calculate new start value for groups
g+=x})(),!1===s&&(e>0&&v(!0),t>0&&v(!1)),// build geometry
this.setIndex(h),this.setAttribute("position",new tr(u,3)),this.setAttribute("normal",new tr(c,3)),this.setAttribute("uv",new tr(d,2))}static fromJSON(e){return new sc(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class sd extends sc{constructor(e=1,t=1,i=8,n=1,r=!1,s=0,a=2*Math.PI){super(0,e,t,i,n,r,s,a),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:i,heightSegments:n,openEnded:r,thetaStart:s,thetaLength:a}}static fromJSON(e){return new sd(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class sp extends td{constructor(e=[],t=[],i=1,n=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:i,detail:n};// default buffer data
let r=[],s=[];function a(e){r.push(e.x,e.y,e.z)}function o(t,i){let n=3*t;i.x=e[n+0],i.y=e[n+1],i.z=e[n+2]}function l(e,t,i,n){n<0&&1===e.x&&(s[t]=e.x-1),0===i.x&&0===i.z&&(s[t]=n/2/Math.PI+.5)}// Angle around the Y axis, counter-clockwise when looking from above.
function h(e){return Math.atan2(e.z,-e.x)}// the subdivision creates the vertex buffer data
// helper functions
(function(e){let i=new q,n=new q,r=new q;// iterate over all faces and apply a subdivison with the given detail value
for(let s=0;s<t.length;s+=3)// get the vertices of the face
o(t[s+0],i),o(t[s+1],n),o(t[s+2],r),// perform subdivision
function(e,t,i,n){let r=n+1,s=[];// construct all of the vertices for this subdivision
for(let n=0;n<=r;n++){s[n]=[];let a=e.clone().lerp(i,n/r),o=t.clone().lerp(i,n/r),l=r-n;for(let e=0;e<=l;e++)0===e&&n===r?s[n][e]=a:s[n][e]=a.clone().lerp(o,e/l)}// construct all of the faces
for(let e=0;e<r;e++)for(let t=0;t<2*(r-e)-1;t++){let i=Math.floor(t/2);t%2==0?(a(s[e][i+1]),a(s[e+1][i]),a(s[e][i])):(a(s[e][i+1]),a(s[e+1][i+1]),a(s[e+1][i]))}}(i,n,r,e)})(n),// all vertices should lie on a conceptual sphere with a given radius
function(e){let t=new q;// iterate over the entire buffer and apply the radius to each vertex
for(let i=0;i<r.length;i+=3)t.x=r[i+0],t.y=r[i+1],t.z=r[i+2],t.normalize().multiplyScalar(e),r[i+0]=t.x,r[i+1]=t.y,r[i+2]=t.z}(i),// finally, create the uv data
function(){let e=new q;for(let t=0;t<r.length;t+=3){e.x=r[t+0],e.y=r[t+1],e.z=r[t+2];let i=h(e)/2/Math.PI+.5,n=Math.atan2(-e.y,Math.sqrt(e.x*e.x+e.z*e.z))/Math.PI+.5;s.push(i,1-n)}(function(){let e=new q,t=new q,i=new q,n=new q,a=new b,o=new b,u=new b;for(let c=0,d=0;c<r.length;c+=9,d+=6){e.set(r[c+0],r[c+1],r[c+2]),t.set(r[c+3],r[c+4],r[c+5]),i.set(r[c+6],r[c+7],r[c+8]),a.set(s[d+0],s[d+1]),o.set(s[d+2],s[d+3]),u.set(s[d+4],s[d+5]),n.copy(e).add(t).add(i).divideScalar(3);let p=h(n);l(a,d+0,e,p),l(o,d+2,t,p),l(u,d+4,i,p)}})(),function(){// handle case when face straddles the seam, see #3269
for(let e=0;e<s.length;e+=6){// uv data of a single face
let t=s[e+0],i=s[e+2],n=s[e+4],r=Math.max(t,i,n),a=Math.min(t,i,n);// 0.9 is somewhat arbitrary
r>.9&&a<.1&&(t<.2&&(s[e+0]+=1),i<.2&&(s[e+2]+=1),n<.2&&(s[e+4]+=1))}}()}(),// build non-indexed geometry
this.setAttribute("position",new tr(r,3)),this.setAttribute("normal",new tr(r.slice(),3)),this.setAttribute("uv",new tr(s,2)),0===n?this.computeVertexNormals():this.normalizeNormals()}static fromJSON(e){return new sp(e.vertices,e.indices,e.radius,e.details)}}class sm extends sp{constructor(e=1,t=0){let i=(1+Math.sqrt(5))/2,n=1/i,r=[// (1, 1, 1)
-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,// (0, 1/, )
0,-n,-i,0,-n,i,0,n,-i,0,n,i,// (1/, , 0)
-n,-i,0,-n,i,0,n,-i,0,n,i,0,// (, 0, 1/)
-i,0,-n,i,0,-n,-i,0,n,i,0,n];super(r,[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new sm(e.radius,e.detail)}}new q,new q,new q,new e5;class sf extends so{constructor(e){super(e),this.uuid=p(),this.type="Shape",this.holes=[]}getPointsHoles(e){let t=[];for(let i=0,n=this.holes.length;i<n;i++)t[i]=this.holes[i].getPoints(e);return t}// get points of shape and holes (keypoints based on segments parameter)
extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,i=e.holes.length;t<i;t++){let i=e.holes[t];this.holes.push(i.clone())}return this}toJSON(){let e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,i=this.holes.length;t<i;t++){let i=this.holes[t];e.holes.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,i=e.holes.length;t<i;t++){let i=e.holes[t];this.holes.push(new so().fromJSON(i))}return this}}/**
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */const sg={triangulate:function(e,t,i=2){let n,r,s,a,o,l,h;let u=t&&t.length,c=u?t[0]*i:e.length,d=sv(e,0,c,i,!0),p=[];if(!d||d.next===d.prev)return p;// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
if(u&&(d=// link every hole into the outer loop, producing a single-ring polygon without holes
function(e,t,i,n){let r,s,a,o,l;let h=[];for(r=0,s=t.length;r<s;r++)a=t[r]*n,o=r<s-1?t[r+1]*n:e.length,(l=sv(e,a,o,n,!1))===l.next&&(l.steiner=!0),h.push(// find the leftmost node of a polygon ring
function(e){let t=e,i=e;do(t.x<i.x||t.x===i.x&&t.y<i.y)&&(i=t),t=t.next;while(t!==e)return i}(l));// process holes from left to right
for(h.sort(sy),r=0;r<h.length;r++)// find a bridge between vertices that connects hole with an outer ring and link it
(function(e,t){if(t=// David Eberly's algorithm for finding a bridge between hole and outer polygon
function(e,t){let i=t,n=e.x,r=e.y,s=-1/0,a;// find a segment intersected by a ray from the hole's leftmost point to the left;
// segment's endpoint with lesser x will be potential connection point
do{if(r<=i.y&&r>=i.next.y&&i.next.y!==i.y){let e=i.x+(r-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(e<=n&&e>s){if(s=e,e===n){if(r===i.y)return i;if(r===i.next.y)return i.next}a=i.x<i.next.x?i:i.next}}i=i.next}while(i!==t)if(!a)return null;if(n===s)return a;// hole touches outer segment; pick leftmost endpoint
// look for points inside the triangle of hole point, segment intersection and endpoint;
// if there are no points found, we have a valid connection;
// otherwise choose the point of the minimum angle with the ray as connection point
let o=a,l=a.x,h=a.y,u=1/0,c;i=a;do{var d,p;n>=i.x&&i.x>=l&&n!==i.x&&sb(r<h?n:s,r,l,h,r<h?s:n,r,i.x,i.y)&&(c=Math.abs(r-i.y)/(n-i.x),sA(i,e)&&(c<u||c===u&&(i.x>a.x||i.x===a.x&&(d=a,p=i,0>sM(d.prev,d,p.prev)&&0>sM(p.next,d,d.next))))&&(a=i,u=c)),i=i.next}while(i!==o)return a}(e,t)){let i=sR(t,e);// filter collinear points around the cuts
sx(t,t.next),sx(i,i.next)}})(h[r],i),i=sx(i,i.next);return i}(e,t,d,i)),e.length>80*i){n=s=e[0],r=a=e[1];for(let t=i;t<c;t+=i)o=e[t],l=e[t+1],o<n&&(n=o),l<r&&(r=l),o>s&&(s=o),l>a&&(a=l);h=0!==// minX, minY and invSize are later used to transform coords into integers for z-order calculation
(h=Math.max(s-n,a-r))?1/h:0}return(// main ear slicing loop which triangulates a polygon (given as a linked list)
function e(t,i,n,r,s,a,o){if(!t)return;// interlink polygon nodes in z-order
!o&&a&&// interlink polygon nodes in z-order
function(e,t,i,n){let r=e;do null===r.z&&(r.z=s_(r.x,r.y,t,i,n)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next;while(r!==e)r.prevZ.nextZ=null,r.prevZ=null,// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function(e){let t,i,n,r,s,a,o,l,h=1;do{for(i=e,e=null,s=null,a=0;i;){for(a++,n=i,o=0,t=0;t<h&&(o++,n=n.nextZ);t++);for(l=h;o>0||l>0&&n;)0!==o&&(0===l||!n||i.z<=n.z)?(r=i,i=i.nextZ,o--):(r=n,n=n.nextZ,l--),s?s.nextZ=r:e=r,r.prevZ=s,s=r;i=n}s.nextZ=null,h*=2}while(a>1)}(r)}(t,r,s,a);let l=t,h,u;// iterate through ears, slicing them one by one
for(;t.prev!==t.next;){if(h=t.prev,u=t.next,a?function(e,t,i,n){let r=e.prev,s=e.next;if(sM(r,e,s)>=0)return!1;// reflex, can't be an ear
// triangle bbox; min & max are calculated like this for speed
let a=r.x<e.x?r.x<s.x?r.x:s.x:e.x<s.x?e.x:s.x,o=r.y<e.y?r.y<s.y?r.y:s.y:e.y<s.y?e.y:s.y,l=r.x>e.x?r.x>s.x?r.x:s.x:e.x>s.x?e.x:s.x,h=r.y>e.y?r.y>s.y?r.y:s.y:e.y>s.y?e.y:s.y,u=s_(a,o,t,i,n),c=s_(l,h,t,i,n),d=e.prevZ,p=e.nextZ;// look for points inside the triangle in both directions
for(;d&&d.z>=u&&p&&p.z<=c;){if(d!==e.prev&&d!==e.next&&sb(r.x,r.y,e.x,e.y,s.x,s.y,d.x,d.y)&&sM(d.prev,d,d.next)>=0||(d=d.prevZ,p!==e.prev&&p!==e.next&&sb(r.x,r.y,e.x,e.y,s.x,s.y,p.x,p.y)&&sM(p.prev,p,p.next)>=0))return!1;p=p.nextZ}// look for remaining points in decreasing z-order
for(;d&&d.z>=u;){if(d!==e.prev&&d!==e.next&&sb(r.x,r.y,e.x,e.y,s.x,s.y,d.x,d.y)&&sM(d.prev,d,d.next)>=0)return!1;d=d.prevZ}// look for remaining points in increasing z-order
for(;p&&p.z<=c;){if(p!==e.prev&&p!==e.next&&sb(r.x,r.y,e.x,e.y,s.x,s.y,p.x,p.y)&&sM(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}(t,r,s,a):// check whether a polygon node forms a valid ear with adjacent nodes
function(e){let t=e.prev,i=e.next;if(sM(t,e,i)>=0)return!1;// reflex, can't be an ear
// now make sure we don't have other points inside the potential ear
let n=e.next.next;for(;n!==e.prev;){if(sb(t.x,t.y,e.x,e.y,i.x,i.y,n.x,n.y)&&sM(n.prev,n,n.next)>=0)return!1;n=n.next}return!0}(t)){// cut off the triangle
i.push(h.i/n),i.push(t.i/n),i.push(u.i/n),sC(t),// skipping the next vertex leads to less sliver triangles
t=u.next,l=u.next;continue}// if we looped through the whole remaining polygon and can't find any more ears
if((t=u)===l){// try filtering points and slicing again
o?1===o?e(t=// go through all polygon nodes and cure small local self-intersections
function(e,t,i){let n=e;do{let r=n.prev,s=n.next.next;!sw(r,s)&&sS(r,n,n.next,s)&&sA(r,s)&&sA(s,r)&&(t.push(r.i/i),t.push(n.i/i),t.push(s.i/i),// remove two nodes involved
sC(n),sC(n.next),n=e=s),n=n.next}while(n!==e)return sx(n)}(sx(t),i,n),i,n,r,s,a,2):2===o&&// try splitting polygon into two and triangulate them independently
function(t,i,n,r,s,a){// look for a valid diagonal that divides the polygon into two
let o=t;do{let t=o.next.next;for(;t!==o.prev;){var l,h;if(o.i!==t.i&&(l=o,h=t,l.next.i!==h.i&&l.prev.i!==h.i&&!// check if a polygon diagonal intersects any polygon segments
function(e,t){let i=e;do{if(i.i!==e.i&&i.next.i!==e.i&&i.i!==t.i&&i.next.i!==t.i&&sS(i,i.next,e,t))return!0;i=i.next}while(i!==e)return!1}(l,h)&&// doesn't intersect other edges
(sA(l,h)&&sA(h,l)&&// check if the middle point of a polygon diagonal is inside the polygon
function(e,t){let i=e,n=!1,r=(e.x+t.x)/2,s=(e.y+t.y)/2;do i.y>s!=i.next.y>s&&i.next.y!==i.y&&r<(i.next.x-i.x)*(s-i.y)/(i.next.y-i.y)+i.x&&(n=!n),i=i.next;while(i!==e)return n}(l,h)&&// locally visible
(sM(l.prev,l,h.prev)||sM(l,h.prev,h))||// does not create opposite-facing sectors
sw(l,h)&&sM(l.prev,l,l.next)>0&&sM(h.prev,h,h.next)>0))){// split the polygon in two by the diagonal
let l=sR(o,t);// filter colinear points around the cuts
o=sx(o,o.next),l=sx(l,l.next),// run earcut on each half
e(o,i,n,r,s,a),e(l,i,n,r,s,a);return}t=t.next}o=o.next}while(o!==t)}(t,i,n,r,s,a):e(sx(t),i,n,r,s,a,1);break}}}(d,p,i,n,r,h),p)}};// create a circular doubly linked list from polygon points in the specified winding order
function sv(e,t,i,n,r){let s,a;if(r===function(e,t,i,n){let r=0;for(let s=t,a=i-n;s<i;s+=n)r+=(e[a]-e[s])*(e[s+1]+e[a+1]),a=s;return r}(e,t,i,n)>0)for(s=t;s<i;s+=n)a=sL(s,e[s],e[s+1],a);else for(s=i-n;s>=t;s-=n)a=sL(s,e[s],e[s+1],a);return a&&sw(a,a.next)&&(sC(a),a=a.next),a}// eliminate colinear or duplicate points
function sx(e,t){if(!e)return e;t||(t=e);let i=e,n;do if(n=!1,!i.steiner&&(sw(i,i.next)||0===sM(i.prev,i,i.next))){if(sC(i),(i=t=i.prev)===i.next)break;n=!0}else i=i.next;while(n||i!==t)return t}function sy(e,t){return e.x-t.x}// z-order of a point given coords and inverse of the longer side of data bbox
function s_(e,t,i,n,r){return(e=((e=((e=((e=(// coords are transformed into non-negative 15-bit integer range
(e=32767*(e-i)*r)|e<<8)&16711935)|e<<4)&252645135)|e<<2)&858993459)|e<<1)&1431655765)|(t=((t=((t=((t=((t=32767*(t-n)*r)|t<<8)&16711935)|t<<4)&252645135)|t<<2)&858993459)|t<<1)&1431655765)<<1}// check if a point lies within a convex triangle
function sb(e,t,i,n,r,s,a,o){return(r-a)*(t-o)-(e-a)*(s-o)>=0&&(e-a)*(n-o)-(i-a)*(t-o)>=0&&(i-a)*(s-o)-(r-a)*(n-o)>=0}// signed area of a triangle
function sM(e,t,i){return(t.y-e.y)*(i.x-t.x)-(t.x-e.x)*(i.y-t.y)}// check if two points are equal
function sw(e,t){return e.x===t.x&&e.y===t.y}// check if two segments intersect
function sS(e,t,i,n){let r=sE(sM(e,t,i)),s=sE(sM(e,t,n)),a=sE(sM(i,n,e)),o=sE(sM(i,n,t));return!!(r!==s&&a!==o||0===r&&sT(e,i,t)||0===s&&sT(e,n,t)||0===a&&sT(i,e,n)||0===o&&sT(i,t,n))}// for collinear points p, q, r, check if point q lies on segment pr
function sT(e,t,i){return t.x<=Math.max(e.x,i.x)&&t.x>=Math.min(e.x,i.x)&&t.y<=Math.max(e.y,i.y)&&t.y>=Math.min(e.y,i.y)}function sE(e){return e>0?1:e<0?-1:0}// check if a polygon diagonal is locally inside the polygon
function sA(e,t){return 0>sM(e.prev,e,e.next)?sM(e,t,e.next)>=0&&sM(e,e.prev,t)>=0:0>sM(e,t,e.prev)||0>sM(e,e.next,t)}// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function sR(e,t){let i=new sP(e.i,e.x,e.y),n=new sP(t.i,t.x,t.y),r=e.next,s=t.prev;return e.next=t,t.prev=e,i.next=r,r.prev=i,n.next=i,i.prev=n,s.next=n,n.prev=s,n}// create a node and optionally link it with previous one (in a circular doubly linked list)
function sL(e,t,i,n){let r=new sP(e,t,i);return n?(r.next=n.next,r.prev=n,n.next.prev=r,n.next=r):(r.prev=r,r.next=r),r}function sC(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function sP(e,t,i){// vertex index in coordinates array
this.i=e,// vertex coordinates
this.x=t,this.y=i,// previous and next vertex nodes in a polygon ring
this.prev=null,this.next=null,// z-order curve value
this.z=null,// previous and next nodes in z-order
this.prevZ=null,this.nextZ=null,// indicates whether this is a steiner point
this.steiner=!1}class sI{// calculate area of the contour polygon
static area(e){let t=e.length,i=0;for(let n=t-1,r=0;r<t;n=r++)i+=e[n].x*e[r].y-e[r].x*e[n].y;return .5*i}static isClockWise(e){return 0>sI.area(e)}static triangulateShape(e,t){let i=[],n=[],r=[];// flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
sD(e),sN(i,e);//
let s=e.length;t.forEach(sD);for(let e=0;e<t.length;e++)n.push(s),s+=t[e].length,sN(i,t[e]);//
let a=sg.triangulate(i,n);//
for(let e=0;e<a.length;e+=3)r.push(a.slice(e,e+3));return r}}function sD(e){let t=e.length;t>2&&e[t-1].equals(e[0])&&e.pop()}function sN(e,t){for(let i=0;i<t.length;i++)e.push(t[i].x),e.push(t[i].y)}/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */class sO extends td{constructor(e=new sf([new b(.5,.5),new b(-.5,.5),new b(-.5,-.5),new b(.5,-.5)]),t={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];let i=this,n=[],r=[];for(let s=0,a=e.length;s<a;s++){let a=e[s];!// functions
function(e){let s,a,o,l;let h=[],u=void 0!==t.curveSegments?t.curveSegments:12,c=void 0!==t.steps?t.steps:1,d=void 0!==t.depth?t.depth:1,p=void 0===t.bevelEnabled||t.bevelEnabled,m=void 0!==t.bevelThickness?t.bevelThickness:.2,f=void 0!==t.bevelSize?t.bevelSize:m-.1,g=void 0!==t.bevelOffset?t.bevelOffset:0,v=void 0!==t.bevelSegments?t.bevelSegments:3,x=t.extrudePath,y=void 0!==t.UVGenerator?t.UVGenerator:sz;void 0!==t.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),d=t.amount);//
let _,M=!1;x&&(_=x.getSpacedPoints(c),M=!0,p=!1,// SETUP TNB variables
// TODO1 - have a .isClosed in spline?
s=x.computeFrenetFrames(c,!1),// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
a=new q,o=new q,l=new q),p||(v=0,m=0,f=0,g=0);// Variables initialization
let w=e.extractPoints(u),S=w.shape,T=w.holes,E=!sI.isClockWise(S);if(E){S=S.reverse();// Maybe we should also check if holes are in the opposite direction, just to be safe ...
for(let e=0,t=T.length;e<t;e++){let t=T[e];sI.isClockWise(t)&&(T[e]=t.reverse())}}let A=sI.triangulateShape(S,T),R=S;for(let e=0,t=T.length;e<t;e++){let t=T[e];S=S.concat(t)}function L(e,t,i){return t||console.error("THREE.ExtrudeGeometry: vec does not exist"),t.clone().multiplyScalar(i).add(e)}let C=S.length,P=A.length;// Find directions for point movement
function I(e,t,i){let n,r,s;// good reading for geometry algorithms (here: line-line intersection)
// http://geomalgorithms.com/a05-_intersect-1.html
let a=e.x-t.x,o=e.y-t.y,l=i.x-e.x,h=i.y-e.y,u=a*a+o*o,c=a*h-o*l;if(Math.abs(c)>Number.EPSILON){// not collinear
// length of vectors for normalizing
let c=Math.sqrt(u),d=Math.sqrt(l*l+h*h),p=t.x-o/c,m=t.y+a/c,f=i.x-h/d,g=i.y+l/d,v=((f-p)*h-(g-m)*l)/(a*h-o*l);// vector from inPt to intersection point
n=p+a*v-e.x,r=m+o*v-e.y;// Don't normalize!, otherwise sharp corners become ugly
//  but prevent crazy spikes
let x=n*n+r*r;if(x<=2)return new b(n,r);s=Math.sqrt(x/2)}else{// handle special case of collinear edges
let e=!1;// assumes: opposite
a>Number.EPSILON?l>Number.EPSILON&&(e=!0):a<-Number.EPSILON?l<-Number.EPSILON&&(e=!0):Math.sign(o)===Math.sign(h)&&(e=!0),e?(// console.log("Warning: lines are a straight sequence");
n=-o,r=a,s=Math.sqrt(u)):(// console.log("Warning: lines are a straight spike");
n=a,r=o,s=Math.sqrt(u/2))}return new b(n/s,r/s)}let D=[];for(let e=0,t=R.length,i=t-1,n=e+1;e<t;e++,i++,n++)i===t&&(i=0),n===t&&(n=0),//  (j)---(i)---(k)
// console.log('i,j,k', i, j , k)
D[e]=I(R[e],R[i],R[n]);let N=[],O,z=D.concat();for(let e=0,t=T.length;e<t;e++){let t=T[e];O=[];for(let e=0,i=t.length,n=i-1,r=e+1;e<i;e++,n++,r++)n===i&&(n=0),r===i&&(r=0),//  (j)---(i)---(k)
O[e]=I(t[e],t[n],t[r]);N.push(O),z=z.concat(O)}// Loop bevelSegments, 1 for the front, 1 for the back
for(let e=0;e<v;e++){//for ( b = bevelSegments; b > 0; b -- ) {
let t=e/v,i=m*Math.cos(t*Math.PI/2),n=f*Math.sin(t*Math.PI/2)+g;// contract shape
for(let e=0,t=R.length;e<t;e++){let t=L(R[e],D[e],n);F(t.x,t.y,-i)}// expand holes
for(let e=0,t=T.length;e<t;e++){let t=T[e];O=N[e];for(let e=0,r=t.length;e<r;e++){let r=L(t[e],O[e],n);F(r.x,r.y,-i)}}}let U=f+g;// Back facing vertices
for(let e=0;e<C;e++){let t=p?L(S[e],z[e],U):S[e];M?(// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
o.copy(s.normals[0]).multiplyScalar(t.x),a.copy(s.binormals[0]).multiplyScalar(t.y),l.copy(_[0]).add(o).add(a),F(l.x,l.y,l.z)):F(t.x,t.y,0)}// Add stepped vertices...
// Including front facing vertices
for(let e=1;e<=c;e++)for(let t=0;t<C;t++){let i=p?L(S[t],z[t],U):S[t];M?(// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
o.copy(s.normals[e]).multiplyScalar(i.x),a.copy(s.binormals[e]).multiplyScalar(i.y),l.copy(_[e]).add(o).add(a),F(l.x,l.y,l.z)):F(i.x,i.y,d/c*e)}// Add bevel segments planes
//for ( b = 1; b <= bevelSegments; b ++ ) {
for(let e=v-1;e>=0;e--){let t=e/v,i=m*Math.cos(t*Math.PI/2),n=f*Math.sin(t*Math.PI/2)+g;// contract shape
for(let e=0,t=R.length;e<t;e++){let t=L(R[e],D[e],n);F(t.x,t.y,d+i)}// expand holes
for(let e=0,t=T.length;e<t;e++){let t=T[e];O=N[e];for(let e=0,r=t.length;e<r;e++){let r=L(t[e],O[e],n);M?F(r.x,r.y+_[c-1].y,_[c-1].x+i):F(r.x,r.y,d+i)}}}function H(e,t){let r=e.length;for(;--r>=0;){let s=r,a=r-1;a<0&&(a=e.length-1);//console.log('b', i,j, i-1, k,vertices.length);
for(let e=0,r=c+2*v;e<r;e++){let r=C*e,o=C*(e+1),l=t+s+r,h=t+a+r,u=t+a+o,c=t+s+o;!function(e,t,r,s){G(e),G(t),G(s),G(t),G(r),G(s);let a=n.length/3,o=y.generateSideWallUV(i,n,a-6,a-3,a-2,a-1);k(o[0]),k(o[1]),k(o[3]),k(o[1]),k(o[2]),k(o[3])}(l,h,u,c)}}}function F(e,t,i){h.push(e),h.push(t),h.push(i)}function B(e,t,r){G(e),G(t),G(r);let s=n.length/3,a=y.generateTopUV(i,n,s-3,s-2,s-1);k(a[0]),k(a[1]),k(a[2])}function G(e){n.push(h[3*e+0]),n.push(h[3*e+1]),n.push(h[3*e+2])}function k(e){r.push(e.x),r.push(e.y)}/* Faces */// Top and bottom faces
/////  Internal functions
(function(){let e=n.length/3;if(p){let e=0*C;// steps + 1
// Bottom faces
for(let t=0;t<P;t++){let i=A[t];B(i[2]+e,i[1]+e,i[0]+e)}e=C*(c+2*v);// Top faces
for(let t=0;t<P;t++){let i=A[t];B(i[0]+e,i[1]+e,i[2]+e)}}else{// Bottom faces
for(let e=0;e<P;e++){let t=A[e];B(t[2],t[1],t[0])}// Top faces
for(let e=0;e<P;e++){let t=A[e];B(t[0]+C*c,t[1]+C*c,t[2]+C*c)}}i.addGroup(e,n.length/3-e,0)})(),// Sides faces
// Create faces for the z-sides of the shape
function(){let e=n.length/3,t=0;H(R,0),t+=R.length;for(let e=0,i=T.length;e<i;e++){let i=T[e];H(i,t),//, true
t+=i.length}i.addGroup(e,n.length/3-e,1)}()}(a)}// build geometry
this.setAttribute("position",new tr(n,3)),this.setAttribute("uv",new tr(r,2)),this.computeVertexNormals()}toJSON(){let e=super.toJSON(),t=this.parameters.shapes,i=this.parameters.options;return function(e,t,i){if(i.shapes=[],Array.isArray(e))for(let t=0,n=e.length;t<n;t++){let n=e[t];i.shapes.push(n.uuid)}else i.shapes.push(e.uuid);return void 0!==t.extrudePath&&(i.options.extrudePath=t.extrudePath.toJSON()),i}(t,i,e)}static fromJSON(e,t){let i=[];for(let n=0,r=e.shapes.length;n<r;n++){let r=t[e.shapes[n]];i.push(r)}let n=e.options.extrudePath;return void 0!==n&&(e.options.extrudePath=new ss[n.type]().fromJSON(n)),new sO(i,e.options)}}const sz={generateTopUV:function(e,t,i,n,r){let s=t[3*i],a=t[3*i+1],o=t[3*n],l=t[3*n+1],h=t[3*r],u=t[3*r+1];return[new b(s,a),new b(o,l),new b(h,u)]},generateSideWallUV:function(e,t,i,n,r,s){let a=t[3*i],o=t[3*i+1],l=t[3*i+2],h=t[3*n],u=t[3*n+1],c=t[3*n+2],d=t[3*r],p=t[3*r+1],m=t[3*r+2],f=t[3*s],g=t[3*s+1],v=t[3*s+2];return Math.abs(o-u)<Math.abs(a-h)?[new b(a,1-l),new b(h,1-c),new b(d,1-m),new b(f,1-v)]:[new b(o,1-l),new b(u,1-c),new b(p,1-m),new b(g,1-v)]}};class sU extends sp{constructor(e=1,t=0){let i=(1+Math.sqrt(5))/2,n=[-1,i,0,1,i,0,-1,-i,0,1,-i,0,0,-1,i,0,1,i,0,-1,-i,0,1,-i,i,0,-1,i,0,1,-i,0,-1,-i,0,1];super(n,[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new sU(e.radius,e.detail)}}class sH extends sp{constructor(e=1,t=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new sH(e.radius,e.detail)}}class sF extends td{constructor(e=.5,t=1,i=8,n=1,r=0,s=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:i,phiSegments:n,thetaStart:r,thetaLength:s},i=Math.max(3,i),n=Math.max(1,n);// buffers
let a=[],o=[],l=[],h=[],u=e,c=(t-e)/n,d=new q,p=new b;// generate vertices, normals and uvs
for(let e=0;e<=n;e++){for(let e=0;e<=i;e++){// values are generate from the inside of the ring to the outside
let n=r+e/i*s;// vertex
d.x=u*Math.cos(n),d.y=u*Math.sin(n),o.push(d.x,d.y,d.z),// normal
l.push(0,0,1),// uv
p.x=(d.x/t+1)/2,p.y=(d.y/t+1)/2,h.push(p.x,p.y)}// increase the radius for next row of vertices
u+=c}// indices
for(let e=0;e<n;e++){let t=e*(i+1);for(let e=0;e<i;e++){let n=e+t,r=n+i+1,s=n+i+2,o=n+1;// faces
a.push(n,r,o),a.push(r,s,o)}}// build geometry
this.setIndex(a),this.setAttribute("position",new tr(o,3)),this.setAttribute("normal",new tr(l,3)),this.setAttribute("uv",new tr(h,2))}static fromJSON(e){return new sF(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class sB extends td{constructor(e=new sf([new b(0,.5),new b(-.5,-.5),new b(.5,-.5)]),t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};// buffers
let i=[],n=[],r=[],s=[],a=0,o=0;// allow single and array values for "shapes" parameter
if(!1===Array.isArray(e))l(e);else for(let t=0;t<e.length;t++)l(e[t]),this.addGroup(a,o,t),a+=o,o=0;// helper functions
function l(e){let a=n.length/3,l=e.extractPoints(t),h=l.shape,u=l.holes;// check direction of vertices
!1===sI.isClockWise(h)&&(h=h.reverse());for(let e=0,t=u.length;e<t;e++){let t=u[e];!0===sI.isClockWise(t)&&(u[e]=t.reverse())}let c=sI.triangulateShape(h,u);// join vertices of inner and outer paths to a single array
for(let e=0,t=u.length;e<t;e++){let t=u[e];h=h.concat(t)}// vertices, normals, uvs
for(let e=0,t=h.length;e<t;e++){let t=h[e];n.push(t.x,t.y,0),r.push(0,0,1),s.push(t.x,t.y)}// incides
for(let e=0,t=c.length;e<t;e++){let t=c[e],n=t[0]+a,r=t[1]+a,s=t[2]+a;i.push(n,r,s),o+=3}}// build geometry
this.setIndex(i),this.setAttribute("position",new tr(n,3)),this.setAttribute("normal",new tr(r,3)),this.setAttribute("uv",new tr(s,2))}toJSON(){let e=super.toJSON(),t=this.parameters.shapes;return function(e,t){if(t.shapes=[],Array.isArray(e))for(let i=0,n=e.length;i<n;i++){let n=e[i];t.shapes.push(n.uuid)}else t.shapes.push(e.uuid);return t}(t,e)}static fromJSON(e,t){let i=[];for(let n=0,r=e.shapes.length;n<r;n++){let r=t[e.shapes[n]];i.push(r)}return new sB(i,e.curveSegments)}}class sG extends td{constructor(e=1,t=32,i=16,n=0,r=2*Math.PI,s=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:i,phiStart:n,phiLength:r,thetaStart:s,thetaLength:a},t=Math.max(3,Math.floor(t)),i=Math.max(2,Math.floor(i));let o=Math.min(s+a,Math.PI),l=0,h=[],u=new q,c=new q,d=[],p=[],m=[],f=[];// generate vertices, normals and uvs
for(let d=0;d<=i;d++){let g=[],v=d/i,x=0;0==d&&0==s?x=.5/t:d==i&&o==Math.PI&&(x=-.5/t);for(let i=0;i<=t;i++){let o=i/t;// vertex
u.x=-e*Math.cos(n+o*r)*Math.sin(s+v*a),u.y=e*Math.cos(s+v*a),u.z=e*Math.sin(n+o*r)*Math.sin(s+v*a),p.push(u.x,u.y,u.z),// normal
c.copy(u).normalize(),m.push(c.x,c.y,c.z),// uv
f.push(o+x,1-v),g.push(l++)}h.push(g)}// indices
for(let e=0;e<i;e++)for(let n=0;n<t;n++){let t=h[e][n+1],r=h[e][n],a=h[e+1][n],l=h[e+1][n+1];(0!==e||s>0)&&d.push(t,r,l),(e!==i-1||o<Math.PI)&&d.push(r,a,l)}// build geometry
this.setIndex(d),this.setAttribute("position",new tr(p,3)),this.setAttribute("normal",new tr(m,3)),this.setAttribute("uv",new tr(f,2))}static fromJSON(e){return new sG(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class sk extends sp{constructor(e=1,t=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new sk(e.radius,e.detail)}}class sV extends td{constructor(e=1,t=.4,i=8,n=6,r=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:i,tubularSegments:n,arc:r},i=Math.floor(i),n=Math.floor(n);// buffers
let s=[],a=[],o=[],l=[],h=new q,u=new q,c=new q;// generate vertices, normals and uvs
for(let s=0;s<=i;s++)for(let d=0;d<=n;d++){let p=d/n*r,m=s/i*Math.PI*2;// vertex
u.x=(e+t*Math.cos(m))*Math.cos(p),u.y=(e+t*Math.cos(m))*Math.sin(p),u.z=t*Math.sin(m),a.push(u.x,u.y,u.z),// normal
h.x=e*Math.cos(p),h.y=e*Math.sin(p),c.subVectors(u,h).normalize(),o.push(c.x,c.y,c.z),// uv
l.push(d/n),l.push(s/i)}// generate indices
for(let e=1;e<=i;e++)for(let t=1;t<=n;t++){// indices
let i=(n+1)*e+t-1,r=(n+1)*(e-1)+t-1,a=(n+1)*(e-1)+t,o=(n+1)*e+t;// faces
s.push(i,r,o),s.push(r,a,o)}// build geometry
this.setIndex(s),this.setAttribute("position",new tr(a,3)),this.setAttribute("normal",new tr(o,3)),this.setAttribute("uv",new tr(l,2))}static fromJSON(e){return new sV(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class sW extends td{constructor(e=1,t=.4,i=64,n=8,r=2,s=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:i,radialSegments:n,p:r,q:s},i=Math.floor(i),n=Math.floor(n);// buffers
let a=[],o=[],l=[],h=[],u=new q,c=new q,d=new q,p=new q,m=new q,f=new q,g=new q;// generate vertices, normals and uvs
for(let a=0;a<=i;++a){// the radian "u" is used to calculate the position on the torus curve of the current tubular segment
let x=a/i*r*Math.PI*2;// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
v(x,r,s,e,d),v(x+.01,r,s,e,p),// calculate orthonormal basis
f.subVectors(p,d),g.addVectors(p,d),m.crossVectors(f,g),g.crossVectors(m,f),// normalize B, N. T can be ignored, we don't use it
m.normalize(),g.normalize();for(let e=0;e<=n;++e){// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
let r=e/n*Math.PI*2,s=-t*Math.cos(r),p=t*Math.sin(r);// now calculate the final vertex position.
// first we orient the extrusion with our basis vectors, then we add it to the current position on the curve
u.x=d.x+(s*g.x+p*m.x),u.y=d.y+(s*g.y+p*m.y),u.z=d.z+(s*g.z+p*m.z),o.push(u.x,u.y,u.z),// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
c.subVectors(u,d).normalize(),l.push(c.x,c.y,c.z),// uv
h.push(a/i),h.push(e/n)}}// generate indices
for(let e=1;e<=i;e++)for(let t=1;t<=n;t++){// indices
let i=(n+1)*(e-1)+(t-1),r=(n+1)*e+(t-1),s=(n+1)*e+t,o=(n+1)*(e-1)+t;// faces
a.push(i,r,o),a.push(r,s,o)}// this function calculates the current position on the torus curve
function v(e,t,i,n,r){let s=i/t*e,a=Math.cos(s);r.x=n*(2+a)*.5*Math.cos(e),r.y=n*(2+a)*Math.sin(e)*.5,r.z=n*Math.sin(s)*.5}// build geometry
this.setIndex(a),this.setAttribute("position",new tr(o,3)),this.setAttribute("normal",new tr(l,3)),this.setAttribute("uv",new tr(h,2))}static fromJSON(e){return new sW(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class sj extends td{constructor(e=new sn(new q(-1,-1,0),new q(-1,1,0),new q(1,1,0)),t=64,i=1,n=8,r=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:i,radialSegments:n,closed:r};let s=e.computeFrenetFrames(t,r);// expose internals
this.tangents=s.tangents,this.normals=s.normals,this.binormals=s.binormals;// helper variables
let a=new q,o=new q,l=new b,h=new q,u=[],c=[],d=[],p=[];function m(r){// we use getPointAt to sample evenly distributed points from the given path
h=e.getPointAt(r/t,h);// retrieve corresponding normal and binormal
let l=s.normals[r],d=s.binormals[r];// generate normals and vertices for the current segment
for(let e=0;e<=n;e++){let t=e/n*Math.PI*2,r=Math.sin(t),s=-Math.cos(t);// normal
o.x=s*l.x+r*d.x,o.y=s*l.y+r*d.y,o.z=s*l.z+r*d.z,o.normalize(),c.push(o.x,o.y,o.z),// vertex
a.x=h.x+i*o.x,a.y=h.y+i*o.y,a.z=h.z+i*o.z,u.push(a.x,a.y,a.z)}}// create buffer data
// functions
(function(){for(let e=0;e<t;e++)m(e);// if the geometry is not closed, generate the last row of vertices and normals
// at the regular position on the given path
//
// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
m(!1===r?t:0),// uvs are generated in a separate function.
// this makes it easy compute correct values for closed geometries
function(){for(let e=0;e<=t;e++)for(let i=0;i<=n;i++)l.x=e/t,l.y=i/n,d.push(l.x,l.y)}(),// finally create faces
function(){for(let e=1;e<=t;e++)for(let t=1;t<=n;t++){let i=(n+1)*(e-1)+(t-1),r=(n+1)*e+(t-1),s=(n+1)*e+t,a=(n+1)*(e-1)+t;// faces
p.push(i,r,a),p.push(r,s,a)}}()})(),// build geometry
this.setIndex(p),this.setAttribute("position",new tr(u,3)),this.setAttribute("normal",new tr(c,3)),this.setAttribute("uv",new tr(d,2))}toJSON(){let e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){// This only works for built-in curves (e.g. CatmullRomCurve3).
// User defined curves or instances of CurvePath will not be deserialized.
return new sj(new ss[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class sq extends e8{constructor(e){super(),this.type="ShadowMaterial",this.color=new O(0),this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this}}sq.prototype.isShadowMaterial=!0;class sX extends tz{constructor(e){super(e),this.type="RawShaderMaterial"}}sX.prototype.isRawShaderMaterial=!0;class sY extends e8{constructor(e){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new O(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new O(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new b(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this}}sY.prototype.isMeshStandardMaterial=!0;class sJ extends sY{constructor(e){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new b(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return m(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.sheenColor=new O(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new O(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new O(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._transmission=0,this.setValues(e)}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}sJ.prototype.isMeshPhysicalMaterial=!0;class sZ extends e8{constructor(e){super(),this.type="MeshPhongMaterial",this.color=new O(16777215),this.specular=new O(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new O(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new b(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this}}sZ.prototype.isMeshPhongMaterial=!0;class sK extends e8{constructor(e){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new O(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new O(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new b(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}sK.prototype.isMeshToonMaterial=!0;class sQ extends e8{constructor(e){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new b(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}sQ.prototype.isMeshNormalMaterial=!0;class s$ extends e8{constructor(e){super(),this.type="MeshLambertMaterial",this.color=new O(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new O(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}s$.prototype.isMeshLambertMaterial=!0;class s0 extends e8{constructor(e){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new O(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new b(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this}}s0.prototype.isMeshMatcapMaterial=!0;class s1 extends rD{constructor(e){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}s1.prototype.isLineDashedMaterial=!0;const s3={ShadowMaterial:sq,SpriteMaterial:rn,RawShaderMaterial:sX,ShaderMaterial:tz,PointsMaterial:rW,MeshPhysicalMaterial:sJ,MeshStandardMaterial:sY,MeshPhongMaterial:sZ,MeshToonMaterial:sK,MeshNormalMaterial:sQ,MeshLambertMaterial:s$,MeshDepthMaterial:nX,MeshDistanceMaterial:nY,MeshBasicMaterial:e7,MeshMatcapMaterial:s0,LineDashedMaterial:s1,LineBasicMaterial:rD,Material:e8};e8.fromType=function(e){return new s3[e]};const s2={// same as Array.prototype.slice, but also works on typed arrays
arraySlice:function(e,t,i){return s2.isTypedArray(e)?new e.constructor(e.subarray(t,void 0!==i?i:e.length)):e.slice(t,i)},// converts an array to a specific type
convertArray:function(e,t,i){return e&&// let 'undefined' and 'null' pass
(i||e.constructor!==t)?"number"==typeof t.BYTES_PER_ELEMENT?new t(e):Array.prototype.slice.call(e):e},isTypedArray:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)},// returns an array by which times and values can be sorted
getKeyframeOrder:function(e){let t=e.length,i=Array(t);for(let e=0;e!==t;++e)i[e]=e;return i.sort(function(t,i){return e[t]-e[i]}),i},// uses the array previously returned by 'getKeyframeOrder' to sort data
sortedArray:function(e,t,i){let n=e.length,r=new e.constructor(n);for(let s=0,a=0;a!==n;++s){let n=i[s]*t;for(let i=0;i!==t;++i)r[a++]=e[n+i]}return r},// function for parsing AOS keyframe formats
flattenJSON:function(e,t,i,n){let r=1,s=e[0];for(;void 0!==s&&void 0===s[n];)s=e[r++];if(void 0===s)return;// no data
let a=s[n];if(void 0!==a){if(Array.isArray(a))do void 0!==(a=s[n])&&(t.push(s.time),i.push.apply(i,a)),s=e[r++];while(void 0!==s)else if(void 0!==a.toArray)do void 0!==(a=s[n])&&(t.push(s.time),a.toArray(i,i.length)),s=e[r++];while(void 0!==s)else do void 0!==(a=s[n])&&(t.push(s.time),i.push(a)),s=e[r++];while(void 0!==s)}// no data
},subclip:function(e,t,i,n,r=30){let s=e.clone();s.name=t;let a=[];for(let e=0;e<s.tracks.length;++e){let t=s.tracks[e],o=t.getValueSize(),l=[],h=[];for(let e=0;e<t.times.length;++e){let s=t.times[e]*r;if(!(s<i)&&!(s>=n)){l.push(t.times[e]);for(let i=0;i<o;++i)h.push(t.values[e*o+i])}}0!==l.length&&(t.times=s2.convertArray(l,t.times.constructor),t.values=s2.convertArray(h,t.values.constructor),a.push(t))}s.tracks=a;// find minimum .times value across all tracks in the trimmed clip
let o=1/0;for(let e=0;e<s.tracks.length;++e)o>s.tracks[e].times[0]&&(o=s.tracks[e].times[0]);// shift all tracks such that clip begins at t=0
for(let e=0;e<s.tracks.length;++e)s.tracks[e].shift(-1*o);return s.resetDuration(),s},makeClipAdditive:function(e,t=0,i=e,n=30){n<=0&&(n=30);let r=i.tracks.length,s=t/n;// Make each track's values relative to the values at the reference frame
for(let t=0;t<r;++t){let n;let r=i.tracks[t],a=r.ValueTypeName;// Skip this track if it's non-numeric
if("bool"===a||"string"===a)continue;// Find the track in the target clip whose name and type matches the reference track
let o=e.tracks.find(function(e){return e.name===r.name&&e.ValueTypeName===a});if(void 0===o)continue;let l=0,h=r.getValueSize();r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(l=h/3);let u=0,c=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(u=c/3);let d=r.times.length-1;// Find the value to subtract out of the track
if(s<=r.times[0]){// Reference frame is earlier than the first keyframe, so just use the first keyframe
let e=l,t=h-l;n=s2.arraySlice(r.values,e,t)}else if(s>=r.times[d]){// Reference frame is after the last keyframe, so just use the last keyframe
let e=d*h+l,t=e+h-l;n=s2.arraySlice(r.values,e,t)}else{// Interpolate to the reference value
let e=r.createInterpolant(),t=l,i=h-l;e.evaluate(s),n=s2.arraySlice(e.resultBuffer,t,i)}// Conjugate the quaternion
if("quaternion"===a){let e=new j().fromArray(n).normalize().conjugate();e.toArray(n)}// Subtract the reference value from all of the track values
let p=o.times.length;for(let e=0;e<p;++e){let t=e*c+u;if("quaternion"===a)j.multiplyQuaternionsFlat(o.values,t,n,0,o.values,t);else{let e=c-2*u;// Subtract each value for all other numeric track types
for(let i=0;i<e;++i)o.values[t+i]-=n[i]}}}return e.blendMode=2501,e}};/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */class s4{constructor(e,t,i,n){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=void 0!==n?n:new t.constructor(i),this.sampleValues=t,this.valueSize=i,this.settings=null,this.DefaultSettings_={}}evaluate(e){let t=this.parameterPositions,i=this._cachedIndex,n=t[i],r=t[i-1];e:{t:{let s;i:{//- See http://jsperf.com/comparison-to-undefined/3
//- slower code:
//-
//- 				if ( t >= t1 || t1 === undefined ) {
n:if(!(e<n)){for(let s=i+2;;){if(void 0===n){if(e<r)break n;return(// after end
i=t.length,this._cachedIndex=i,this.afterEnd_(i-1,e,r))}if(i===s)break;// this loop
if(r=n,e<(n=t[++i]))break t}// prepare binary search on the right side of the index
s=t.length;break i}//- slower code:
//-					if ( t < t0 || t0 === undefined ) {
if(!(e>=r)){// looping?
let a=t[1];e<a&&(i=2,r=a);// linear reverse scan
for(let s=i-2;;){if(void 0===r)return(// before start
this._cachedIndex=0,this.beforeStart_(0,e,n));if(i===s)break;// this loop
if(n=r,e>=(r=t[--i-1]))break t}// prepare binary search on the left side of the index
s=i,i=0;break i}break e}// linear scan
// binary search
for(;i<s;){let n=i+s>>>1;e<t[n]?s=n:i=n+1}// check boundary cases, again
if(n=t[i],void 0===(r=t[i-1]))return this._cachedIndex=0,this.beforeStart_(0,e,n);if(void 0===n)return i=t.length,this._cachedIndex=i,this.afterEnd_(i-1,r,e)}// seek
this._cachedIndex=i,this.intervalChanged_(i,r,n)}// validate_interval
return this.interpolate_(i,r,e,n)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){// copies a sample value to the result buffer
let t=this.resultBuffer,i=this.sampleValues,n=this.valueSize,r=e*n;for(let e=0;e!==n;++e)t[e]=i[r+e];return t}// Template methods for derived classes:
interpolate_(){throw Error("call to abstract method");// implementations shall return this.resultBuffer
}intervalChanged_(){// empty
}}// ALIAS DEFINITIONS
s4.prototype.beforeStart_=s4.prototype.copySampleValue_,s4.prototype.afterEnd_=s4.prototype.copySampleValue_;/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */class s5 extends s4{constructor(e,t,i,n){super(e,t,i,n),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:2400,endingEnd:2400}}intervalChanged_(e,t,i){let n=this.parameterPositions,r=e-2,s=e+1,a=n[r],o=n[s];if(void 0===a)switch(this.getSettings_().endingStart){case 2401:// f'(t0) = 0
r=e,a=2*t-i;break;case 2402:// use the other end of the curve
r=n.length-2,a=t+n[r]-n[r+1];break;default:// f''(t0) = 0 a.k.a. Natural Spline
r=e,a=i}if(void 0===o)switch(this.getSettings_().endingEnd){case 2401:// f'(tN) = 0
s=e,o=2*i-t;break;case 2402:// use the other end of the curve
s=1,o=i+n[1]-n[0];break;default:// f''(tN) = 0, a.k.a. Natural Spline
s=e-1,o=t}let l=(i-t)*.5,h=this.valueSize;this._weightPrev=l/(t-a),this._weightNext=l/(o-i),this._offsetPrev=r*h,this._offsetNext=s*h}interpolate_(e,t,i,n){let r=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=e*a,l=o-a,h=this._offsetPrev,u=this._offsetNext,c=this._weightPrev,d=this._weightNext,p=(i-t)/(n-t),m=p*p,f=m*p,g=-c*f+2*c*m-c*p,v=(1+c)*f+(-1.5-2*c)*m+(-.5+c)*p+1,x=(-1-d)*f+(1.5+d)*m+.5*p,y=d*f-d*m;// combine data linearly
for(let e=0;e!==a;++e)r[e]=g*s[h+e]+v*s[l+e]+x*s[o+e]+y*s[u+e];return r}}class s6 extends s4{constructor(e,t,i,n){super(e,t,i,n)}interpolate_(e,t,i,n){let r=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=e*a,l=o-a,h=(i-t)/(n-t),u=1-h;for(let e=0;e!==a;++e)r[e]=s[l+e]*u+s[o+e]*h;return r}}/**
 *
 * Interpolant that evaluates to the sample value at the position preceding
 * the parameter.
 */class s8 extends s4{constructor(e,t,i,n){super(e,t,i,n)}interpolate_(e/*, t0, t, t1 */){return this.copySampleValue_(e-1)}}class s7{constructor(e,t,i,n){if(void 0===e)throw Error("THREE.KeyframeTrack: track name is undefined");if(void 0===t||0===t.length)throw Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=s2.convertArray(t,this.TimeBufferType),this.values=s2.convertArray(i,this.ValueBufferType),this.setInterpolation(n||this.DefaultInterpolation)}// Serialization (in static context, because of constructor invocation
// and automatic invocation of .toJSON):
static toJSON(e){let t;let i=e.constructor;// derived classes can define a static toJSON method
if(i.toJSON!==this.toJSON)t=i.toJSON(e);else{// by default, we assume the data can be serialized as-is
t={name:e.name,times:s2.convertArray(e.times,Array),values:s2.convertArray(e.values,Array)};let i=e.getInterpolation();i!==e.DefaultInterpolation&&(t.interpolation=i)}return t.type=e.ValueTypeName,t}InterpolantFactoryMethodDiscrete(e){return new s8(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new s6(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new s5(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case 2300:t=this.InterpolantFactoryMethodDiscrete;break;case 2301:t=this.InterpolantFactoryMethodLinear;break;case 2302:t=this.InterpolantFactoryMethodSmooth}if(void 0===t){let t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){// fall back to default, unless the default itself is messed up
if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw Error(t);// fatal, in this case
}return console.warn("THREE.KeyframeTrack:",t),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return 2300;case this.InterpolantFactoryMethodLinear:return 2301;case this.InterpolantFactoryMethodSmooth:return 2302}}getValueSize(){return this.values.length/this.times.length}// move all keyframes either forwards or backwards in time
shift(e){if(0!==e){let t=this.times;for(let i=0,n=t.length;i!==n;++i)t[i]+=e}return this}// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
scale(e){if(1!==e){let t=this.times;for(let i=0,n=t.length;i!==n;++i)t[i]*=e}return this}// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
trim(e,t){let i=this.times,n=i.length,r=0,s=n-1;for(;r!==n&&i[r]<e;)++r;for(;-1!==s&&i[s]>t;)--s;if(++s,0!==r||s!==n){r>=s&&(r=(s=Math.max(s,1))-1);let e=this.getValueSize();this.times=s2.arraySlice(i,r,s),this.values=s2.arraySlice(this.values,r*e,s*e)}return this}// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
validate(){let e=!0,t=this.getValueSize();t-Math.floor(t)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);let i=this.times,n=this.values,r=i.length;0===r&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let s=null;for(let t=0;t!==r;t++){let n=i[t];if("number"==typeof n&&isNaN(n)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,t,n),e=!1;break}if(null!==s&&s>n){console.error("THREE.KeyframeTrack: Out of order keys.",this,t,n,s),e=!1;break}s=n}if(void 0!==n&&s2.isTypedArray(n))for(let t=0,i=n.length;t!==i;++t){let i=n[t];if(isNaN(i)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,t,i),e=!1;break}}return e}// removes equivalent sequential keys as common in morph target sequences
// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
optimize(){// times or values may be shared with other tracks, so overwriting is unsafe
let e=s2.arraySlice(this.times),t=s2.arraySlice(this.values),i=this.getValueSize(),n=2302===this.getInterpolation(),r=e.length-1,s=1;for(let a=1;a<r;++a){let r=!1,o=e[a],l=e[a+1];// remove adjacent keyframes scheduled at the same time
if(o!==l&&(1!==a||o!==e[0])){if(n)r=!0;else{// remove unnecessary keyframes same as their neighbors
let e=a*i,n=e-i,s=e+i;for(let a=0;a!==i;++a){let i=t[e+a];if(i!==t[n+a]||i!==t[s+a]){r=!0;break}}}}// in-place compaction
if(r){if(a!==s){e[s]=e[a];let n=a*i,r=s*i;for(let e=0;e!==i;++e)t[r+e]=t[n+e]}++s}}// flush last keyframe (compaction looks ahead)
if(r>0){e[s]=e[r];for(let e=r*i,n=s*i,a=0;a!==i;++a)t[n+a]=t[e+a];++s}return s!==e.length?(this.times=s2.arraySlice(e,0,s),this.values=s2.arraySlice(t,0,s*i)):(this.times=e,this.values=t),this}clone(){let e=s2.arraySlice(this.times,0),t=s2.arraySlice(this.values,0),i=this.constructor,n=new i(this.name,e,t);return(// Interpolant argument to constructor is not saved, so copy the factory method directly.
n.createInterpolant=this.createInterpolant,n)}}s7.prototype.TimeBufferType=Float32Array,s7.prototype.ValueBufferType=Float32Array,s7.prototype.DefaultInterpolation=2301;/**
 * A Track of Boolean keyframe values.
 */class s9 extends s7{}s9.prototype.ValueTypeName="bool",s9.prototype.ValueBufferType=Array,s9.prototype.DefaultInterpolation=2300,s9.prototype.InterpolantFactoryMethodLinear=void 0,s9.prototype.InterpolantFactoryMethodSmooth=void 0;/**
 * A Track of keyframe values that represent color.
 */class ae extends s7{}ae.prototype.ValueTypeName="color";/**
 * A Track of numeric keyframe values.
 */class at extends s7{}at.prototype.ValueTypeName="number";/**
 * Spherical linear unit quaternion interpolant.
 */class ai extends s4{constructor(e,t,i,n){super(e,t,i,n)}interpolate_(e,t,i,n){let r=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=(i-t)/(n-t),l=e*a;for(let e=l+a;l!==e;l+=4)j.slerpFlat(r,0,s,l-a,s,l,o);return r}}/**
 * A Track of quaternion keyframe values.
 */class an extends s7{InterpolantFactoryMethodLinear(e){return new ai(this.times,this.values,this.getValueSize(),e)}}an.prototype.ValueTypeName="quaternion",// ValueBufferType is inherited
an.prototype.DefaultInterpolation=2301,an.prototype.InterpolantFactoryMethodSmooth=void 0;/**
 * A Track that interpolates Strings
 */class ar extends s7{}ar.prototype.ValueTypeName="string",ar.prototype.ValueBufferType=Array,ar.prototype.DefaultInterpolation=2300,ar.prototype.InterpolantFactoryMethodLinear=void 0,ar.prototype.InterpolantFactoryMethodSmooth=void 0;/**
 * A Track of vectored keyframe values.
 */class as extends s7{}as.prototype.ValueTypeName="vector";class aa{constructor(e,t=-1,i,n=2500){this.name=e,this.tracks=i,this.duration=t,this.blendMode=n,this.uuid=p(),this.duration<0&&this.resetDuration()}static parse(e){let t=[],i=e.tracks,n=1/(e.fps||1);for(let e=0,r=i.length;e!==r;++e)t.push((function(e){if(void 0===e.type)throw Error("THREE.KeyframeTrack: track type undefined, can not parse");let t=function(e){switch(e.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return at;case"vector":case"vector2":case"vector3":case"vector4":return as;case"color":return ae;case"quaternion":return an;case"bool":case"boolean":return s9;case"string":return ar}throw Error("THREE.KeyframeTrack: Unsupported typeName: "+e)}(e.type);if(void 0===e.times){let t=[],i=[];s2.flattenJSON(e.keys,t,i,"value"),e.times=t,e.values=i}return(// derived classes can define a static parse method
void 0!==t.parse?t.parse(e):new t(e.name,e.times,e.values,e.interpolation))})(i[e]).scale(n));let r=new this(e.name,e.duration,t,e.blendMode);return r.uuid=e.uuid,r}static toJSON(e){let t=[],i=e.tracks,n={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let e=0,n=i.length;e!==n;++e)t.push(s7.toJSON(i[e]));return n}static CreateFromMorphTargetSequence(e,t,i,n){let r=t.length,s=[];for(let e=0;e<r;e++){let a=[],o=[];a.push((e+r-1)%r,e,(e+1)%r),o.push(0,1,0);let l=s2.getKeyframeOrder(a);a=s2.sortedArray(a,1,l),o=s2.sortedArray(o,1,l),n||0!==a[0]||(a.push(r),o.push(o[0])),s.push(new at(".morphTargetInfluences["+t[e].name+"]",a,o).scale(1/i))}return new this(e,-1,s)}static findByName(e,t){let i=e;Array.isArray(e)||(i=e.geometry&&e.geometry.animations||e.animations);for(let e=0;e<i.length;e++)if(i[e].name===t)return i[e];return null}static CreateClipsFromMorphTargetSequences(e,t,i){let n={},r=/^([\w-]*?)([\d]+)$/;// sort morph target names into animation groups based
// patterns like Walk_001, Walk_002, Run_001, Run_002
for(let t=0,i=e.length;t<i;t++){let i=e[t],s=i.name.match(r);if(s&&s.length>1){let e=s[1],t=n[e];t||(n[e]=t=[]),t.push(i)}}let s=[];for(let e in n)s.push(this.CreateFromMorphTargetSequence(e,n[e],t,i));return s}// parse the animation.hierarchy format
static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;let i=function(e,t,i,n,r){// only return track if there are actually keys.
if(0!==i.length){let s=[],a=[];s2.flattenJSON(i,s,a,n),0!==s.length&&r.push(new e(t,s,a))}},n=[],r=e.name||"default",s=e.fps||30,a=e.blendMode,o=e.length||-1,l=e.hierarchy||[];for(let e=0;e<l.length;e++){let r=l[e].keys;// skip empty tracks
if(r&&0!==r.length){// process morph targets
if(r[0].morphTargets){let e;// figure out all morph targets used in this track
let t={};for(e=0;e<r.length;e++)if(r[e].morphTargets)for(let i=0;i<r[e].morphTargets.length;i++)t[r[e].morphTargets[i]]=-1;// create a track for each morph target with all zero
// morphTargetInfluences except for the keys in which
// the morphTarget is named.
for(let i in t){let t=[],s=[];for(let n=0;n!==r[e].morphTargets.length;++n){let n=r[e];t.push(n.time),s.push(n.morphTarget===i?1:0)}n.push(new at(".morphTargetInfluence["+i+"]",t,s))}o=t.length*s}else{// ...assume skeletal animation
let s=".bones["+t[e].name+"]";i(as,s+".position",r,"pos",n),i(an,s+".quaternion",r,"rot",n),i(as,s+".scale",r,"scl",n)}}}if(0===n.length)return null;let h=new this(r,o,n,a);return h}resetDuration(){let e=this.tracks,t=0;for(let i=0,n=e.length;i!==n;++i){let e=this.tracks[i];t=Math.max(t,e.times[e.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){let e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}const ao={enabled:!1,files:{},add:function(e,t){!1!==this.enabled&&// console.log( 'THREE.Cache', 'Adding key:', key );
(this.files[e]=t)},get:function(e){if(!1!==this.enabled)// console.log( 'THREE.Cache', 'Checking key:', key );
return this.files[e]},remove:function(e){delete this.files[e]},clear:function(){this.files={}}},al=new class{constructor(e,t,i){let n;let r=this,s=!1,a=0,o=0,l=[];// Refer to #5689 for the reason why we don't set .onStart
// in the constructor
this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=i,this.itemStart=function(e){o++,!1===s&&void 0!==r.onStart&&r.onStart(e,a,o),s=!0},this.itemEnd=function(e){a++,void 0!==r.onProgress&&r.onProgress(e,a,o),a===o&&(s=!1,void 0!==r.onLoad&&r.onLoad())},this.itemError=function(e){void 0!==r.onError&&r.onError(e)},this.resolveURL=function(e){return n?n(e):e},this.setURLModifier=function(e){return n=e,this},this.addHandler=function(e,t){return l.push(e,t),this},this.removeHandler=function(e){let t=l.indexOf(e);return -1!==t&&l.splice(t,2),this},this.getHandler=function(e){for(let t=0,i=l.length;t<i;t+=2){let i=l[t],n=l[t+1];if(i.global&&(i.lastIndex=0),i.test(e))return n}return null}}};class ah{constructor(e){this.manager=void 0!==e?e:al,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){let i=this;return new Promise(function(n,r){i.load(e,n,t,r)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}const au={};class ac extends ah{constructor(e){super(e)}load(e,t,i,n){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);let r=ao.get(e);if(void 0!==r)return this.manager.itemStart(e),setTimeout(()=>{t&&t(r),this.manager.itemEnd(e)},0),r;// Check if request is duplicate
if(void 0!==au[e]){au[e].push({onLoad:t,onProgress:i,onError:n});return}// Initialise array for duplicate requests
au[e]=[],au[e].push({onLoad:t,onProgress:i,onError:n});// create request
let s=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,o=this.responseType;// start the fetch
fetch(s).then(t=>{if(200===t.status||0===t.status){// Workaround: Checking if response.body === undefined for Alipay browser #23548
if(0===t.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),"undefined"==typeof ReadableStream||void 0===t.body||void 0===t.body.getReader)return t;let i=au[e],n=t.body.getReader(),r=t.headers.get("Content-Length"),s=r?parseInt(r):0,a=0!==s,o=0,l=new ReadableStream({start(e){(function t(){n.read().then(({done:n,value:r})=>{if(n)e.close();else{o+=r.byteLength;let n=new ProgressEvent("progress",{lengthComputable:a,loaded:o,total:s});for(let e=0,t=i.length;e<t;e++){let t=i[e];t.onProgress&&t.onProgress(n)}e.enqueue(r),t()}})})()}});return new Response(l)}throw Error(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`)}).then(e=>{switch(o){case"arraybuffer":return e.arrayBuffer();case"blob":return e.blob();case"document":return e.text().then(e=>{let t=new DOMParser;return t.parseFromString(e,a)});case"json":return e.json();default:if(void 0===a)return e.text();{let t=/charset="?([^;"\s]*)"?/i.exec(a),i=t&&t[1]?t[1].toLowerCase():void 0,n=new TextDecoder(i);return e.arrayBuffer().then(e=>n.decode(e))}}}).then(t=>{// Add to cache only on HTTP success, so that we do not cache
// error response bodies as proper responses to requests.
ao.add(e,t);let i=au[e];delete au[e];for(let e=0,n=i.length;e<n;e++){let n=i[e];n.onLoad&&n.onLoad(t)}}).catch(t=>{// Abort errors and other errors are handled the same
let i=au[e];if(void 0===i)throw(// When onLoad was called and url was deleted in `loading`
this.manager.itemError(e),t);delete au[e];for(let e=0,n=i.length;e<n;e++){let n=i[e];n.onError&&n.onError(t)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class ad extends ah{constructor(e){super(e)}load(e,t,i,n){void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);let r=this,s=ao.get(e);if(void 0!==s)return r.manager.itemStart(e),setTimeout(function(){t&&t(s),r.manager.itemEnd(e)},0),s;let a=S("img");function o(){h(),ao.add(e,this),t&&t(this),r.manager.itemEnd(e)}function l(t){h(),n&&n(t),r.manager.itemError(e),r.manager.itemEnd(e)}function h(){a.removeEventListener("load",o,!1),a.removeEventListener("error",l,!1)}return a.addEventListener("load",o,!1),a.addEventListener("error",l,!1),"data:"!==e.slice(0,5)&&void 0!==this.crossOrigin&&(a.crossOrigin=this.crossOrigin),r.manager.itemStart(e),a.src=e,a}}class ap extends ah{constructor(e){super(e)}load(e,t,i,n){let r=new tB,s=new ad(this.manager);s.setCrossOrigin(this.crossOrigin),s.setPath(this.path);let a=0;for(let i=0;i<e.length;++i)!function(i){s.load(e[i],function(e){r.images[i]=e,6==++a&&(r.needsUpdate=!0,t&&t(r))},void 0,n)}(i);return r}}/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */class am extends ah{constructor(e){super(e)}load(e,t,i,n){let r=this,s=new rS,a=new ac(this.manager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(r.withCredentials),a.load(e,function(e){let i=r.parse(e);i&&(void 0!==i.image?s.image=i.image:void 0!==i.data&&(s.image.width=i.width,s.image.height=i.height,s.image.data=i.data),s.wrapS=void 0!==i.wrapS?i.wrapS:1001,s.wrapT=void 0!==i.wrapT?i.wrapT:1001,s.magFilter=void 0!==i.magFilter?i.magFilter:1006,s.minFilter=void 0!==i.minFilter?i.minFilter:1006,s.anisotropy=void 0!==i.anisotropy?i.anisotropy:1,void 0!==i.encoding&&(s.encoding=i.encoding),void 0!==i.flipY&&(s.flipY=i.flipY),void 0!==i.format&&(s.format=i.format),void 0!==i.type&&(s.type=i.type),void 0!==i.mipmaps&&(s.mipmaps=i.mipmaps,s.minFilter=1008),1===i.mipmapCount&&(s.minFilter=1006),void 0!==i.generateMipmaps&&(s.generateMipmaps=i.generateMipmaps),s.needsUpdate=!0,t&&t(s,i))},i,n),s}}class af extends ah{constructor(e){super(e)}load(e,t,i,n){let r=new B,s=new ad(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(e,function(e){r.image=e,r.needsUpdate=!0,void 0!==t&&t(r)},i,n),r}}class ag extends eY{constructor(e,t=1){super(),this.type="Light",this.color=new O(e),this.intensity=t}dispose(){// Empty here in base class; some subclasses override.
}copy(e){return super.copy(e),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){let t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,void 0!==this.groundColor&&(t.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(t.object.distance=this.distance),void 0!==this.angle&&(t.object.angle=this.angle),void 0!==this.decay&&(t.object.decay=this.decay),void 0!==this.penumbra&&(t.object.penumbra=this.penumbra),void 0!==this.shadow&&(t.object.shadow=this.shadow.toJSON()),t}}ag.prototype.isLight=!0,(class extends ag{constructor(e,t,i){super(e,i),this.type="HemisphereLight",this.position.copy(eY.DefaultUp),this.updateMatrix(),this.groundColor=new O(t)}copy(e){return ag.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}}).prototype.isHemisphereLight=!0;const av=/*@__PURE__*/new ew,ax=/*@__PURE__*/new q,ay=/*@__PURE__*/new q;class a_{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new b(512,512),this.map=null,this.mapPass=null,this.matrix=new ew,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new tY,this._frameExtents=new b(1,1),this._viewportCount=1,this._viewports=[new G(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){let t=this.camera,i=this.matrix;ax.setFromMatrixPosition(e.matrixWorld),t.position.copy(ax),ay.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(ay),t.updateMatrixWorld(),av.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(av),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(t.projectionMatrix),i.multiply(t.matrixWorldInverse)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){let e={};return 0!==this.bias&&(e.bias=this.bias),0!==this.normalBias&&(e.normalBias=this.normalBias),1!==this.radius&&(e.radius=this.radius),(512!==this.mapSize.x||512!==this.mapSize.y)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class ab extends a_{constructor(){super(new tH(50,1,.5,500)),this.focus=1}updateMatrices(e){let t=this.camera,i=2*d*e.angle*this.focus,n=this.mapSize.width/this.mapSize.height,r=e.distance||t.far;(i!==t.fov||n!==t.aspect||r!==t.far)&&(t.fov=i,t.aspect=n,t.far=r,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}ab.prototype.isSpotLightShadow=!0;class aM extends ag{constructor(e,t,i=0,n=Math.PI/3,r=0,s=1){super(e,t),this.type="SpotLight",this.position.copy(eY.DefaultUp),this.updateMatrix(),this.target=new eY,this.distance=i,this.angle=n,this.penumbra=r,this.decay=s,this.shadow=new ab}get power(){// compute the light's luminous power (in lumens) from its intensity (in candela)
// by convention for a spotlight, luminous power (lm) =  * luminous intensity (cd)
return this.intensity*Math.PI}set power(e){// set the light's intensity (in candela) from the desired luminous power (in lumens)
this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}aM.prototype.isSpotLight=!0;const aw=/*@__PURE__*/new ew,aS=/*@__PURE__*/new q,aT=/*@__PURE__*/new q;class aE extends a_{constructor(){super(new tH(90,1,.5,500)),this._frameExtents=new b(4,2),this._viewportCount=6,this._viewports=[// These viewports map a cube-map onto a 2D texture with the
// following orientation:
//
//  xzXZ
//   y Y
//
// X - Positive x direction
// x - Negative x direction
// Y - Positive y direction
// y - Negative y direction
// Z - Positive z direction
// z - Negative z direction
// positive X
new G(2,1,1,1),// negative X
new G(0,1,1,1),// positive Z
new G(3,1,1,1),// negative Z
new G(1,1,1,1),// positive Y
new G(3,0,1,1),// negative Y
new G(1,0,1,1)],this._cubeDirections=[new q(1,0,0),new q(-1,0,0),new q(0,0,1),new q(0,0,-1),new q(0,1,0),new q(0,-1,0)],this._cubeUps=[new q(0,1,0),new q(0,1,0),new q(0,1,0),new q(0,1,0),new q(0,0,1),new q(0,0,-1)]}updateMatrices(e,t=0){let i=this.camera,n=this.matrix,r=e.distance||i.far;r!==i.far&&(i.far=r,i.updateProjectionMatrix()),aS.setFromMatrixPosition(e.matrixWorld),i.position.copy(aS),aT.copy(i.position),aT.add(this._cubeDirections[t]),i.up.copy(this._cubeUps[t]),i.lookAt(aT),i.updateMatrixWorld(),n.makeTranslation(-aS.x,-aS.y,-aS.z),aw.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(aw)}}aE.prototype.isPointLightShadow=!0;class aA extends ag{constructor(e,t,i=0,n=1){super(e,t),this.type="PointLight",this.distance=i,this.decay=n,this.shadow=new aE}get power(){// compute the light's luminous power (in lumens) from its intensity (in candela)
// for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)
return 4*this.intensity*Math.PI}set power(e){// set the light's intensity (in candela) from the desired luminous power (in lumens)
this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}aA.prototype.isPointLight=!0;class aR extends a_{constructor(){super(new t8(-5,5,5,-5,.5,500))}}aR.prototype.isDirectionalLightShadow=!0;class aL extends ag{constructor(e,t){super(e,t),this.type="DirectionalLight",this.position.copy(eY.DefaultUp),this.updateMatrix(),this.target=new eY,this.shadow=new aR}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}aL.prototype.isDirectionalLight=!0,(class extends ag{constructor(e,t){super(e,t),this.type="AmbientLight"}}).prototype.isAmbientLight=!0,(class extends ag{constructor(e,t,i=10,n=10){super(e,t),this.type="RectAreaLight",this.width=i,this.height=n}get power(){// compute the light's luminous power (in lumens) from its intensity (in nits)
return this.intensity*this.width*this.height*Math.PI}set power(e){// set the light's intensity (in nits) from the desired luminous power (in lumens)
this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){let t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}).prototype.isRectAreaLight=!0;/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */// 3-band SH defined by 9 coefficients
class aC{constructor(){this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new q)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}// get the radiance in the direction of the normal
// target is a Vector3
getAt(e,t){// normal is assumed to be unit length
let i=e.x,n=e.y,r=e.z,s=this.coefficients;return(// band 0
t.copy(s[0]).multiplyScalar(.282095),// band 1
t.addScaledVector(s[1],.488603*n),t.addScaledVector(s[2],.488603*r),t.addScaledVector(s[3],.488603*i),// band 2
t.addScaledVector(s[4],1.092548*(i*n)),t.addScaledVector(s[5],1.092548*(n*r)),t.addScaledVector(s[6],.315392*(3*r*r-1)),t.addScaledVector(s[7],1.092548*(i*r)),t.addScaledVector(s[8],.546274*(i*i-n*n)),t)}// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
// target is a Vector3
// https://graphics.stanford.edu/papers/envmap/envmap.pdf
getIrradianceAt(e,t){// normal is assumed to be unit length
let i=e.x,n=e.y,r=e.z,s=this.coefficients;return(// band 0
t.copy(s[0]).multiplyScalar(.886227),// band 1
t.addScaledVector(s[1],1.023328*n),t.addScaledVector(s[2],1.023328*r),t.addScaledVector(s[3],1.023328*i),// band 2
t.addScaledVector(s[4],.858086*i*n),t.addScaledVector(s[5],.858086*n*r),t.addScaledVector(s[6],.743125*r*r-.247708),t.addScaledVector(s[7],.858086*i*r),t.addScaledVector(s[8],.429043*(i*i-n*n)),t)}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let i=0;i<9;i++)this.coefficients[i].addScaledVector(e.coefficients[i],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let i=0;i<9;i++)this.coefficients[i].lerp(e.coefficients[i],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){let i=this.coefficients;for(let n=0;n<9;n++)i[n].fromArray(e,t+3*n);return this}toArray(e=[],t=0){let i=this.coefficients;for(let n=0;n<9;n++)i[n].toArray(e,t+3*n);return e}// evaluate the basis functions
// shBasis is an Array[ 9 ]
static getBasisAt(e,t){// normal is assumed to be unit length
let i=e.x,n=e.y,r=e.z;// band 0
t[0]=.282095,// band 1
t[1]=.488603*n,t[2]=.488603*r,t[3]=.488603*i,// band 2
t[4]=1.092548*i*n,t[5]=1.092548*n*r,t[6]=.315392*(3*r*r-1),t[7]=1.092548*i*r,t[8]=.546274*(i*i-n*n)}}aC.prototype.isSphericalHarmonics3=!0;class aP extends ag{constructor(e=new aC,t=1){super(void 0,t),this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){let t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}aP.prototype.isLightProbe=!0;class aI{static decodeText(e){if("undefined"!=typeof TextDecoder)return new TextDecoder().decode(e);// Avoid the String.fromCharCode.apply(null, array) shortcut, which
// throws a "maximum call stack size exceeded" error for large arrays.
let t="";for(let i=0,n=e.length;i<n;i++)t+=String.fromCharCode(e[i]);try{// merges multi-byte utf-8 characters.
return decodeURIComponent(escape(t))}catch(e){return t}}static extractUrlBase(e){let t=e.lastIndexOf("/");return -1===t?"./":e.slice(0,t+1)}static resolveURL(e,t){return(// Invalid URL
"string"!=typeof e||""===e?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e))?e:t+e)}}(class extends td{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){let e=super.toJSON(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}).prototype.isInstancedBufferGeometry=!0;class aD extends ah{constructor(e){super(e),"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,i,n){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);let r=this,s=ao.get(e);if(void 0!==s)return r.manager.itemStart(e),setTimeout(function(){t&&t(s),r.manager.itemEnd(e)},0),s;let a={};a.credentials="anonymous"===this.crossOrigin?"same-origin":"include",a.headers=this.requestHeader,fetch(e,a).then(function(e){return e.blob()}).then(function(e){return createImageBitmap(e,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(i){ao.add(e,i),t&&t(i),r.manager.itemEnd(e)}).catch(function(t){n&&n(t),r.manager.itemError(e),r.manager.itemEnd(e)}),r.manager.itemStart(e)}}aD.prototype.isImageBitmapLoader=!0;const aN={getContext:function(){return void 0===i&&(i=new(window.AudioContext||window.webkitAudioContext)),i},setContext:function(e){i=e}};class aO extends ah{constructor(e){super(e)}load(e,t,i,n){let r=this,s=new ac(this.manager);s.setResponseType("arraybuffer"),s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(e,function(i){try{// Create a copy of the buffer. The `decodeAudioData` method
// detaches the buffer when complete, preventing reuse.
let e=i.slice(0),n=aN.getContext();n.decodeAudioData(e,function(e){t(e)})}catch(t){n?n(t):console.error(t),r.manager.itemError(e)}},i,n)}}(class extends aP{constructor(e,t,i=1){super(void 0,i);let n=new O().set(e),r=new O().set(t),s=new q(n.r,n.g,n.b),a=new q(r.r,r.g,r.b),o=Math.sqrt(Math.PI),l=o*Math.sqrt(.75);this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o),this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l)}}).prototype.isHemisphereLightProbe=!0,(class extends aP{constructor(e,t=1){super(void 0,t);let i=new O().set(e);// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
this.sh.coefficients[0].set(i.r,i.g,i.b).multiplyScalar(2*Math.sqrt(Math.PI))}}).prototype.isAmbientLightProbe=!0;class az{constructor(e,t,i){let n,r,s;// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
//
// interpolators can use .buffer as their .result
// the data then goes to 'incoming'
//
// 'accu0' and 'accu1' are used frame-interleaved for
// the cumulative result and are compared to detect
// changes
//
// 'orig' stores the original state of the property
//
// 'add' is used for additive cumulative results
//
// 'work' is optional and is only present for quaternion types. It is used
// to store intermediate quaternion multiplication results
switch(this.binding=e,this.valueSize=i,t){case"quaternion":n=this._slerp,r=this._slerpAdditive,s=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*i),this._workIndex=5;break;case"string":case"bool":n=this._select,// Use the regular mix function and for additive on these types,
// additive is not relevant for non-numeric types
r=this._select,s=this._setAdditiveIdentityOther,this.buffer=Array(5*i);break;default:n=this._lerp,r=this._lerpAdditive,s=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*i)}this._mixBufferRegion=n,this._mixBufferRegionAdditive=r,this._setIdentity=s,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}// accumulate data in the 'incoming' region into 'accu<i>'
accumulate(e,t){// note: happily accumulating nothing when weight = 0, the caller knows
// the weight and shouldn't have made the call in the first place
let i=this.buffer,n=this.valueSize,r=e*n+n,s=this.cumulativeWeight;if(0===s){// accuN := incoming * weight
for(let e=0;e!==n;++e)i[r+e]=i[e];s=t}else{// accuN := accuN + incoming * weight
s+=t;let e=t/s;this._mixBufferRegion(i,r,0,e,n)}this.cumulativeWeight=s}// accumulate data in the 'incoming' region into 'add'
accumulateAdditive(e){let t=this.buffer,i=this.valueSize,n=i*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),// add := add + incoming * weight
this._mixBufferRegionAdditive(t,n,0,e,i),this.cumulativeWeightAdditive+=e}// apply the state of 'accu<i>' to the binding when accus differ
apply(e){let t=this.valueSize,i=this.buffer,n=e*t+t,r=this.cumulativeWeight,s=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){// accuN := accuN + original * ( 1 - cumulativeWeight )
let e=t*this._origIndex;this._mixBufferRegion(i,n,e,1-r,t)}s>0&&this._mixBufferRegionAdditive(i,n,this._addIndex*t,1,t);for(let e=t,r=t+t;e!==r;++e)if(i[e]!==i[e+t]){// value has changed -> update scene graph
a.setValue(i,n);break}}// remember the state of the bound property and copy it to both accus
saveOriginalState(){let e=this.binding,t=this.buffer,i=this.valueSize,n=i*this._origIndex;e.getValue(t,n);// accu[0..1] := orig -- initially detect changes against the original
for(let e=i;e!==n;++e)t[e]=t[n+e%i];// Add to identity for additive
this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}// apply the state previously taken via 'saveOriginalState' to the binding
restoreOriginalState(){let e=3*this.valueSize;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){let e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let i=e;i<t;i++)this.buffer[i]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){let e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let i=0;i<this.valueSize;i++)this.buffer[t+i]=this.buffer[e+i]}// mix functions
_select(e,t,i,n,r){if(n>=.5)for(let n=0;n!==r;++n)e[t+n]=e[i+n]}_slerp(e,t,i,n){j.slerpFlat(e,t,e,t,e,i,n)}_slerpAdditive(e,t,i,n,r){let s=this._workIndex*r;// Store result in intermediate buffer offset
j.multiplyQuaternionsFlat(e,s,e,t,e,i),// Slerp to the intermediate result
j.slerpFlat(e,t,e,t,e,s,n)}_lerp(e,t,i,n,r){let s=1-n;for(let a=0;a!==r;++a){let r=t+a;e[r]=e[r]*s+e[i+a]*n}}_lerpAdditive(e,t,i,n,r){for(let s=0;s!==r;++s){let r=t+s;e[r]=e[r]+e[i+s]*n}}}// Characters [].:/ are reserved for track binding syntax.
const aU="\\[\\]\\.:\\/",aH=RegExp("["+aU+"]","g"),aF="[^"+aU+"]",aB="[^"+aU.replace("\\.","")+"]",aG=/((?:WC+[\/:])*)/.source.replace("WC",aF),ak=/(WCOD+)?/.source.replace("WCOD",aB),aV=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",aF),aW=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",aF),aj=RegExp("^"+aG+ak+aV+aW+"$"),aq=["material","materials","bones"];// Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.
class aX{constructor(e,t,i){this.path=t,this.parsedPath=i||aX.parseTrackName(t),this.node=aX.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,// initial state of these methods that calls 'bind'
this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,i){return e&&e.isAnimationObjectGroup?new aX.Composite(e,t,i):new aX(e,t,i)}/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(aH,"")}static parseTrackName(e){let t=aj.exec(e);if(null===t)throw Error("PropertyBinding: Cannot parse trackName: "+e);let i={// directoryName: matches[ 1 ], // (tschw) currently unused
nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},n=i.nodeName&&i.nodeName.lastIndexOf(".");if(void 0!==n&&-1!==n){let e=i.nodeName.substring(n+1);// Object names must be checked against an allowlist. Otherwise, there
// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
// 'bar' could be the objectName, or part of a nodeName (which can
// include '.' characters).
-1!==aq.indexOf(e)&&(i.nodeName=i.nodeName.substring(0,n),i.objectName=e)}if(null===i.propertyName||0===i.propertyName.length)throw Error("PropertyBinding: can not parse propertyName from trackName: "+e);return i}static findNode(e,t){if(void 0===t||""===t||"."===t||-1===t||t===e.name||t===e.uuid)return e;// search into skeleton bones.
if(e.skeleton){let i=e.skeleton.getBoneByName(t);if(void 0!==i)return i}// search into node subtree.
if(e.children){let i=function(e){for(let n=0;n<e.length;n++){let r=e[n];if(r.name===t||r.uuid===t)return r;let s=i(r.children);if(s)return s}return null},n=i(e.children);if(n)return n}return null}// these are used to "bind" a nonexistent property
_getValue_unavailable(){}_setValue_unavailable(){}// Getters
_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){let i=this.resolvedProperty;for(let n=0,r=i.length;n!==r;++n)e[t++]=i[n]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}// Direct
_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}// EntireArray
_setValue_array(e,t){let i=this.resolvedProperty;for(let n=0,r=i.length;n!==r;++n)i[n]=e[t++]}_setValue_array_setNeedsUpdate(e,t){let i=this.resolvedProperty;for(let n=0,r=i.length;n!==r;++n)i[n]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){let i=this.resolvedProperty;for(let n=0,r=i.length;n!==r;++n)i[n]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}// ArrayElement
_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}// HasToFromArray
_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}// create getter / setter pair for a property in the scene graph
bind(){let e=this.node,t=this.parsedPath,i=t.objectName,n=t.propertyName,r=t.propertyIndex;// ensure there is a value node
if(e||(e=aX.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),// set fail state so we can just 'return' on error
this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(i){let n=t.objectIndex;// special cases were we need to reach deeper into the hierarchy to get the face materials....
switch(i){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}// potential future optimization: skip this if propertyIndex is already an integer
// and convert the integer string to a true integer.
e=e.skeleton.bones;// support resolving morphTarget names into indices.
for(let t=0;t<e.length;t++)if(e[t].name===n){n=t;break}break;default:if(void 0===e[i]){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[i]}if(void 0!==n){if(void 0===e[n]){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[n]}}// resolve property
let s=e[n];if(void 0===s){let i=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+i+"."+n+" but it wasn't found.",e);return}// determine versioning scheme
let a=this.Versioning.None;this.targetObject=e,void 0!==e.needsUpdate?a=this.Versioning.NeedsUpdate:void 0!==e.matrixWorldNeedsUpdate&&(a=this.Versioning.MatrixWorldNeedsUpdate);// determine how the property gets bound
let o=this.BindingType.Direct;if(void 0!==r){// access a sub element of the property array (only primitives are supported right now)
if("morphTargetInfluences"===n){// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
// support resolving morphTarget names into indices.
if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(e.geometry.isBufferGeometry){if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}void 0!==e.morphTargetDictionary[r]&&(r=e.morphTargetDictionary[r])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}o=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=r}else void 0!==s.fromArray&&void 0!==s.toArray?(// must use copy for Object3D.Euler/Quaternion
o=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(o=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=n;// select getter / setter
this.getValue=this.GetterByBindingType[o],this.setValue=this.SetterByBindingTypeAndVersioning[o][a]}unbind(){this.node=null,// back to the prototype version of getValue / setValue
// note: avoiding to mutate the shape of 'this' via 'delete'
this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}aX.Composite=class{constructor(e,t,i){let n=i||aX.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,n)}getValue(e,t){this.bind();// bind all binding
let i=this._targetGroup.nCachedObjects_,n=this._bindings[i];// and only call .getValue on the first
void 0!==n&&n.getValue(e,t)}setValue(e,t){let i=this._bindings;for(let n=this._targetGroup.nCachedObjects_,r=i.length;n!==r;++n)i[n].setValue(e,t)}bind(){let e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,i=e.length;t!==i;++t)e[t].bind()}unbind(){let e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,i=e.length;t!==i;++t)e[t].unbind()}},aX.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},aX.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},aX.prototype.GetterByBindingType=[aX.prototype._getValue_direct,aX.prototype._getValue_array,aX.prototype._getValue_arrayElement,aX.prototype._getValue_toArray],aX.prototype.SetterByBindingTypeAndVersioning=[[// Direct
aX.prototype._setValue_direct,aX.prototype._setValue_direct_setNeedsUpdate,aX.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[// EntireArray
aX.prototype._setValue_array,aX.prototype._setValue_array_setNeedsUpdate,aX.prototype._setValue_array_setMatrixWorldNeedsUpdate],[// ArrayElement
aX.prototype._setValue_arrayElement,aX.prototype._setValue_arrayElement_setNeedsUpdate,aX.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[// HasToFromArray
aX.prototype._setValue_fromArray,aX.prototype._setValue_fromArray_setNeedsUpdate,aX.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]],/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */(class{constructor(){this.uuid=p(),// cached objects followed by the active ones
this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;// note: read by PropertyBinding.Composite
let e={};this._indicesByUUID=e;for(let t=0,i=arguments.length;t!==i;++t)e[arguments[t].uuid]=t;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};let t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){let e=this._objects,t=this._indicesByUUID,i=this._paths,n=this._parsedPaths,r=this._bindings,s=r.length,a,o=e.length,l=this.nCachedObjects_;for(let h=0,u=arguments.length;h!==u;++h){let u=arguments[h],c=u.uuid,d=t[c];if(void 0===d){// unknown object -> add it to the ACTIVE region
d=o++,t[c]=d,e.push(u);// accounting is done, now do the same for all bindings
for(let e=0;e!==s;++e)r[e].push(new aX(u,i[e],n[e]))}else if(d<l){a=e[d];// move existing object to the ACTIVE region
let o=--l,h=e[o];t[h.uuid]=d,e[d]=h,t[c]=o,e[o]=u;// accounting is done, now do the same for all bindings
for(let e=0;e!==s;++e){let t=r[e],s=t[o],a=t[d];t[d]=s,void 0===a&&// for objects that are cached, the binding may
// or may not exist
(a=new aX(u,i[e],n[e])),t[o]=a}}else e[d]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");// else the object is already where we want it to be
}// for arguments
this.nCachedObjects_=l}remove(){let e=this._objects,t=this._indicesByUUID,i=this._bindings,n=i.length,r=this.nCachedObjects_;for(let s=0,a=arguments.length;s!==a;++s){let a=arguments[s],o=a.uuid,l=t[o];if(void 0!==l&&l>=r){// move existing object into the CACHED region
let s=r++,h=e[s];t[h.uuid]=l,e[l]=h,t[o]=s,e[s]=a;// accounting is done, now do the same for all bindings
for(let e=0;e!==n;++e){let t=i[e],n=t[s],r=t[l];t[l]=n,t[s]=r}}}// for arguments
this.nCachedObjects_=r}// remove & forget
uncache(){let e=this._objects,t=this._indicesByUUID,i=this._bindings,n=i.length,r=this.nCachedObjects_,s=e.length;for(let a=0,o=arguments.length;a!==o;++a){let o=arguments[a],l=o.uuid,h=t[l];if(void 0!==h){if(delete t[l],h<r){// object is cached, shrink the CACHED region
let a=--r,o=e[a],l=--s,u=e[l];// last cached object takes this object's place
t[o.uuid]=h,e[h]=o,// last object goes to the activated slot and pop
t[u.uuid]=a,e[a]=u,e.pop();// accounting is done, now do the same for all bindings
for(let e=0;e!==n;++e){let t=i[e],n=t[a],r=t[l];t[h]=n,t[a]=r,t.pop()}}else{// object is active, just swap with the last and pop
let r=--s,a=e[r];r>0&&(t[a.uuid]=h),e[h]=a,e.pop();// accounting is done, now do the same for all bindings
for(let e=0;e!==n;++e){let t=i[e];t[h]=t[r],t.pop()}}// cached or active
}// if object is known
}// for arguments
this.nCachedObjects_=r}// Internal interface used by befriended PropertyBinding.Composite:
subscribe_(e,t){// returns an array of bindings for the given path that is changed
// according to the contained objects in the group
let i=this._bindingsIndicesByPath,n=i[e],r=this._bindings;if(void 0!==n)return r[n];let s=this._paths,a=this._parsedPaths,o=this._objects,l=o.length,h=this.nCachedObjects_,u=Array(l);n=r.length,i[e]=n,s.push(e),a.push(t),r.push(u);for(let i=h,n=o.length;i!==n;++i){let n=o[i];u[i]=new aX(n,e,t)}return u}unsubscribe_(e){// tells the group to forget about a property path and no longer
// update the array previously obtained with 'subscribe_'
let t=this._bindingsIndicesByPath,i=t[e];if(void 0!==i){let n=this._paths,r=this._parsedPaths,s=this._bindings,a=s.length-1,o=s[a],l=e[a];t[l]=i,s[i]=o,s.pop(),r[i]=r[a],r.pop(),n[i]=n[a],n.pop()}}}).prototype.isAnimationObjectGroup=!0;class aY{constructor(e,t,i=null,n=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=i,this.blendMode=n;let r=t.tracks,s=r.length,a=Array(s),o={endingStart:2400,endingEnd:2400};for(let e=0;e!==s;++e){let t=r[e].createInterpolant(null);a[e]=t,t.settings=o}this._interpolantSettings=o,this._interpolants=a,// inside: PropertyMixer (managed by the mixer)
this._propertyBindings=Array(s),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,// global mixer time when the action is to be started
// it's set back to 'null' upon start of the action
this._startTime=null,// scaled local time of the action
// gets clamped or wrapped to 0..clip.duration according to loop
this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}// State & Scheduling
play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}// return true when play has been called
isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}// Weight
// set the weight stopping any scheduled fading
// although .enabled = false yields an effective weight of zero, this
// method does *not* change .enabled, because it would be confusing
setEffectiveWeight(e){return this.weight=e,// note: same logic as when updated at runtime
this._effectiveWeight=this.enabled?e:0,this.stopFading()}// return the weight considering fading and .enabled
getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,i){if(e.fadeOut(t),this.fadeIn(t),i){let i=this._clip.duration,n=e._clip.duration;e.warp(1,n/i,t),this.warp(i/n,1,t)}return this}crossFadeTo(e,t,i){return e.crossFadeFrom(this,t,i)}stopFading(){let e=this._weightInterpolant;return null!==e&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}// Time Scale Control
// set the time scale stopping any scheduled warping
// although .paused = true yields an effective time scale of zero, this
// method does *not* change .paused, because it would be confusing
setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}// return the time scale considering warping and .paused
getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,i){let n=this._mixer,r=n.time,s=this.timeScale,a=this._timeScaleInterpolant;null===a&&(a=n._lendControlInterpolant(),this._timeScaleInterpolant=a);let o=a.parameterPositions,l=a.sampleValues;return o[0]=r,o[1]=r+i,l[0]=e/s,l[1]=t/s,this}stopWarping(){let e=this._timeScaleInterpolant;return null!==e&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}// Object Accessors
getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}// Interna
_update(e,t,i,n){// called by the mixer
if(!this.enabled){// call ._updateWeight() to update ._effectiveWeight
this._updateWeight(e);return}let r=this._startTime;if(null!==r){// check for scheduled start of action
let n=(e-r)*i;if(n<0||0===i)return;// yet to come / don't decide when delta = 0
// start
this._startTime=null,t=i*n}// apply time scale and advance time
t*=this._updateTimeScale(e);let s=this._updateTime(t),a=this._updateWeight(e);if(a>0){let e=this._interpolants,t=this._propertyBindings;if(2501===this.blendMode)for(let i=0,n=e.length;i!==n;++i)e[i].evaluate(s),t[i].accumulateAdditive(a);else for(let i=0,r=e.length;i!==r;++i)e[i].evaluate(s),t[i].accumulate(n,a)}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;let i=this._weightInterpolant;if(null!==i){let n=i.evaluate(e)[0];t*=n,e>i.parameterPositions[1]&&(this.stopFading(),0===n&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;let i=this._timeScaleInterpolant;if(null!==i){let n=i.evaluate(e)[0];t*=n,e>i.parameterPositions[1]&&(this.stopWarping(),0===t?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){let t=this._clip.duration,i=this.loop,n=this.time+e,r=this._loopCount,s=2202===i;if(0===e)return -1===r?n:s&&(1&r)==1?t-n:n;if(2200===i){-1===r&&(// just started
this._loopCount=0,this._setEndings(!0,!0,!1));r:{if(n>=t)n=t;else if(n<0)n=0;else{this.time=n;break r}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=n,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(-1===r&&(e>=0?(r=0,this._setEndings(!0,0===this.repetitions,s)):// transition through zero counts as a repetition,
// so leave loopCount at -1
this._setEndings(0===this.repetitions,!0,s)),n>=t||n<0){// wrap around
let i=Math.floor(n/t);// signed
n-=t*i,r+=Math.abs(i);let a=this.repetitions-r;if(a<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,n=e>0?t:0,this.time=n,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{// keep running
if(1===a){// entering the last round
let t=e<0;this._setEndings(t,!t,s)}else this._setEndings(!1,!1,s);this._loopCount=r,this.time=n,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:i})}}else this.time=n;if(s&&(1&r)==1)return t-n}return n}_setEndings(e,t,i){let n=this._interpolantSettings;i?(n.endingStart=2401,n.endingEnd=2401):(e?n.endingStart=this.zeroSlopeAtStart?2401:2400:n.endingStart=2402,t?n.endingEnd=this.zeroSlopeAtEnd?2401:2400:n.endingEnd=2402)}_scheduleFading(e,t,i){let n=this._mixer,r=n.time,s=this._weightInterpolant;null===s&&(s=n._lendControlInterpolant(),this._weightInterpolant=s);let a=s.parameterPositions,o=s.sampleValues;return a[0]=r,o[0]=t,a[1]=r+e,o[1]=i,this}}(class extends l{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){let i=e._localRoot||this._root,n=e._clip.tracks,r=n.length,s=e._propertyBindings,a=e._interpolants,o=i.uuid,l=this._bindingsByRootAndName,h=l[o];void 0===h&&(h={},l[o]=h);for(let e=0;e!==r;++e){let r=n[e],l=r.name,u=h[l];if(void 0!==u)++u.referenceCount,s[e]=u;else{if(void 0!==(u=s[e])){// existing binding, make sure the cache knows
null===u._cacheIndex&&(++u.referenceCount,this._addInactiveBinding(u,o,l));continue}let n=t&&t._propertyBindings[e].binding.parsedPath;u=new az(aX.create(i,l,n),r.ValueTypeName,r.getValueSize()),++u.referenceCount,this._addInactiveBinding(u,o,l),s[e]=u}a[e].resultBuffer=u.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(null===e._cacheIndex){// this action has been forgotten by the cache, but the user
// appears to be still using it -> rebind
let t=(e._localRoot||this._root).uuid,i=e._clip.uuid,n=this._actionsByClip[i];this._bindAction(e,n&&n.knownActions[0]),this._addInactiveAction(e,i,t)}let t=e._propertyBindings;// increment reference counts / sort out state
for(let e=0,i=t.length;e!==i;++e){let i=t[e];0==i.useCount++&&(this._lendBinding(i),i.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){let t=e._propertyBindings;// decrement reference counts / sort out state
for(let e=0,i=t.length;e!==i;++e){let i=t[e];0==--i.useCount&&(i.restoreOriginalState(),this._takeBackBinding(i))}this._takeBackAction(e)}}// Memory manager
_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},// inside:
// {
// 	knownActions: Array< AnimationAction > - used as prototypes
// 	actionByRoot: AnimationAction - lookup
// }
this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;let e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}// Memory management for AnimationAction objects
_isActiveAction(e){let t=e._cacheIndex;return null!==t&&t<this._nActiveActions}_addInactiveAction(e,t,i){let n=this._actions,r=this._actionsByClip,s=r[t];if(void 0===s)s={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,r[t]=s;else{let t=s.knownActions;e._byClipCacheIndex=t.length,t.push(e)}e._cacheIndex=n.length,n.push(e),s.actionByRoot[i]=e}_removeInactiveAction(e){let t=this._actions,i=t[t.length-1],n=e._cacheIndex;i._cacheIndex=n,t[n]=i,t.pop(),e._cacheIndex=null;let r=e._clip.uuid,s=this._actionsByClip,a=s[r],o=a.knownActions,l=o[o.length-1],h=e._byClipCacheIndex;l._byClipCacheIndex=h,o[h]=l,o.pop(),e._byClipCacheIndex=null;let u=a.actionByRoot,c=(e._localRoot||this._root).uuid;delete u[c],0===o.length&&delete s[r],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){let t=e._propertyBindings;for(let e=0,i=t.length;e!==i;++e){let i=t[e];0==--i.referenceCount&&this._removeInactiveBinding(i)}}_lendAction(e){// [ active actions |  inactive actions  ]
// [  active actions >| inactive actions ]
//                 s        a
//                  <-swap->
//                 a        s
let t=this._actions,i=e._cacheIndex,n=this._nActiveActions++,r=t[n];e._cacheIndex=n,t[n]=e,r._cacheIndex=i,t[i]=r}_takeBackAction(e){// [  active actions  | inactive actions ]
// [ active actions |< inactive actions  ]
//        a        s
//         <-swap->
//        s        a
let t=this._actions,i=e._cacheIndex,n=--this._nActiveActions,r=t[n];e._cacheIndex=n,t[n]=e,r._cacheIndex=i,t[i]=r}// Memory management for PropertyMixer objects
_addInactiveBinding(e,t,i){let n=this._bindingsByRootAndName,r=this._bindings,s=n[t];void 0===s&&(s={},n[t]=s),s[i]=e,e._cacheIndex=r.length,r.push(e)}_removeInactiveBinding(e){let t=this._bindings,i=e.binding,n=i.rootNode.uuid,r=i.path,s=this._bindingsByRootAndName,a=s[n],o=t[t.length-1],l=e._cacheIndex;o._cacheIndex=l,t[l]=o,t.pop(),delete a[r],0===Object.keys(a).length&&delete s[n]}_lendBinding(e){let t=this._bindings,i=e._cacheIndex,n=this._nActiveBindings++,r=t[n];e._cacheIndex=n,t[n]=e,r._cacheIndex=i,t[i]=r}_takeBackBinding(e){let t=this._bindings,i=e._cacheIndex,n=--this._nActiveBindings,r=t[n];e._cacheIndex=n,t[n]=e,r._cacheIndex=i,t[i]=r}// Memory management of Interpolants for weight and time scale
_lendControlInterpolant(){let e=this._controlInterpolants,t=this._nActiveControlInterpolants++,i=e[t];return void 0===i&&((i=new s6(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer)).__cacheIndex=t,e[t]=i),i}_takeBackControlInterpolant(e){let t=this._controlInterpolants,i=e.__cacheIndex,n=--this._nActiveControlInterpolants,r=t[n];e.__cacheIndex=n,t[n]=e,r.__cacheIndex=i,t[i]=r}// return an action for a clip optionally using a custom root target
// object (this method allocates a lot of dynamic memory in case a
// previously unknown clip/root combination is specified)
clipAction(e,t,i){let n=t||this._root,r=n.uuid,s="string"==typeof e?aa.findByName(n,e):e,a=null!==s?s.uuid:e,o=this._actionsByClip[a],l=null;if(void 0===i&&(i=null!==s?s.blendMode:2500),void 0!==o){let e=o.actionByRoot[r];if(void 0!==e&&e.blendMode===i)return e;// we know the clip, so we don't have to parse all
// the bindings again but can just copy
l=o.knownActions[0],null===s&&(s=l._clip)}// clip must be known when specified via string
if(null===s)return null;// allocate all resources required to run it
let h=new aY(this,s,t,i);return this._bindAction(h,l),// and make the action known to the memory manager
this._addInactiveAction(h,a,r),h}// get an existing action
existingAction(e,t){let i=t||this._root,n=i.uuid,r="string"==typeof e?aa.findByName(i,e):e,s=r?r.uuid:e,a=this._actionsByClip[s];return void 0!==a&&a.actionByRoot[n]||null}// deactivates all previously scheduled actions
stopAllAction(){let e=this._actions,t=this._nActiveActions;for(let i=t-1;i>=0;--i)e[i].stop();return this}// advance the time and update apply the animation
update(e){e*=this.timeScale;let t=this._actions,i=this._nActiveActions,n=this.time+=e,r=Math.sign(e),s=this._accuIndex^=1;// run active actions
for(let a=0;a!==i;++a){let i=t[a];i._update(n,e,r,s)}// update scene graph
let a=this._bindings,o=this._nActiveBindings;for(let e=0;e!==o;++e)a[e].apply(s);return this}// Allows you to seek to a specific time in an animation.
setTime(e){this.time=0;// Zero out time attribute for AnimationMixer object;
for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;// Zero out time attribute for all associated AnimationAction objects.
return this.update(e);// Update used to set exact time. Returns "this" AnimationMixer object.
}// return this mixer's root target object
getRoot(){return this._root}// free all resources specific to a particular clip
uncacheClip(e){let t=this._actions,i=e.uuid,n=this._actionsByClip,r=n[i];if(void 0!==r){// note: just calling _removeInactiveAction would mess up the
// iteration state and also require updating the state we can
// just throw away
let e=r.knownActions;for(let i=0,n=e.length;i!==n;++i){let n=e[i];this._deactivateAction(n);let r=n._cacheIndex,s=t[t.length-1];n._cacheIndex=null,n._byClipCacheIndex=null,s._cacheIndex=r,t[r]=s,t.pop(),this._removeInactiveBindingsForAction(n)}delete n[i]}}// free all resources specific to a particular root target object
uncacheRoot(e){let t=e.uuid,i=this._actionsByClip;for(let e in i){let n=i[e].actionByRoot,r=n[t];void 0!==r&&(this._deactivateAction(r),this._removeInactiveAction(r))}let n=this._bindingsByRootAndName,r=n[t];if(void 0!==r)for(let e in r){let t=r[e];t.restoreOriginalState(),this._removeInactiveBinding(t)}}// remove a targeted clip from the cache
uncacheAction(e,t){let i=this.existingAction(e,t);null!==i&&(this._deactivateAction(i),this._removeInactiveAction(i))}}).prototype._controlInterpolantsResultBuffer=new Float32Array(1);class aJ{constructor(e){"string"==typeof e&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),e=arguments[1]),this.value=e}clone(){return new aJ(void 0===this.value.clone?this.value:this.value.clone())}}(class extends re{constructor(e,t,i=1){super(e,t),this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){let t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){let t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}).prototype.isInstancedInterleavedBuffer=!0,(class{constructor(e,t,i,n,r){this.buffer=e,this.type=t,this.itemSize=i,this.elementSize=n,this.count=r,this.version=0}set needsUpdate(e){!0===e&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,t){return this.type=e,this.elementSize=t,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}).prototype.isGLBufferAttribute=!0;/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */class aZ{constructor(e=1,t=0,i=0){return this.radius=e,this.phi=t,this.theta=i,this}set(e,t,i){return this.radius=e,this.phi=t,this.theta=i,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}// restrict phi to be between EPS and PI-EPS
makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,i){return this.radius=Math.sqrt(e*e+t*t+i*i),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,i),this.phi=Math.acos(m(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}const aK=/*@__PURE__*/new b;class aQ{constructor(e=new b(1/0,1/0),t=new b(-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){let i=aK.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(i),this.max.copy(e).add(i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x)&&!(e.x>this.max.x)&&!(e.y<this.min.y)&&!(e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){// This can potentially have a divide by zero if the box
// has a size dimension of 0.
return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){// using 4 splitting planes to rule out intersections
return!(e.max.x<this.min.x)&&!(e.min.x>this.max.x)&&!(e.max.y<this.min.y)&&!(e.min.y>this.max.y)}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){let t=aK.copy(e).clamp(this.min,this.max);return t.sub(e).length()}intersect(e){return this.min.max(e.min),this.max.min(e.max),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}aQ.prototype.isBox2=!0;const a$=/*@__PURE__*/new q,a0=/*@__PURE__*/new q,a1=/*@__PURE__*/new q,a3=/*@__PURE__*/new ew,a2=/*@__PURE__*/new ew;// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
class a4{// float32 to float16
static toHalfFloat(e){Math.abs(e)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),e=m(e,-65504,65504),a6[0]=e;let t=a8[0],i=t>>23&511;return a7[i]+((8388607&t)>>a9[i])}// float16 to float32
static fromHalfFloat(e){let t=e>>10;return a8[0]=oe[oi[t]+(1023&e)]+ot[t],a6[0]}}// float32 to float16 helpers
const a5=new ArrayBuffer(4),a6=new Float32Array(a5),a8=new Uint32Array(a5),a7=new Uint32Array(512),a9=new Uint32Array(512);for(let e=0;e<256;++e){let t=e-127;// very small number (0, -0)
t<-27?(a7[e]=0,a7[256|e]=32768,a9[e]=24,a9[256|e]=24):t<-14?(a7[e]=1024>>-t-14,a7[256|e]=1024>>-t-14|32768,a9[e]=-t-1,a9[256|e]=-t-1):t<=15?(a7[e]=t+15<<10,a7[256|e]=t+15<<10|32768,a9[e]=13,a9[256|e]=13):t<128?(a7[e]=31744,a7[256|e]=64512,a9[e]=24,a9[256|e]=24):(a7[e]=31744,a7[256|e]=64512,a9[e]=13,a9[256|e]=13)}// float16 to float32 helpers
const oe=new Uint32Array(2048),ot=new Uint32Array(64),oi=new Uint32Array(64);for(let e=1;e<1024;++e){let t=e<<13,i=0;// zero pad mantissa bits
// normalized
for(;(8388608&t)==0;)t<<=1,i-=8388608;t&=-8388609,i+=947912704,oe[e]=t|i}for(let e=1024;e<2048;++e)oe[e]=939524096+(e-1024<<13);for(let e=1;e<31;++e)ot[e]=e<<23;ot[31]=1199570944,ot[32]=2147483648;for(let e=33;e<63;++e)ot[e]=2147483648+(e-32<<23);ot[63]=3347054592;for(let e=1;e<64;++e)32!==e&&(oi[e]=1024);//
rK.create=function(e,t){return console.log("THREE.Curve.create() has been deprecated"),e.prototype=Object.create(rK.prototype),e.prototype.constructor=e,e.prototype.getPoint=t,e},//
so.prototype.fromPoints=function(e){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(e)},(class extends rk{constructor(e=10,t=10,i=4473924,n=8947848){i=new O(i),n=new O(n);let r=t/2,s=e/t,a=e/2,o=[],l=[];for(let e=0,h=0,u=-a;e<=t;e++,u+=s){o.push(-a,0,u,a,0,u),o.push(u,0,-a,u,0,a);let t=e===r?i:n;t.toArray(l,h),h+=3,t.toArray(l,h),h+=3,t.toArray(l,h),h+=3,t.toArray(l,h),h+=3}let h=new td;h.setAttribute("position",new tr(o,3)),h.setAttribute("color",new tr(l,3));let u=new rD({vertexColors:!0,toneMapped:!1});super(h,u),this.type="GridHelper"}}).prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},(class extends rk{constructor(e){let t=function e(t){let i=[];!0===t.isBone&&i.push(t);for(let n=0;n<t.children.length;n++)i.push.apply(i,e(t.children[n]));return i}(e),i=new td,n=[],r=[],s=new O(0,0,1),a=new O(0,1,0);for(let e=0;e<t.length;e++){let i=t[e];i.parent&&i.parent.isBone&&(n.push(0,0,0),n.push(0,0,0),r.push(s.r,s.g,s.b),r.push(a.r,a.g,a.b))}i.setAttribute("position",new tr(n,3)),i.setAttribute("color",new tr(r,3));let o=new rD({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(i,o),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){let t=this.bones,i=this.geometry,n=i.getAttribute("position");a2.copy(this.root.matrixWorld).invert();for(let e=0,i=0;e<t.length;e++){let r=t[e];r.parent&&r.parent.isBone&&(a3.multiplyMatrices(a2,r.matrixWorld),a1.setFromMatrixPosition(a3),n.setXYZ(i,a1.x,a1.y,a1.z),a3.multiplyMatrices(a2,r.parent.matrixWorld),a1.setFromMatrixPosition(a3),n.setXYZ(i+1,a1.x,a1.y,a1.z),i+=2)}i.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}).prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},//
ah.prototype.extractUrlBase=function(e){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),aI.extractUrlBase(e)},ah.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},//
aQ.prototype.center=function(e){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(e)},aQ.prototype.empty=function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},aQ.prototype.isIntersectionBox=function(e){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},aQ.prototype.size=function(e){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(e)},//
J.prototype.center=function(e){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(e)},J.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},J.prototype.isIntersectionBox=function(e){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},J.prototype.isIntersectionSphere=function(e){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)},J.prototype.size=function(e){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(e)},//
eD.prototype.toVector3=function(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")},//
em.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()},//
tY.prototype.setFromMatrix=function(e){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(e)},//
(class{constructor(e=new q,t=new q){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){a$.subVectors(e,this.start),a0.subVectors(this.end,this.start);let i=a0.dot(a0),n=a0.dot(a$),r=n/i;return t&&(r=m(r,0,1)),r}closestPointToPoint(e,t,i){let n=this.closestPointToPointParameter(e,t);return this.delta(i).multiplyScalar(n).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}).prototype.center=function(e){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(e)},//
M.prototype.flattenToArrayOffset=function(e,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,t)},M.prototype.multiplyVector3=function(e){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},M.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},M.prototype.applyToBufferAttribute=function(e){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},M.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},M.prototype.getInverse=function(e){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(e).invert()},//
ew.prototype.extractPosition=function(e){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(e)},ew.prototype.flattenToArrayOffset=function(e,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,t)},ew.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new q().setFromMatrixColumn(this,3)},ew.prototype.setRotationFromQuaternion=function(e){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(e)},ew.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},ew.prototype.multiplyVector3=function(e){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},ew.prototype.multiplyVector4=function(e){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},ew.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},ew.prototype.rotateAxis=function(e){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),e.transformDirection(this)},ew.prototype.crossVector=function(e){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},ew.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")},ew.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},ew.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},ew.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},ew.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},ew.prototype.applyToBufferAttribute=function(e){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},ew.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},ew.prototype.makeFrustum=function(e,t,i,n,r,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(e,t,n,i,r,s)},ew.prototype.getInverse=function(e){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(e).invert()},//
tj.prototype.isIntersectionLine=function(e){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(e)},//
j.prototype.multiplyVector3=function(e){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),e.applyQuaternion(this)},j.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()},//
eM.prototype.isIntersectionBox=function(e){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},eM.prototype.isIntersectionPlane=function(e){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(e)},eM.prototype.isIntersectionSphere=function(e){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)},//
e5.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},e5.prototype.barycoordFromPoint=function(e,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(e,t)},e5.prototype.midpoint=function(e){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(e)},e5.prototypenormal=function(e){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(e)},e5.prototype.plane=function(e){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(e)},e5.barycoordFromPoint=function(e,t,i,n,r){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),e5.getBarycoord(e,t,i,n,r)},e5.normal=function(e,t,i,n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),e5.getNormal(e,t,i,n)},//
sf.prototype.extractAllPoints=function(e){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(e)},sf.prototype.extrude=function(e){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new sO(this,e)},sf.prototype.makeGeometry=function(e){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new sB(this,e)},//
b.prototype.fromAttribute=function(e,t,i){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,i)},b.prototype.distanceToManhattan=function(e){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},b.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},//
q.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},q.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},q.prototype.getPositionFromMatrix=function(e){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(e)},q.prototype.getScaleFromMatrix=function(e){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(e)},q.prototype.getColumnFromMatrix=function(e,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,e)},q.prototype.applyProjection=function(e){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(e)},q.prototype.fromAttribute=function(e,t,i){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,i)},q.prototype.distanceToManhattan=function(e){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},q.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},//
G.prototype.fromAttribute=function(e,t,i){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,i)},G.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},//
eY.prototype.getChildByName=function(e){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(e)},eY.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},eY.prototype.translate=function(e,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,e)},eY.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},eY.prototype.applyMatrix=function(e){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)},Object.defineProperties(eY.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(e){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=e}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),tC.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")},Object.defineProperties(tC.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),0},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),rM.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},//
tH.prototype.setLens=function(e,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),void 0!==t&&(this.filmGauge=t),this.setFocalLength(e)},//
Object.defineProperties(ag.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(e){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=e}},shadowCameraLeft:{set:function(e){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=e}},shadowCameraRight:{set:function(e){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=e}},shadowCameraTop:{set:function(e){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=e}},shadowCameraBottom:{set:function(e){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=e}},shadowCameraNear:{set:function(e){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=e}},shadowCameraFar:{set:function(e){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=e}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(e){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=e}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(e){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=e}},shadowMapHeight:{set:function(e){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=e}}}),//
Object.defineProperties(tt.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),35048===this.usage},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(35048)}}}),tt.prototype.setDynamic=function(e){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===e?35048:35044),this},tt.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},tt.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},//
td.prototype.addIndex=function(e){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(e)},td.prototype.addAttribute=function(e,t){return(console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),t&&t.isBufferAttribute||t&&t.isInterleavedBufferAttribute)?"index"===e?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(e,t):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(e,new tt(arguments[1],arguments[2])))},td.prototype.addDrawCall=function(e,t,i){void 0!==i&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(e,t)},td.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},td.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},td.prototype.removeAttribute=function(e){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(e)},td.prototype.applyMatrix=function(e){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)},Object.defineProperties(td.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),re.prototype.setDynamic=function(e){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===e?35048:35044),this},re.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},//
sO.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},sO.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},sO.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")},//
n9.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")},//
aJ.prototype.onUpdate=function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this},//
Object.defineProperties(e8.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new O}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===e}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(e){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=e}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}}),Object.defineProperties(tz.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(e){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=e}}}),//
n6.prototype.clearTarget=function(e,t,i,n){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(e),this.clear(t,i,n)},n6.prototype.animate=function(e){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(e)},n6.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},n6.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},n6.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},n6.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},n6.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},n6.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},n6.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},n6.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},n6.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},n6.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},n6.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},n6.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},n6.prototype.enableScissorTest=function(e){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(e)},n6.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},n6.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},n6.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},n6.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},n6.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},n6.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},n6.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},n6.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},n6.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},n6.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()},Object.defineProperties(n6.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=e}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=e}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(e){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=!0===e?3001:3e3}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}},gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}}),Object.defineProperties(nJ.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),//
Object.defineProperties(k.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=e}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=e}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=e}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=e}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(e){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=e}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(e){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=e}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(e){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=e}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(e){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=e}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(e){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=e}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(e){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=e}}}),//
(class extends eY{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(!0===this.isPlaying){console.warn("THREE.Audio: Audio is already playing.");return}if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;let t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}return!0===this.isPlaying&&(// update current progress
this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),!0===this._connected?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this;// only set detune when available
}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,!0===this.isPlaying&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}).prototype.load=function(e){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");let t=this,i=new aO;return i.load(e,function(e){t.setBuffer(e)}),this},(class{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0,t=this.getFrequencyData();for(let i=0;i<t.length;i++)e+=t[i];return e/t.length}}).prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},//
tF.prototype.updateCubeMap=function(e,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(e,t)},tF.prototype.clear=function(e,t,i,n){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(e,t,i,n)},z.crossOrigin=void 0,z.loadTexture=function(e,t,i,n){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");let r=new af;r.setCrossOrigin(this.crossOrigin);let s=r.load(e,i,void 0,n);return t&&(s.mapping=t),s},z.loadTextureCube=function(e,t,i,n){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");let r=new ap;r.setCrossOrigin(this.crossOrigin);let s=r.load(e,i,void 0,n);return t&&(s.mapping=t),s},z.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},z.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:"139"}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__="139");// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move
const on={type:"change"},or={type:"start"},os={type:"end"};/* GLTFREGISTRY */function oa(){let e={};return{get:function(t){return e[t]},add:function(t,i){e[t]=i},remove:function(t){delete e[t]},removeAll:function(){e={}}}}/*********************************//********** EXTENSIONS ***********//*********************************/const oo={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */class ol{constructor(e){this.parser=e,this.name=oo.KHR_LIGHTS_PUNCTUAL,// Object3D instance caches
this.cache={refs:{},uses:{}}}_markDefs(){let e=this.parser,t=this.parser.json.nodes||[];for(let i=0,n=t.length;i<n;i++){let n=t[i];n.extensions&&n.extensions[this.name]&&void 0!==n.extensions[this.name].light&&e._addNodeRef(this.cache,n.extensions[this.name].light)}}_loadLight(e){let t;let i=this.parser,n="light:"+e,r=i.cache.get(n);if(r)return r;let s=i.json,a=s.extensions&&s.extensions[this.name]||{},o=a.lights||[],l=o[e],h=new O(16777215);void 0!==l.color&&h.fromArray(l.color);let u=void 0!==l.range?l.range:0;switch(l.type){case"directional":(t=new aL(h)).target.position.set(0,0,-1),t.add(t.target);break;case"point":(t=new aA(h)).distance=u;break;case"spot":(t=new aM(h)).distance=u,// Handle spotlight properties.
l.spot=l.spot||{},l.spot.innerConeAngle=void 0!==l.spot.innerConeAngle?l.spot.innerConeAngle:0,l.spot.outerConeAngle=void 0!==l.spot.outerConeAngle?l.spot.outerConeAngle:Math.PI/4,t.angle=l.spot.outerConeAngle,t.penumbra=1-l.spot.innerConeAngle/l.spot.outerConeAngle,t.target.position.set(0,0,-1),t.add(t.target);break;default:throw Error("THREE.GLTFLoader: Unexpected light type: "+l.type)}return(// Some lights (e.g. spot) default to a position other than the origin. Reset the position
// here, because node-level parsing will only override position if explicitly specified.
t.position.set(0,0,0),t.decay=2,void 0!==l.intensity&&(t.intensity=l.intensity),t.name=i.createUniqueName(l.name||"light_"+e),r=Promise.resolve(t),i.cache.add(n,r),r)}createNodeAttachment(e){let t=this,i=this.parser,n=i.json,r=n.nodes[e],s=r.extensions&&r.extensions[this.name]||{},a=s.light;return void 0===a?null:this._loadLight(a).then(function(e){return i._getNodeRef(t.cache,a,e)})}}/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */class oh{constructor(){this.name=oo.KHR_MATERIALS_UNLIT}getMaterialType(){return e7}extendParams(e,t,i){let n=[];e.color=new O(1,1,1),e.opacity=1;let r=t.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){let t=r.baseColorFactor;e.color.fromArray(t),e.opacity=t[3]}void 0!==r.baseColorTexture&&n.push(i.assignTexture(e,"map",r.baseColorTexture,3001))}return Promise.all(n)}}/**
 * Clearcoat Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
 */class ou{constructor(e){this.parser=e,this.name=oo.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){let t=this.parser,i=t.json.materials[e];return i.extensions&&i.extensions[this.name]?sJ:null}extendMaterialParams(e,t){let i=this.parser,n=i.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();let r=[],s=n.extensions[this.name];if(void 0!==s.clearcoatFactor&&(t.clearcoat=s.clearcoatFactor),void 0!==s.clearcoatTexture&&r.push(i.assignTexture(t,"clearcoatMap",s.clearcoatTexture)),void 0!==s.clearcoatRoughnessFactor&&(t.clearcoatRoughness=s.clearcoatRoughnessFactor),void 0!==s.clearcoatRoughnessTexture&&r.push(i.assignTexture(t,"clearcoatRoughnessMap",s.clearcoatRoughnessTexture)),void 0!==s.clearcoatNormalTexture&&(r.push(i.assignTexture(t,"clearcoatNormalMap",s.clearcoatNormalTexture)),void 0!==s.clearcoatNormalTexture.scale)){let e=s.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new b(e,e)}return Promise.all(r)}}/**
 * Sheen Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
 */class oc{constructor(e){this.parser=e,this.name=oo.KHR_MATERIALS_SHEEN}getMaterialType(e){let t=this.parser,i=t.json.materials[e];return i.extensions&&i.extensions[this.name]?sJ:null}extendMaterialParams(e,t){let i=this.parser,n=i.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();let r=[];t.sheenColor=new O(0,0,0),t.sheenRoughness=0,t.sheen=1;let s=n.extensions[this.name];return void 0!==s.sheenColorFactor&&t.sheenColor.fromArray(s.sheenColorFactor),void 0!==s.sheenRoughnessFactor&&(t.sheenRoughness=s.sheenRoughnessFactor),void 0!==s.sheenColorTexture&&r.push(i.assignTexture(t,"sheenColorMap",s.sheenColorTexture,3001)),void 0!==s.sheenRoughnessTexture&&r.push(i.assignTexture(t,"sheenRoughnessMap",s.sheenRoughnessTexture)),Promise.all(r)}}/**
 * Transmission Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
 */class od{constructor(e){this.parser=e,this.name=oo.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){let t=this.parser,i=t.json.materials[e];return i.extensions&&i.extensions[this.name]?sJ:null}extendMaterialParams(e,t){let i=this.parser,n=i.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();let r=[],s=n.extensions[this.name];return void 0!==s.transmissionFactor&&(t.transmission=s.transmissionFactor),void 0!==s.transmissionTexture&&r.push(i.assignTexture(t,"transmissionMap",s.transmissionTexture)),Promise.all(r)}}/**
 * Materials Volume Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
 */class op{constructor(e){this.parser=e,this.name=oo.KHR_MATERIALS_VOLUME}getMaterialType(e){let t=this.parser,i=t.json.materials[e];return i.extensions&&i.extensions[this.name]?sJ:null}extendMaterialParams(e,t){let i=this.parser,n=i.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();let r=[],s=n.extensions[this.name];t.thickness=void 0!==s.thicknessFactor?s.thicknessFactor:0,void 0!==s.thicknessTexture&&r.push(i.assignTexture(t,"thicknessMap",s.thicknessTexture)),t.attenuationDistance=s.attenuationDistance||0;let a=s.attenuationColor||[1,1,1];return t.attenuationColor=new O(a[0],a[1],a[2]),Promise.all(r)}}/**
 * Materials ior Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
 */class om{constructor(e){this.parser=e,this.name=oo.KHR_MATERIALS_IOR}getMaterialType(e){let t=this.parser,i=t.json.materials[e];return i.extensions&&i.extensions[this.name]?sJ:null}extendMaterialParams(e,t){let i=this.parser,n=i.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();let r=n.extensions[this.name];return t.ior=void 0!==r.ior?r.ior:1.5,Promise.resolve()}}/**
 * Materials specular Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
 */class of{constructor(e){this.parser=e,this.name=oo.KHR_MATERIALS_SPECULAR}getMaterialType(e){let t=this.parser,i=t.json.materials[e];return i.extensions&&i.extensions[this.name]?sJ:null}extendMaterialParams(e,t){let i=this.parser,n=i.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();let r=[],s=n.extensions[this.name];t.specularIntensity=void 0!==s.specularFactor?s.specularFactor:1,void 0!==s.specularTexture&&r.push(i.assignTexture(t,"specularIntensityMap",s.specularTexture));let a=s.specularColorFactor||[1,1,1];return t.specularColor=new O(a[0],a[1],a[2]),void 0!==s.specularColorTexture&&r.push(i.assignTexture(t,"specularColorMap",s.specularColorTexture,3001)),Promise.all(r)}}/**
 * BasisU Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
 */class og{constructor(e){this.parser=e,this.name=oo.KHR_TEXTURE_BASISU}loadTexture(e){let t=this.parser,i=t.json,n=i.textures[e];if(!n.extensions||!n.extensions[this.name])return null;let r=n.extensions[this.name],s=t.options.ktx2Loader;if(!s){if(!(i.extensionsRequired&&i.extensionsRequired.indexOf(this.name)>=0))return null;throw Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures")}return t.loadTextureImage(e,r.source,s)}}/**
 * WebP Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
 */class ov{constructor(e){this.parser=e,this.name=oo.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){let t=this.name,i=this.parser,n=i.json,r=n.textures[e];if(!r.extensions||!r.extensions[t])return null;let s=r.extensions[t],a=n.images[s.source],o=i.textureLoader;if(a.uri){let e=i.options.manager.getHandler(a.uri);null!==e&&(o=e)}return this.detectSupport().then(function(r){if(r)return i.loadTextureImage(e,s.source,o);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw Error("THREE.GLTFLoader: WebP required by asset but unsupported.");// Fall back to PNG or JPEG.
return i.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){let t=new Image;// Lossy test image. Support for lossy images doesn't guarantee support for all
// WebP images, unfortunately.
t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(1===t.height)}})),this.isSupported}}/**
 * meshopt BufferView Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
 */class ox{constructor(e){this.name=oo.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){let t=this.parser.json,i=t.bufferViews[e];if(!i.extensions||!i.extensions[this.name])return null;{let e=i.extensions[this.name],n=this.parser.getDependency("buffer",e.buffer),r=this.parser.options.meshoptDecoder;if(!r||!r.supported){if(!(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0))return null;throw Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files")}return Promise.all([n,r.ready]).then(function(t){let i=e.byteOffset||0,n=e.byteLength||0,s=e.count,a=e.byteStride,o=new ArrayBuffer(s*a),l=new Uint8Array(t[0],i,n);return r.decodeGltfBuffer(new Uint8Array(o),s,a,l,e.mode,e.filter),o})}}}/* BINARY EXTENSION */const oy="glTF",o_={JSON:1313821514,BIN:5130562};class ob{constructor(e){this.name=oo.KHR_BINARY_GLTF,this.content=null,this.body=null;let t=new DataView(e,0,12);if(this.header={magic:aI.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==oy)throw Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw Error("THREE.GLTFLoader: Legacy binary file detected.");let i=this.header.length-12,n=new DataView(e,12),r=0;for(;r<i;){let t=n.getUint32(r,!0);r+=4;let i=n.getUint32(r,!0);if(r+=4,i===o_.JSON){let i=new Uint8Array(e,12+r,t);this.content=aI.decodeText(i)}else if(i===o_.BIN){let i=12+r;this.body=e.slice(i,i+t)}// Clients must ignore chunks with unknown types.
r+=t}if(null===this.content)throw Error("THREE.GLTFLoader: JSON content not found.")}}/**
 * DRACO Mesh Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
 */class oM{constructor(e,t){if(!t)throw Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=oo.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){let i=this.json,n=this.dracoLoader,r=e.extensions[this.name].bufferView,s=e.extensions[this.name].attributes,a={},o={},l={};for(let e in s){let t=oO[e]||e.toLowerCase();a[t]=s[e]}for(let t in e.attributes){let n=oO[t]||t.toLowerCase();if(void 0!==s[t]){let r=i.accessors[e.attributes[t]],s=oP[r.componentType];l[n]=s,o[n]=!0===r.normalized}}return t.getDependency("bufferView",r).then(function(e){return new Promise(function(t){n.decodeDracoFile(e,function(e){for(let t in e.attributes){let i=e.attributes[t],n=o[t];void 0!==n&&(i.normalized=n)}t(e)},a,l)})})}}/**
 * Texture Transform Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
 */class ow{constructor(){this.name=oo.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return void 0!==t.texCoord&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),void 0===t.offset&&void 0===t.rotation&&void 0===t.scale||(e=e.clone(),void 0!==t.offset&&e.offset.fromArray(t.offset),void 0!==t.rotation&&(e.rotation=t.rotation),void 0!==t.scale&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}/**
 * Specular-Glossiness Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness
 *//**
 * A sub class of StandardMaterial with some of the functionality
 * changed via the `onBeforeCompile` callback
 * @pailhead
 */class oS extends sY{constructor(e){super(),this.isGLTFSpecularGlossinessMaterial=!0;let t={specular:{value:new O().setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=t,this.onBeforeCompile=function(e){for(let i in t)e.uniforms[i]=t[i];e.fragmentShader=e.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>","#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif").replace("#include <metalnessmap_pars_fragment>","#ifdef USE_GLOSSINESSMAP\n	uniform sampler2D glossinessMap;\n#endif").replace("#include <roughnessmap_fragment>","vec3 specularFactor = specular;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture\n	specularFactor *= texelSpecular.rgb;\n#endif").replace("#include <metalnessmap_fragment>","float glossinessFactor = glossiness;\n#ifdef USE_GLOSSINESSMAP\n	vec4 texelGlossiness = texture2D( glossinessMap, vUv );\n	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture\n	glossinessFactor *= texelGlossiness.a;\n#endif").replace("#include <lights_physical_fragment>","PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.\nmaterial.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\nmaterial.specularColor = specularFactor;")},Object.defineProperties(this,{specular:{get:function(){return t.specular.value},set:function(e){t.specular.value=e}},specularMap:{get:function(){return t.specularMap.value},set:function(e){t.specularMap.value=e,e?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return t.glossiness.value},set:function(e){t.glossiness.value=e}},glossinessMap:{get:function(){return t.glossinessMap.value},set:function(e){t.glossinessMap.value=e,e?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(e)}copy(e){return super.copy(e),this.specularMap=e.specularMap,this.specular.copy(e.specular),this.glossinessMap=e.glossinessMap,this.glossiness=e.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class oT{constructor(){this.name=oo.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity"]}getMaterialType(){return oS}extendParams(e,t,i){let n=t.extensions[this.name];e.color=new O(1,1,1),e.opacity=1;let r=[];if(Array.isArray(n.diffuseFactor)){let t=n.diffuseFactor;e.color.fromArray(t),e.opacity=t[3]}if(void 0!==n.diffuseTexture&&r.push(i.assignTexture(e,"map",n.diffuseTexture,3001)),e.emissive=new O(0,0,0),e.glossiness=void 0!==n.glossinessFactor?n.glossinessFactor:1,e.specular=new O(1,1,1),Array.isArray(n.specularFactor)&&e.specular.fromArray(n.specularFactor),void 0!==n.specularGlossinessTexture){let t=n.specularGlossinessTexture;r.push(i.assignTexture(e,"glossinessMap",t)),r.push(i.assignTexture(e,"specularMap",t,3001))}return Promise.all(r)}createMaterial(e){let t=new oS(e);return t.fog=!0,t.color=e.color,t.map=void 0===e.map?null:e.map,t.lightMap=null,t.lightMapIntensity=1,t.aoMap=void 0===e.aoMap?null:e.aoMap,t.aoMapIntensity=1,t.emissive=e.emissive,t.emissiveIntensity=1,t.emissiveMap=void 0===e.emissiveMap?null:e.emissiveMap,t.bumpMap=void 0===e.bumpMap?null:e.bumpMap,t.bumpScale=1,t.normalMap=void 0===e.normalMap?null:e.normalMap,t.normalMapType=0,e.normalScale&&(t.normalScale=e.normalScale),t.displacementMap=null,t.displacementScale=1,t.displacementBias=0,t.specularMap=void 0===e.specularMap?null:e.specularMap,t.specular=e.specular,t.glossinessMap=void 0===e.glossinessMap?null:e.glossinessMap,t.glossiness=e.glossiness,t.alphaMap=null,t.envMap=void 0===e.envMap?null:e.envMap,t.envMapIntensity=1,t}}/**
 * Mesh Quantization Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
 */class oE{constructor(){this.name=oo.KHR_MESH_QUANTIZATION}}/*********************************//********** INTERPOLATION ********//*********************************/// Spline Interpolation
// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
class oA extends s4{constructor(e,t,i,n){super(e,t,i,n)}copySampleValue_(e){// Copies a sample value to the result buffer. See description of glTF
// CUBICSPLINE values layout in interpolate_() function below.
let t=this.resultBuffer,i=this.sampleValues,n=this.valueSize,r=e*n*3+n;for(let e=0;e!==n;e++)t[e]=i[r+e];return t}}oA.prototype.beforeStart_=oA.prototype.copySampleValue_,oA.prototype.afterEnd_=oA.prototype.copySampleValue_,oA.prototype.interpolate_=function(e,t,i,n){let r=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=2*a,l=3*a,h=n-t,u=(i-t)/h,c=u*u,d=c*u,p=e*l,m=p-l,f=-2*d+3*c,g=d-c,v=1-f,x=g-c+u;// Layout of keyframe output values for CUBICSPLINE animations:
//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
for(let e=0;e!==a;e++){let t=s[m+e+a],i=s[m+e+o]*h,n=s[p+e+a],l=s[p+e]*h;// splineVertex_k
r[e]=v*t+x*i+f*n+g*l}return r};const oR=new j;class oL extends oA{interpolate_(e,t,i,n){let r=super.interpolate_(e,t,i,n);return oR.fromArray(r).normalize().toArray(r),r}}/*********************************//********** INTERNALS ************//*********************************//* CONSTANTS */const oC={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},oP={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},oI={9728:1003,9729:1006,9984:1004,9985:1007,9986:1005,9987:1008},oD={33071:1001,33648:1002,10497:1e3},oN={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},oO={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},oz={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},oU={CUBICSPLINE:void 0,// keyframe track will be initialized with a default interpolation type, then modified.
LINEAR:2301,STEP:2300},oH={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function oF(e,t,i){// Add unknown glTF extensions to an object's userData.
for(let n in i.extensions)void 0===e[n]&&(t.userData.gltfExtensions=t.userData.gltfExtensions||{},t.userData.gltfExtensions[n]=i.extensions[n])}/**
 * @param {Object3D|Material|BufferGeometry} object
 * @param {GLTF.definition} gltfDef
 */function oB(e,t){void 0!==t.extras&&("object"==typeof t.extras?Object.assign(e.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}function oG(e){let t="",i=Object.keys(e).sort();for(let n=0,r=i.length;n<r;n++)t+=i[n]+":"+e[i[n]]+";";return t}function ok(e){// Reference:
// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data
switch(e){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}/* GLTF PARSER */class oV{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,// loader object cache
this.cache=new oa,// associations between Three.js objects and glTF elements
this.associations=new Map,// BufferGeometry caching
this.primitiveCache={},// Object3D instance caches
this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},// Track node names, to ensure no duplicates
this.nodeNamesUsed={},"undefined"!=typeof createImageBitmap&&!1===/^((?!chrome|android).)*safari/i.test(navigator.userAgent)?this.textureLoader=new aD(this.options.manager):this.textureLoader=new af(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new ac(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){let i=this,n=this.json,r=this.extensions;// Clear the loader cache
this.cache.removeAll(),// Mark the special nodes/meshes in json for efficient parse
this._invokeAll(function(e){return e._markDefs&&e._markDefs()}),Promise.all(this._invokeAll(function(e){return e.beforeRoot&&e.beforeRoot()})).then(function(){return Promise.all([i.getDependencies("scene"),i.getDependencies("animation"),i.getDependencies("camera")])}).then(function(t){let s={scene:t[0][n.scene||0],scenes:t[0],animations:t[1],cameras:t[2],asset:n.asset,parser:i,userData:{}};oF(r,s,n),oB(s,n),Promise.all(i._invokeAll(function(e){return e.afterRoot&&e.afterRoot(s)})).then(function(){e(s)})}).catch(t)}/**
	 * Marks the special nodes/meshes in json for efficient parse.
	 */_markDefs(){let e=this.json.nodes||[],t=this.json.skins||[],i=this.json.meshes||[];// Nothing in the node definition indicates whether it is a Bone or an
// Object3D. Use the skins' joint references to mark bones.
for(let i=0,n=t.length;i<n;i++){let n=t[i].joints;for(let t=0,i=n.length;t<i;t++)e[n[t]].isBone=!0}// Iterate over all nodes, marking references to shared resources,
// as well as skeleton joints.
for(let t=0,n=e.length;t<n;t++){let n=e[t];void 0!==n.mesh&&(this._addNodeRef(this.meshCache,n.mesh),void 0!==n.skin&&(i[n.mesh].isSkinnedMesh=!0)),void 0!==n.camera&&this._addNodeRef(this.cameraCache,n.camera)}}/**
	 * Counts references to shared node / Object3D resources. These resources
	 * can be reused, or "instantiated", at multiple nodes in the scene
	 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
	 * be marked. Non-scenegraph resources (like Materials, Geometries, and
	 * Textures) can be reused directly and are not marked here.
	 *
	 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
	 */_addNodeRef(e,t){void 0!==t&&(void 0===e.refs[t]&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}/** Returns a reference to a shared resource, cloning it if necessary. */_getNodeRef(e,t,i){if(e.refs[t]<=1)return i;let n=i.clone(),r=(e,t)=>{let i=this.associations.get(e);for(let[n,s]of(null!=i&&this.associations.set(t,i),e.children.entries()))r(s,t.children[n])};return r(i,n),n.name+="_instance_"+e.uses[t]++,n}_invokeOne(e){let t=Object.values(this.plugins);t.push(this);for(let i=0;i<t.length;i++){let n=e(t[i]);if(n)return n}return null}_invokeAll(e){let t=Object.values(this.plugins);t.unshift(this);let i=[];for(let n=0;n<t.length;n++){let r=e(t[n]);r&&i.push(r)}return i}/**
	 * Requests the specified dependency asynchronously, with caching.
	 * @param {string} type
	 * @param {number} index
	 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
	 */getDependency(e,t){let i=e+":"+t,n=this.cache.get(i);if(!n){switch(e){case"scene":n=this.loadScene(t);break;case"node":n=this.loadNode(t);break;case"mesh":n=this._invokeOne(function(e){return e.loadMesh&&e.loadMesh(t)});break;case"accessor":n=this.loadAccessor(t);break;case"bufferView":n=this._invokeOne(function(e){return e.loadBufferView&&e.loadBufferView(t)});break;case"buffer":n=this.loadBuffer(t);break;case"material":n=this._invokeOne(function(e){return e.loadMaterial&&e.loadMaterial(t)});break;case"texture":n=this._invokeOne(function(e){return e.loadTexture&&e.loadTexture(t)});break;case"skin":n=this.loadSkin(t);break;case"animation":n=this.loadAnimation(t);break;case"camera":n=this.loadCamera(t);break;default:throw Error("Unknown type: "+e)}this.cache.add(i,n)}return n}/**
	 * Requests all dependencies of the specified type asynchronously, with caching.
	 * @param {string} type
	 * @return {Promise<Array<Object>>}
	 */getDependencies(e){let t=this.cache.get(e);if(!t){let i=this,n=this.json[e+("mesh"===e?"es":"s")]||[];t=Promise.all(n.map(function(t,n){return i.getDependency(e,n)})),this.cache.add(e,t)}return t}/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferIndex
	 * @return {Promise<ArrayBuffer>}
	 */loadBuffer(e){let t=this.json.buffers[e],i=this.fileLoader;if(t.type&&"arraybuffer"!==t.type)throw Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");// If present, GLB container is required to be the first buffer.
if(void 0===t.uri&&0===e)return Promise.resolve(this.extensions[oo.KHR_BINARY_GLTF].body);let n=this.options;return new Promise(function(e,r){i.load(aI.resolveURL(t.uri,n.path),e,void 0,function(){r(Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferViewIndex
	 * @return {Promise<ArrayBuffer>}
	 */loadBufferView(e){let t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(e){let i=t.byteLength||0,n=t.byteOffset||0;return e.slice(n,n+i)})}/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
	 * @param {number} accessorIndex
	 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
	 */loadAccessor(e){let t=this,i=this.json,n=this.json.accessors[e];if(void 0===n.bufferView&&void 0===n.sparse)// information about attributes coming from another source (e.g. Draco
// compression extension).
return Promise.resolve(null);let r=[];return void 0!==n.bufferView?r.push(this.getDependency("bufferView",n.bufferView)):r.push(null),void 0!==n.sparse&&(r.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(r).then(function(e){let r,s;let a=e[0],o=oN[n.type],l=oP[n.componentType],h=l.BYTES_PER_ELEMENT,u=h*o,c=n.byteOffset||0,d=void 0!==n.bufferView?i.bufferViews[n.bufferView].byteStride:void 0,p=!0===n.normalized;// The buffer is not interleaved if the stride is the item size in bytes.
if(d&&d!==u){// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
// This makes sure that IBA.count reflects accessor.count properly
let e=Math.floor(c/d),i="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+e+":"+n.count,u=t.cache.get(i);u||(r=new l(a,e*d,n.count*d/h),// Integer parameters to IB/IBA are in array elements, not bytes.
u=new re(r,d/h),t.cache.add(i,u)),s=new ri(u,o,c%d/h,p)}else r=null===a?new l(n.count*o):new l(a,c,n.count*o),s=new tt(r,o,p);// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
if(void 0!==n.sparse){let t=oN.SCALAR,i=oP[n.sparse.indices.componentType],r=n.sparse.indices.byteOffset||0,h=n.sparse.values.byteOffset||0,u=new i(e[1],r,n.sparse.count*t),c=new l(e[2],h,n.sparse.count*o);null!==a&&(s=new tt(s.array.slice(),s.itemSize,s.normalized));for(let e=0,t=u.length;e<t;e++){let t=u[e];if(s.setX(t,c[e*o]),o>=2&&s.setY(t,c[e*o+1]),o>=3&&s.setZ(t,c[e*o+2]),o>=4&&s.setW(t,c[e*o+3]),o>=5)throw Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return s})}/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
	 * @param {number} textureIndex
	 * @return {Promise<THREE.Texture>}
	 */loadTexture(e){let t=this.json,i=this.options,n=t.textures[e],r=n.source,s=t.images[r],a=this.textureLoader;if(s.uri){let e=i.manager.getHandler(s.uri);null!==e&&(a=e)}return this.loadTextureImage(e,r,a)}loadTextureImage(e,t,i){let n=this,r=this.json,s=r.textures[e],a=r.images[t],o=(a.uri||a.bufferView)+":"+s.sampler;if(this.textureCache[o])return this.textureCache[o];let l=this.loadImageSource(t,i).then(function(t){t.flipY=!1,s.name&&(t.name=s.name);let i=r.samplers||{},a=i[s.sampler]||{};return t.magFilter=oI[a.magFilter]||1006,t.minFilter=oI[a.minFilter]||1008,t.wrapS=oD[a.wrapS]||1e3,t.wrapT=oD[a.wrapT]||1e3,n.associations.set(t,{textures:e}),t}).catch(function(){return null});return this.textureCache[o]=l,l}loadImageSource(e,t){let i=this.json,n=this.options;if(void 0!==this.sourceCache[e])return this.sourceCache[e].then(e=>e.clone());let r=i.images[e],s=self.URL||self.webkitURL,a=r.uri||"",o=!1;if(void 0!==r.bufferView)a=this.getDependency("bufferView",r.bufferView).then(function(e){o=!0;let t=new Blob([e],{type:r.mimeType});return a=s.createObjectURL(t)});else if(void 0===r.uri)throw Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");let l=Promise.resolve(a).then(function(e){return new Promise(function(i,r){let s=i;!0===t.isImageBitmapLoader&&(s=function(e){let t=new B(e);t.needsUpdate=!0,i(t)}),t.load(aI.resolveURL(e,n.path),s,void 0,r)})}).then(function(e){var t;return!0===o&&s.revokeObjectURL(a),e.userData.mimeType=r.mimeType||((t=r.uri).search(/\.jpe?g($|\?)/i)>0||0===t.search(/^data\:image\/jpeg/)?"image/jpeg":t.search(/\.webp($|\?)/i)>0||0===t.search(/^data\:image\/webp/)?"image/webp":"image/png"),e}).catch(function(e){throw console.error("THREE.GLTFLoader: Couldn't load texture",a),e});return this.sourceCache[e]=l,l}/**
	 * Asynchronously assigns a texture to the given material parameters.
	 * @param {Object} materialParams
	 * @param {string} mapName
	 * @param {Object} mapDef
	 * @return {Promise<Texture>}
	 */assignTexture(e,t,i,n){let r=this;return this.getDependency("texture",i.index).then(function(s){if(void 0===i.texCoord||0==i.texCoord||"aoMap"===t&&1==i.texCoord||console.warn("THREE.GLTFLoader: Custom UV set "+i.texCoord+" for texture "+t+" not yet supported."),r.extensions[oo.KHR_TEXTURE_TRANSFORM]){let e=void 0!==i.extensions?i.extensions[oo.KHR_TEXTURE_TRANSFORM]:void 0;if(e){let t=r.associations.get(s);s=r.extensions[oo.KHR_TEXTURE_TRANSFORM].extendTexture(s,e),r.associations.set(s,t)}}return void 0!==n&&(s.encoding=n),e[t]=s,s})}/**
	 * Assigns final material to a Mesh, Line, or Points instance. The instance
	 * already has a material (generated from the glTF material options alone)
	 * but reuse of the same glTF material may require multiple threejs materials
	 * to accommodate different primitive types, defines, etc. New materials will
	 * be created if necessary, and reused from a cache.
	 * @param  {Object3D} mesh Mesh, Line, or Points instance.
	 */assignFinalMaterial(e){let t=e.geometry,i=e.material,n=void 0===t.attributes.tangent,r=void 0!==t.attributes.color,s=void 0===t.attributes.normal;if(e.isPoints){let e="PointsMaterial:"+i.uuid,t=this.cache.get(e);t||(t=new rW,e8.prototype.copy.call(t,i),t.color.copy(i.color),t.map=i.map,t.sizeAttenuation=!1,this.cache.add(e,t)),i=t}else if(e.isLine){let e="LineBasicMaterial:"+i.uuid,t=this.cache.get(e);t||(t=new rD,e8.prototype.copy.call(t,i),t.color.copy(i.color),this.cache.add(e,t)),i=t}// Clone the material if it will be modified
if(n||r||s){let e="ClonedMaterial:"+i.uuid+":";i.isGLTFSpecularGlossinessMaterial&&(e+="specular-glossiness:"),n&&(e+="derivative-tangents:"),r&&(e+="vertex-colors:"),s&&(e+="flat-shading:");let t=this.cache.get(e);t||(t=i.clone(),r&&(t.vertexColors=!0),s&&(t.flatShading=!0),n&&(t.normalScale&&(t.normalScale.y*=-1),t.clearcoatNormalScale&&(t.clearcoatNormalScale.y*=-1)),this.cache.add(e,t),this.associations.set(t,this.associations.get(i))),i=t}i.aoMap&&void 0===t.attributes.uv2&&void 0!==t.attributes.uv&&t.setAttribute("uv2",t.attributes.uv),e.material=i}getMaterialType(){return sY}/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
	 * @param {number} materialIndex
	 * @return {Promise<Material>}
	 */loadMaterial(e){let t;let i=this,n=this.json,r=this.extensions,s=n.materials[e],a={},o=s.extensions||{},l=[];if(o[oo.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){let e=r[oo.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];t=e.getMaterialType(),l.push(e.extendParams(a,s,i))}else if(o[oo.KHR_MATERIALS_UNLIT]){let e=r[oo.KHR_MATERIALS_UNLIT];t=e.getMaterialType(),l.push(e.extendParams(a,s,i))}else{// Specification:
// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material
let n=s.pbrMetallicRoughness||{};if(a.color=new O(1,1,1),a.opacity=1,Array.isArray(n.baseColorFactor)){let e=n.baseColorFactor;a.color.fromArray(e),a.opacity=e[3]}void 0!==n.baseColorTexture&&l.push(i.assignTexture(a,"map",n.baseColorTexture,3001)),a.metalness=void 0!==n.metallicFactor?n.metallicFactor:1,a.roughness=void 0!==n.roughnessFactor?n.roughnessFactor:1,void 0!==n.metallicRoughnessTexture&&(l.push(i.assignTexture(a,"metalnessMap",n.metallicRoughnessTexture)),l.push(i.assignTexture(a,"roughnessMap",n.metallicRoughnessTexture))),t=this._invokeOne(function(t){return t.getMaterialType&&t.getMaterialType(e)}),l.push(Promise.all(this._invokeAll(function(t){return t.extendMaterialParams&&t.extendMaterialParams(e,a)})))}!0===s.doubleSided&&(a.side=2);let h=s.alphaMode||oH.OPAQUE;if(h===oH.BLEND?(a.transparent=!0,// See: https://github.com/mrdoob/three.js/issues/17706
a.depthWrite=!1):(a.transparent=!1,h===oH.MASK&&(a.alphaTest=void 0!==s.alphaCutoff?s.alphaCutoff:.5)),void 0!==s.normalTexture&&t!==e7&&(l.push(i.assignTexture(a,"normalMap",s.normalTexture)),a.normalScale=new b(1,1),void 0!==s.normalTexture.scale)){let e=s.normalTexture.scale;a.normalScale.set(e,e)}return void 0!==s.occlusionTexture&&t!==e7&&(l.push(i.assignTexture(a,"aoMap",s.occlusionTexture)),void 0!==s.occlusionTexture.strength&&(a.aoMapIntensity=s.occlusionTexture.strength)),void 0!==s.emissiveFactor&&t!==e7&&(a.emissive=new O().fromArray(s.emissiveFactor)),void 0!==s.emissiveTexture&&t!==e7&&l.push(i.assignTexture(a,"emissiveMap",s.emissiveTexture,3001)),Promise.all(l).then(function(){let n;return n=t===oS?r[oo.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a):new t(a),s.name&&(n.name=s.name),oB(n,s),i.associations.set(n,{materials:e}),s.extensions&&oF(r,n,s),n})}/** When Object3D instances are targeted by animation, they need unique names. */createUniqueName(e){let t=aX.sanitizeNodeName(e||""),i=t;for(let e=1;this.nodeNamesUsed[i];++e)i=t+"_"+e;return this.nodeNamesUsed[i]=!0,i}/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
	 *
	 * Creates BufferGeometries from primitives.
	 *
	 * @param {Array<GLTF.Primitive>} primitives
	 * @return {Promise<Array<BufferGeometry>>}
	 */loadGeometries(e){let t=this,i=this.extensions,n=this.primitiveCache,r=[];for(let s=0,a=e.length;s<a;s++){let a=e[s],o=function(e){let t=e.extensions&&e.extensions[oo.KHR_DRACO_MESH_COMPRESSION];return t?"draco:"+t.bufferView+":"+t.indices+":"+oG(t.attributes):e.indices+":"+oG(e.attributes)+":"+e.mode}(a),l=n[o];if(l)r.push(l.promise);else{let e;e=a.extensions&&a.extensions[oo.KHR_DRACO_MESH_COMPRESSION]?function(e){return i[oo.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e,t).then(function(i){return oW(i,e,t)})}(a):oW(new td,a,t),// Cache this geometry
n[o]={primitive:a,promise:e},r.push(e)}}return Promise.all(r)}/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
	 * @param {number} meshIndex
	 * @return {Promise<Group|Mesh|SkinnedMesh>}
	 */loadMesh(e){let t=this,i=this.json,n=this.extensions,r=i.meshes[e],s=r.primitives,a=[];for(let e=0,t=s.length;e<t;e++){var o;let t=void 0===s[e].material?(void 0===(o=this.cache).DefaultMaterial&&(o.DefaultMaterial=new sY({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:0})),o.DefaultMaterial):this.getDependency("material",s[e].material);a.push(t)}return a.push(t.loadGeometries(s)),Promise.all(a).then(function(i){let a=i.slice(0,i.length-1),o=i[i.length-1],l=[];for(let i=0,h=o.length;i<h;i++){let h;let u=o[i],c=s[i],d=a[i];if(c.mode===oC.TRIANGLES||c.mode===oC.TRIANGLE_STRIP||c.mode===oC.TRIANGLE_FAN||void 0===c.mode)!0!==// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
(h=!0===r.isSkinnedMesh?new rM(u,d):new tC(u,d)).isSkinnedMesh||h.geometry.attributes.skinWeight.normalized||// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
h.normalizeSkinWeights(),c.mode===oC.TRIANGLE_STRIP?h.geometry=oj(h.geometry,1):c.mode===oC.TRIANGLE_FAN&&(h.geometry=oj(h.geometry,2));else if(c.mode===oC.LINES)h=new rk(u,d);else if(c.mode===oC.LINE_STRIP)h=new rF(u,d);else if(c.mode===oC.LINE_LOOP)h=new rV(u,d);else if(c.mode===oC.POINTS)h=new rJ(u,d);else throw Error("THREE.GLTFLoader: Primitive mode unsupported: "+c.mode);Object.keys(h.geometry.morphAttributes).length>0&&/**
 * @param {Mesh} mesh
 * @param {GLTF.Mesh} meshDef
 */function(e,t){if(e.updateMorphTargets(),void 0!==t.weights)for(let i=0,n=t.weights.length;i<n;i++)e.morphTargetInfluences[i]=t.weights[i];// .extras has user-defined data, so check that .extras.targetNames is an array.
if(t.extras&&Array.isArray(t.extras.targetNames)){let i=t.extras.targetNames;if(e.morphTargetInfluences.length===i.length){e.morphTargetDictionary={};for(let t=0,n=i.length;t<n;t++)e.morphTargetDictionary[i[t]]=t}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}(h,r),h.name=t.createUniqueName(r.name||"mesh_"+e),oB(h,r),c.extensions&&oF(n,h,c),t.assignFinalMaterial(h),l.push(h)}for(let i=0,n=l.length;i<n;i++)t.associations.set(l[i],{meshes:e,primitives:i});if(1===l.length)return l[0];let h=new n0;t.associations.set(h,{meshes:e});for(let e=0,t=l.length;e<t;e++)h.add(l[e]);return h})}/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
	 * @param {number} cameraIndex
	 * @return {Promise<THREE.Camera>}
	 */loadCamera(e){let t;let i=this.json.cameras[e],n=i[i.type];if(!n){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return"perspective"===i.type?t=new tH(_.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):"orthographic"===i.type&&(t=new t8(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),i.name&&(t.name=this.createUniqueName(i.name)),oB(t,i),Promise.resolve(t)}/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
	 * @param {number} skinIndex
	 * @return {Promise<Object>}
	 */loadSkin(e){let t=this.json.skins[e],i={joints:t.joints};return void 0===t.inverseBindMatrices?Promise.resolve(i):this.getDependency("accessor",t.inverseBindMatrices).then(function(e){return i.inverseBindMatrices=e,i})}/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
	 * @param {number} animationIndex
	 * @return {Promise<AnimationClip>}
	 */loadAnimation(e){let t=this.json,i=t.animations[e],n=[],r=[],s=[],a=[],o=[];for(let e=0,t=i.channels.length;e<t;e++){let t=i.channels[e],l=i.samplers[t.sampler],h=t.target,u=void 0!==h.node?h.node:h.id,c=void 0!==i.parameters?i.parameters[l.input]:l.input,d=void 0!==i.parameters?i.parameters[l.output]:l.output;n.push(this.getDependency("node",u)),r.push(this.getDependency("accessor",c)),s.push(this.getDependency("accessor",d)),a.push(l),o.push(h)}return Promise.all([Promise.all(n),Promise.all(r),Promise.all(s),Promise.all(a),Promise.all(o)]).then(function(t){let n=t[0],r=t[1],s=t[2],a=t[3],o=t[4],l=[];for(let e=0,t=n.length;e<t;e++){let t;let i=n[e],h=r[e],u=s[e],c=a[e],d=o[e];if(void 0===i)continue;switch(i.updateMatrix(),i.matrixAutoUpdate=!0,oz[d.path]){case oz.weights:t=at;break;case oz.rotation:t=an;break;case oz.position:case oz.scale:default:t=as}let p=i.name?i.name:i.uuid,m=void 0!==c.interpolation?oU[c.interpolation]:2301,f=[];oz[d.path]===oz.weights?i.traverse(function(e){e.morphTargetInfluences&&f.push(e.name?e.name:e.uuid)}):f.push(p);let g=u.array;if(u.normalized){let e=ok(g.constructor),t=new Float32Array(g.length);for(let i=0,n=g.length;i<n;i++)t[i]=g[i]*e;g=t}for(let e=0,i=f.length;e<i;e++){let i=new t(f[e]+"."+oz[d.path],h.array,g,m);"CUBICSPLINE"===c.interpolation&&(i.createInterpolant=function(e){// A CUBICSPLINE keyframe in glTF has three output values for each input value,
// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
// must be divided by three to get the interpolant's sampleSize argument.
let t=this instanceof an?oL:oA;return new t(this.times,this.values,this.getValueSize()/3,e)},// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),l.push(i)}}let h=i.name?i.name:"animation_"+e;return new aa(h,void 0,l)})}createNodeMesh(e){let t=this.json,i=this,n=t.nodes[e];return void 0===n.mesh?null:i.getDependency("mesh",n.mesh).then(function(e){let t=i._getNodeRef(i.meshCache,n.mesh,e);return void 0!==n.weights&&t.traverse(function(e){if(e.isMesh)for(let t=0,i=n.weights.length;t<i;t++)e.morphTargetInfluences[t]=n.weights[t]}),t})}/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
	 * @param {number} nodeIndex
	 * @return {Promise<Object3D>}
	 */loadNode(e){let t=this.json,i=this.extensions,n=this,r=t.nodes[e],s=r.name?n.createUniqueName(r.name):"";return(function(){let t=[],i=n._invokeOne(function(t){return t.createNodeMesh&&t.createNodeMesh(e)});return i&&t.push(i),void 0!==r.camera&&t.push(n.getDependency("camera",r.camera).then(function(e){return n._getNodeRef(n.cameraCache,r.camera,e)})),n._invokeAll(function(t){return t.createNodeAttachment&&t.createNodeAttachment(e)}).forEach(function(e){t.push(e)}),Promise.all(t)})().then(function(t){let a;if((a=!0===r.isBone?new rw:t.length>1?new n0:1===t.length?t[0]:new eY)!==t[0])for(let e=0,i=t.length;e<i;e++)a.add(t[e]);if(r.name&&(a.userData.name=r.name,a.name=s),oB(a,r),r.extensions&&oF(i,a,r),void 0!==r.matrix){let e=new ew;e.fromArray(r.matrix),a.applyMatrix4(e)}else void 0!==r.translation&&a.position.fromArray(r.translation),void 0!==r.rotation&&a.quaternion.fromArray(r.rotation),void 0!==r.scale&&a.scale.fromArray(r.scale);return n.associations.has(a)||n.associations.set(a,{}),n.associations.get(a).nodes=e,a})}/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
	 * @param {number} sceneIndex
	 * @return {Promise<Group>}
	 */loadScene(e){let t=this.json,i=this.extensions,n=this.json.scenes[e],r=this,s=new n0;n.name&&(s.name=r.createUniqueName(n.name)),oB(s,n),n.extensions&&oF(i,s,n);let a=n.nodes||[],o=[];for(let e=0,i=a.length;e<i;e++)o.push(function e(t,i,n,r){let s=n.nodes[t];return r.getDependency("node",t).then(function(e){let t;return void 0===s.skin?e:r.getDependency("skin",s.skin).then(function(e){t=e;let i=[];for(let e=0,n=t.joints.length;e<n;e++)i.push(r.getDependency("node",t.joints[e]));return Promise.all(i)}).then(function(i){return e.traverse(function(e){if(!e.isMesh)return;let n=[],r=[];for(let e=0,s=i.length;e<s;e++){let s=i[e];if(s){n.push(s);let i=new ew;void 0!==t.inverseBindMatrices&&i.fromArray(t.inverseBindMatrices.array,16*e),r.push(i)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[e])}e.bind(new rA(n,r),e.matrixWorld)}),e})}).then(function(t){// build node hierachy
i.add(t);let a=[];if(s.children){let i=s.children;for(let s=0,o=i.length;s<o;s++){let o=i[s];a.push(e(o,t,n,r))}}return Promise.all(a)})}(a[e],s,t,r));return Promise.all(o).then(function(){return r.associations=(e=>{let t=new Map;for(let[e,i]of r.associations)(e instanceof e8||e instanceof B)&&t.set(e,i);return e.traverse(e=>{let i=r.associations.get(e);null!=i&&t.set(e,i)}),t})(s),s})}}/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */function oW(e,t,i){let n=t.attributes,r=[];for(let t in n){let s=oO[t]||t.toLowerCase();// Skip attributes already provided by e.g. Draco extension.
s in e.attributes||r.push(function(t,n){return i.getDependency("accessor",t).then(function(t){e.setAttribute(n,t)})}(n[t],s))}if(void 0!==t.indices&&!e.index){let n=i.getDependency("accessor",t.indices).then(function(t){e.setIndex(t)});r.push(n)}return oB(e,t),!/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 */function(e,t,i){let n=t.attributes,r=new J;if(void 0===n.POSITION)return;{let e=i.json.accessors[n.POSITION],t=e.min,s=e.max;// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.
if(void 0!==t&&void 0!==s){if(r.set(new q(t[0],t[1],t[2]),new q(s[0],s[1],s[2])),e.normalized){let t=ok(oP[e.componentType]);r.min.multiplyScalar(t),r.max.multiplyScalar(t)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}let s=t.targets;if(void 0!==s){let e=new q,t=new q;for(let n=0,r=s.length;n<r;n++){let r=s[n];if(void 0!==r.POSITION){let n=i.json.accessors[r.POSITION],s=n.min,a=n.max;// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.
if(void 0!==s&&void 0!==a){if(// we need to get max of absolute components because target weight is [-1,1]
t.setX(Math.max(Math.abs(s[0]),Math.abs(a[0]))),t.setY(Math.max(Math.abs(s[1]),Math.abs(a[1]))),t.setZ(Math.max(Math.abs(s[2]),Math.abs(a[2]))),n.normalized){let e=ok(oP[n.componentType]);t.multiplyScalar(e)}// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
// are used to implement key-frame animations and as such only two are active at a time - this results in very large
// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
e.max(t)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
r.expandByVector(e)}e.boundingBox=r;let a=new em;r.getCenter(a.center),a.radius=r.min.distanceTo(r.max)/2,e.boundingSphere=a}(e,t,i),Promise.all(r).then(function(){return void 0!==t.targets?/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
 *
 * @param {BufferGeometry} geometry
 * @param {Array<GLTF.Target>} targets
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */function(e,t,i){let n=!1,r=!1,s=!1;for(let e=0,i=t.length;e<i;e++){let i=t[e];if(void 0!==i.POSITION&&(n=!0),void 0!==i.NORMAL&&(r=!0),void 0!==i.COLOR_0&&(s=!0),n&&r&&s)break}if(!n&&!r&&!s)return Promise.resolve(e);let a=[],o=[],l=[];for(let h=0,u=t.length;h<u;h++){let u=t[h];if(n){let t=void 0!==u.POSITION?i.getDependency("accessor",u.POSITION):e.attributes.position;a.push(t)}if(r){let t=void 0!==u.NORMAL?i.getDependency("accessor",u.NORMAL):e.attributes.normal;o.push(t)}if(s){let t=void 0!==u.COLOR_0?i.getDependency("accessor",u.COLOR_0):e.attributes.color;l.push(t)}}return Promise.all([Promise.all(a),Promise.all(o),Promise.all(l)]).then(function(t){let i=t[0],a=t[1],o=t[2];return n&&(e.morphAttributes.position=i),r&&(e.morphAttributes.normal=a),s&&(e.morphAttributes.color=o),e.morphTargetsRelative=!0,e})}(e,t.targets,i):e})}/**
 * @param {BufferGeometry} geometry
 * @param {Number} drawMode
 * @return {BufferGeometry}
 */function oj(e,t){let i=e.getIndex();// generate index if not present
if(null===i){let t=[],n=e.getAttribute("position");if(void 0===n)return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let e=0;e<n.count;e++)t.push(e);e.setIndex(t),i=e.getIndex()}//
let n=i.count-2,r=[];if(2===t)for(let e=1;e<=n;e++)r.push(i.getX(0)),r.push(i.getX(e)),r.push(i.getX(e+1));else // gl.TRIANGLE_STRIP
for(let e=0;e<n;e++)e%2==0?(r.push(i.getX(e)),r.push(i.getX(e+1)),r.push(i.getX(e+2))):(r.push(i.getX(e+2)),r.push(i.getX(e+1)),r.push(i.getX(e)));r.length/3!==n&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");// build final geometry
let s=e.clone();return s.setIndex(r),s}const oq=new n6({antialias:!0});oq.setSize(window.innerWidth,window.innerHeight),document.body.appendChild(oq.domElement),oq.setClearColor(10724259);const oX=new n9,oY=new tH(45,window.innerWidth/window.innerHeight,.1,1e4),oJ=new class extends l{constructor(e,t){super(),void 0===t&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),t===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=e,this.domElement=t,this.domElement.style.touchAction="none",// Set to false to disable this control
this.enabled=!0,// "target" sets the location of focus, where the object orbits around
this.target=new q,// How far you can dolly in and out ( PerspectiveCamera only )
this.minDistance=0,this.maxDistance=1/0,// How far you can zoom in and out ( OrthographicCamera only )
this.minZoom=0,this.maxZoom=1/0,// How far you can orbit vertically, upper and lower limits.
// Range is 0 to Math.PI radians.
this.minPolarAngle=0,this.maxPolarAngle=Math.PI,// How far you can orbit horizontally, upper and lower limits.
// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,// Set to true to enable damping (inertia)
// If damping is enabled, you must call controls.update() in your animation loop
this.enableDamping=!1,this.dampingFactor=.05,// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
// Set to false to disable zooming
this.enableZoom=!0,this.zoomSpeed=1,// Set to false to disable rotating
this.enableRotate=!0,this.rotateSpeed=1,// Set to false to disable panning
this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,// Set to true to automatically rotate around the target
// If auto-rotate is enabled, you must call controls.update() in your animation loop
this.autoRotate=!1,this.autoRotateSpeed=2,// The four arrow keys
this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},// Mouse buttons
this.mouseButtons={LEFT:n.ROTATE,MIDDLE:n.DOLLY,RIGHT:n.PAN},// Touch fingers
this.touches={ONE:r.ROTATE,TWO:r.DOLLY_PAN},// for reset
this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,// the target DOM element for key events
this._domElementKeyEvents=null,//
// public methods
//
this.getPolarAngle=function(){return l.phi},this.getAzimuthalAngle=function(){return l.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(e){e.addEventListener("keydown",X),this._domElementKeyEvents=e},this.saveState=function(){i.target0.copy(i.target),i.position0.copy(i.object.position),i.zoom0=i.object.zoom},this.reset=function(){i.target.copy(i.target0),i.object.position.copy(i.position0),i.object.zoom=i.zoom0,i.object.updateProjectionMatrix(),i.dispatchEvent(on),i.update(),a=s.NONE},// this method is exposed, but perhaps it would be better if we can make it private...
this.update=function(){let t=new q,n=new j().setFromUnitVectors(e.up,new q(0,1,0)),r=n.clone().invert(),p=new q,m=new j,f=2*Math.PI;return function(){let e=i.object.position;t.copy(e).sub(i.target),// rotate offset to "y-axis-is-up" space
t.applyQuaternion(n),// angle from z-axis around y-axis
l.setFromVector3(t),i.autoRotate&&a===s.NONE&&E(2*Math.PI/60/60*i.autoRotateSpeed),i.enableDamping?(l.theta+=h.theta*i.dampingFactor,l.phi+=h.phi*i.dampingFactor):(l.theta+=h.theta,l.phi+=h.phi);// restrict theta to be between desired limits
let g=i.minAzimuthAngle,v=i.maxAzimuthAngle;return(// update condition is:
// min(camera displacement, camera rotation in radians)^2 > EPS
// using small-angle approximation cos(x/2) = 1 - x^2 / 8
isFinite(g)&&isFinite(v)&&(g<-Math.PI?g+=f:g>Math.PI&&(g-=f),v<-Math.PI?v+=f:v>Math.PI&&(v-=f),g<=v?l.theta=Math.max(g,Math.min(v,l.theta)):l.theta=l.theta>(g+v)/2?Math.max(g,l.theta):Math.min(v,l.theta)),// restrict phi to be between desired limits
l.phi=Math.max(i.minPolarAngle,Math.min(i.maxPolarAngle,l.phi)),l.makeSafe(),l.radius*=u,// restrict radius to be between desired limits
l.radius=Math.max(i.minDistance,Math.min(i.maxDistance,l.radius)),!0===i.enableDamping?i.target.addScaledVector(c,i.dampingFactor):i.target.add(c),t.setFromSpherical(l),// rotate offset back to "camera-up-vector-is-up" space
t.applyQuaternion(r),e.copy(i.target).add(t),i.object.lookAt(i.target),!0===i.enableDamping?(h.theta*=1-i.dampingFactor,h.phi*=1-i.dampingFactor,c.multiplyScalar(1-i.dampingFactor)):(h.set(0,0,0),c.set(0,0,0)),u=1,!!(d||p.distanceToSquared(i.object.position)>o||8*(1-m.dot(i.object.quaternion))>o)&&(i.dispatchEvent(on),p.copy(i.object.position),m.copy(i.object.quaternion),d=!1,!0))}}(),this.dispose=function(){i.domElement.removeEventListener("contextmenu",Y),i.domElement.removeEventListener("pointerdown",B),i.domElement.removeEventListener("pointercancel",V),i.domElement.removeEventListener("wheel",W),i.domElement.removeEventListener("pointermove",G),i.domElement.removeEventListener("pointerup",k),null!==i._domElementKeyEvents&&i._domElementKeyEvents.removeEventListener("keydown",X);//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
};//
// internals
//
let i=this,s={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6},a=s.NONE,o=1e-6,l=new aZ,h=new aZ,u=1,c=new q,d=!1,p=new b,m=new b,f=new b,g=new b,v=new b,x=new b,y=new b,_=new b,M=new b,w=[],S={};function T(){return Math.pow(.95,i.zoomSpeed)}function E(e){h.theta-=e}let A=function(){let e=new q;return function(t,i){e.setFromMatrixColumn(i,0),e.multiplyScalar(-t),c.add(e)}}(),R=function(){let e=new q;return function(t,n){!0===i.screenSpacePanning?e.setFromMatrixColumn(n,1):(e.setFromMatrixColumn(n,0),e.crossVectors(i.object.up,e)),e.multiplyScalar(t),c.add(e)}}(),L=function(){let e=new q;return function(t,n){let r=i.domElement;if(i.object.isPerspectiveCamera){// perspective
let s=i.object.position;e.copy(s).sub(i.target);let a=e.length();// we use only clientHeight here so aspect ratio does not distort speed
A(2*t*// half of the fov is center to top of screen
(a*=Math.tan(i.object.fov/2*Math.PI/180))/r.clientHeight,i.object.matrix),R(2*n*a/r.clientHeight,i.object.matrix)}else i.object.isOrthographicCamera?(// orthographic
A(t*(i.object.right-i.object.left)/i.object.zoom/r.clientWidth,i.object.matrix),R(n*(i.object.top-i.object.bottom)/i.object.zoom/r.clientHeight,i.object.matrix)):(// camera neither orthographic nor perspective
console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),i.enablePan=!1)}}();function C(e){i.object.isPerspectiveCamera?u/=e:i.object.isOrthographicCamera?(i.object.zoom=Math.max(i.minZoom,Math.min(i.maxZoom,i.object.zoom*e)),i.object.updateProjectionMatrix(),d=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),i.enableZoom=!1)}function P(e){i.object.isPerspectiveCamera?u*=e:i.object.isOrthographicCamera?(i.object.zoom=Math.max(i.minZoom,Math.min(i.maxZoom,i.object.zoom/e)),i.object.updateProjectionMatrix(),d=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),i.enableZoom=!1)}//
// event callbacks - update the object state
//
function I(e){p.set(e.clientX,e.clientY)}function D(e){g.set(e.clientX,e.clientY)}function N(){if(1===w.length)p.set(w[0].pageX,w[0].pageY);else{let e=.5*(w[0].pageX+w[1].pageX),t=.5*(w[0].pageY+w[1].pageY);p.set(e,t)}}function O(){if(1===w.length)g.set(w[0].pageX,w[0].pageY);else{let e=.5*(w[0].pageX+w[1].pageX),t=.5*(w[0].pageY+w[1].pageY);g.set(e,t)}}function z(){let e=w[0].pageX-w[1].pageX,t=w[0].pageY-w[1].pageY;y.set(0,Math.sqrt(e*e+t*t))}function U(e){var t;if(1==w.length)m.set(e.pageX,e.pageY);else{let t=K(e),i=.5*(e.pageX+t.x),n=.5*(e.pageY+t.y);m.set(i,n)}f.subVectors(m,p).multiplyScalar(i.rotateSpeed);let n=i.domElement;E(2*Math.PI*f.x/n.clientHeight),t=2*Math.PI*f.y/n.clientHeight,h.phi-=t,p.copy(m)}function H(e){if(1===w.length)v.set(e.pageX,e.pageY);else{let t=K(e),i=.5*(e.pageX+t.x),n=.5*(e.pageY+t.y);v.set(i,n)}x.subVectors(v,g).multiplyScalar(i.panSpeed),L(x.x,x.y),g.copy(v)}function F(e){let t=K(e),n=e.pageX-t.x,r=e.pageY-t.y;_.set(0,Math.sqrt(n*n+r*r)),M.set(0,Math.pow(_.y/y.y,i.zoomSpeed)),C(M.y),y.copy(_)}//
// event handlers - FSM: listen for events and reset state
//
function B(e){!1!==i.enabled&&(0===w.length&&(i.domElement.setPointerCapture(e.pointerId),i.domElement.addEventListener("pointermove",G),i.domElement.addEventListener("pointerup",k)),w.push(e),"touch"===e.pointerType?function(e){switch(Z(e),w.length){case 1:switch(i.touches.ONE){case r.ROTATE:if(!1===i.enableRotate)return;N(),a=s.TOUCH_ROTATE;break;case r.PAN:if(!1===i.enablePan)return;O(),a=s.TOUCH_PAN;break;default:a=s.NONE}break;case 2:switch(i.touches.TWO){case r.DOLLY_PAN:if(!1===i.enableZoom&&!1===i.enablePan)return;i.enableZoom&&z(),i.enablePan&&O(),a=s.TOUCH_DOLLY_PAN;break;case r.DOLLY_ROTATE:if(!1===i.enableZoom&&!1===i.enableRotate)return;i.enableZoom&&z(),i.enableRotate&&N(),a=s.TOUCH_DOLLY_ROTATE;break;default:a=s.NONE}break;default:a=s.NONE}a!==s.NONE&&i.dispatchEvent(or)}(e):function(e){let t;switch(e.button){case 0:t=i.mouseButtons.LEFT;break;case 1:t=i.mouseButtons.MIDDLE;break;case 2:t=i.mouseButtons.RIGHT;break;default:t=-1}switch(t){case n.DOLLY:if(!1===i.enableZoom)return;y.set(e.clientX,e.clientY),a=s.DOLLY;break;case n.ROTATE:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===i.enablePan)return;D(e),a=s.PAN}else{if(!1===i.enableRotate)return;I(e),a=s.ROTATE}break;case n.PAN:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===i.enableRotate)return;I(e),a=s.ROTATE}else{if(!1===i.enablePan)return;D(e),a=s.PAN}break;default:a=s.NONE}a!==s.NONE&&i.dispatchEvent(or)}(e))}function G(e){!1!==i.enabled&&("touch"===e.pointerType?function(e){switch(Z(e),a){case s.TOUCH_ROTATE:if(!1===i.enableRotate)return;U(e),i.update();break;case s.TOUCH_PAN:if(!1===i.enablePan)return;H(e),i.update();break;case s.TOUCH_DOLLY_PAN:if(!1===i.enableZoom&&!1===i.enablePan)return;i.enableZoom&&F(e),i.enablePan&&H(e),i.update();break;case s.TOUCH_DOLLY_ROTATE:if(!1===i.enableZoom&&!1===i.enableRotate)return;i.enableZoom&&F(e),i.enableRotate&&U(e),i.update();break;default:a=s.NONE}}(e):function(e){if(!1!==i.enabled)switch(a){case s.ROTATE:if(!1===i.enableRotate)return;!function(e){var t;m.set(e.clientX,e.clientY),f.subVectors(m,p).multiplyScalar(i.rotateSpeed);let n=i.domElement;E(2*Math.PI*f.x/n.clientHeight),t=2*Math.PI*f.y/n.clientHeight,h.phi-=t,p.copy(m),i.update()}(e);break;case s.DOLLY:if(!1===i.enableZoom)return;_.set(e.clientX,e.clientY),M.subVectors(_,y),M.y>0?C(T()):M.y<0&&P(T()),y.copy(_),i.update();break;case s.PAN:if(!1===i.enablePan)return;v.set(e.clientX,e.clientY),x.subVectors(v,g).multiplyScalar(i.panSpeed),L(x.x,x.y),g.copy(v),i.update()}}(e))}function k(e){J(e),0===w.length&&(i.domElement.releasePointerCapture(e.pointerId),i.domElement.removeEventListener("pointermove",G),i.domElement.removeEventListener("pointerup",k)),i.dispatchEvent(os),a=s.NONE}function V(e){J(e)}function W(e){!1!==i.enabled&&!1!==i.enableZoom&&a===s.NONE&&(e.preventDefault(),i.dispatchEvent(or),e.deltaY<0?P(T()):e.deltaY>0&&C(T()),i.update(),i.dispatchEvent(os))}function X(e){!1!==i.enabled&&!1!==i.enablePan&&function(e){let t=!1;switch(e.code){case i.keys.UP:L(0,i.keyPanSpeed),t=!0;break;case i.keys.BOTTOM:L(0,-i.keyPanSpeed),t=!0;break;case i.keys.LEFT:L(i.keyPanSpeed,0),t=!0;break;case i.keys.RIGHT:L(-i.keyPanSpeed,0),t=!0}t&&(// prevent the browser from scrolling on cursor keys
e.preventDefault(),i.update())}(e)}function Y(e){!1!==i.enabled&&e.preventDefault()}function J(e){delete S[e.pointerId];for(let t=0;t<w.length;t++)if(w[t].pointerId==e.pointerId){w.splice(t,1);return}}function Z(e){let t=S[e.pointerId];void 0===t&&(t=new b,S[e.pointerId]=t),t.set(e.pageX,e.pageY)}function K(e){let t=e.pointerId===w[0].pointerId?w[1]:w[0];return S[t.pointerId]}//
i.domElement.addEventListener("contextmenu",Y),i.domElement.addEventListener("pointerdown",B),i.domElement.addEventListener("pointercancel",V),i.domElement.addEventListener("wheel",W,{passive:!1}),// force an update at start
this.update()}}(oY,oq.domElement);oY.position.set(-4e3,700,100),oJ.update();// const grid = new THREE.GridHelper(30,30)
// scene.add(grid)
const oZ=new class extends ah{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(e){return new ou(e)}),this.register(function(e){return new og(e)}),this.register(function(e){return new ov(e)}),this.register(function(e){return new oc(e)}),this.register(function(e){return new od(e)}),this.register(function(e){return new op(e)}),this.register(function(e){return new om(e)}),this.register(function(e){return new of(e)}),this.register(function(e){return new ol(e)}),this.register(function(e){return new ox(e)})}load(e,t,i,n){let r;let s=this;r=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:aI.extractUrlBase(e),// Tells the LoadingManager to track an extra item, which resolves after
// the model is fully loaded. This means the count of items loaded will
// be incorrect, but ensures manager.onLoad() does not fire early.
this.manager.itemStart(e);let a=function(t){n?n(t):console.error(t),s.manager.itemError(e),s.manager.itemEnd(e)},o=new ac(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(i){try{s.parse(i,r,function(i){t(i),s.manager.itemEnd(e)},a)}catch(e){a(e)}},i,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return -1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this}unregister(e){return -1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,i,n){let r;let s={},a={};if("string"==typeof e)r=e;else{let t=aI.decodeText(new Uint8Array(e,0,4));if(t===oy){try{s[oo.KHR_BINARY_GLTF]=new ob(e)}catch(e){n&&n(e);return}r=s[oo.KHR_BINARY_GLTF].content}else r=aI.decodeText(new Uint8Array(e))}let o=JSON.parse(r);if(void 0===o.asset||o.asset.version[0]<2){n&&n(Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}let l=new oV(o,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let e=0;e<this.pluginCallbacks.length;e++){let t=this.pluginCallbacks[e](l);a[t.name]=t,// Workaround to avoid determining as unknown extension
// in addUnknownExtensionsToUserData().
// Remove this workaround if we move all the existing
// extension handlers to plugin system
s[t.name]=!0}if(o.extensionsUsed)for(let e=0;e<o.extensionsUsed.length;++e){let t=o.extensionsUsed[e],i=o.extensionsRequired||[];switch(t){case oo.KHR_MATERIALS_UNLIT:s[t]=new oh;break;case oo.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:s[t]=new oT;break;case oo.KHR_DRACO_MESH_COMPRESSION:s[t]=new oM(o,this.dracoLoader);break;case oo.KHR_TEXTURE_TRANSFORM:s[t]=new ow;break;case oo.KHR_MESH_QUANTIZATION:s[t]=new oE;break;default:i.indexOf(t)>=0&&void 0===a[t]&&console.warn('THREE.GLTFLoader: Unknown extension "'+t+'".')}}l.setExtensions(s),l.setPlugins(a),l.parse(i,n)}parseAsync(e,t){let i=this;return new Promise(function(n,r){i.parse(e,t,n,r)})}},oK=new // https://github.com/mrdoob/three.js/issues/5552
// http://en.wikipedia.org/wiki/RGBE_image_format
class extends am{constructor(e){super(e),this.type=1016}// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
parse(e){let t=function(e,t){switch(e){case 1:console.error("THREE.RGBELoader Read Error: "+(t||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(t||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(t||""));break;default:console.error("THREE.RGBELoader: Error: "+(t||""))}return -1},i=function(e,t,i){t=t||1024;let n=e.pos,r=-1,s=0,a="",o=String.fromCharCode.apply(null,new Uint16Array(e.subarray(n,n+128)));for(;0>(r=o.indexOf("\n"))&&s<t&&n<e.byteLength;)a+=o,s+=o.length,n+=128,o+=String.fromCharCode.apply(null,new Uint16Array(e.subarray(n,n+128)));return -1<r&&(!1!==i&&(e.pos+=s+r+1),a+o.slice(0,r))},n=new Uint8Array(e);n.pos=0;let r=function(e){let n,r;// regexes to parse header info fields
let s=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,o=/^\s*FORMAT=(\S+)\s*$/,l=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,h={valid:0,/* indicate which fields are valid */string:"",/* the actual header string */comments:"",/* comments found in header */programtype:"RGBE",/* listed at beginning of file to identify it after "#?". defaults to "RGBE" */format:"",/* RGBE format, default 32-bit_rle_rgbe */gamma:1,/* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */exposure:1,/* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */width:0,height:0/* image dimensions, width/height */};if(e.pos>=e.byteLength||!(n=i(e)))return t(1,"no header found");/* if you want to require the magic token then uncomment the next line */if(!(r=n.match(/^#\?(\S+)/)))return t(3,"bad initial token");for(h.valid|=1,h.programtype=r[1],h.string+=n+"\n";!1!==(n=i(e));){if(h.string+=n+"\n","#"===n.charAt(0)){h.comments+=n+"\n";continue;// comment line
}if((r=n.match(s))&&(h.gamma=parseFloat(r[1])),(r=n.match(a))&&(h.exposure=parseFloat(r[1])),(r=n.match(o))&&(h.valid|=2,h.format=r[1]),(r=n.match(l))&&(h.valid|=4,h.height=parseInt(r[1],10),h.width=parseInt(r[2],10)),2&h.valid&&4&h.valid)break}return 2&h.valid?4&h.valid?h:t(3,"missing image size specifier"):t(3,"missing format specifier")}(n);if(-1!==r){let e=r.width,i=r.height,s=function(e,i,n){if(i<8||i>32767||// this file is not run length encoded
2!==e[0]||2!==e[1]||128&e[2])return new Uint8Array(e);if(i!==(e[2]<<8|e[3]))return t(3,"wrong scanline width");let r=new Uint8Array(4*i*n);if(!r.length)return t(4,"unable to allocate buffer space");let s=0,a=0,o=4*i,l=new Uint8Array(4),h=new Uint8Array(o),u=n;// read in each successive scanline
for(;u>0&&a<e.byteLength;){if(a+4>e.byteLength)return t(1);if(l[0]=e[a++],l[1]=e[a++],l[2]=e[a++],l[3]=e[a++],2!=l[0]||2!=l[1]||(l[2]<<8|l[3])!=i)return t(3,"bad rgbe scanline format");// read each of the four channels for the scanline into the buffer
// first red, then green, then blue, then exponent
let n=0,c;for(;n<o&&a<e.byteLength;){c=e[a++];let i=c>128;if(i&&(c-=128),0===c||n+c>o)return t(3,"bad scanline data");if(i){// a (encoded) run of the same value
let t=e[a++];for(let e=0;e<c;e++)h[n++]=t;//ptr += count;
}else // a literal-run
h.set(e.subarray(a,a+c),n),n+=c,a+=c}for(let e=0;e<i;e++){let t=0;r[s]=h[e+t],t+=i,r[s+1]=h[e+t],t+=i,r[s+2]=h[e+t],t+=i,r[s+3]=h[e+t],s+=4}u--}return r}(n.subarray(n.pos),e,i);if(-1!==s){let t,n,a,o;switch(this.type){case 1015:o=s.length/4;let l=new Float32Array(4*o);for(let e=0;e<o;e++)!function(e,t,i,n){let r=e[t+3],s=Math.pow(2,r-128)/255;i[n+0]=e[t+0]*s,i[n+1]=e[t+1]*s,i[n+2]=e[t+2]*s,i[n+3]=1}(s,4*e,l,4*e);t=l,a=1015;break;case 1016:o=s.length/4;let h=new Uint16Array(4*o);for(let e=0;e<o;e++)!function(e,t,i,n){let r=e[t+3],s=Math.pow(2,r-128)/255;// clamping to 65504, the maximum representable value in float16
i[n+0]=a4.toHalfFloat(Math.min(e[t+0]*s,65504)),i[n+1]=a4.toHalfFloat(Math.min(e[t+1]*s,65504)),i[n+2]=a4.toHalfFloat(Math.min(e[t+2]*s,65504)),i[n+3]=a4.toHalfFloat(1)}(s,4*e,h,4*e);t=h,a=1016;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type)}return{width:e,height:i,data:t,header:r.string,gamma:r.gamma,exposure:r.exposure,format:n,type:a}}}return null}setDataType(e){return this.type=e,this}load(e,t,i,n){return super.load(e,function(e,i){switch(e.type){case 1015:case 1016:e.encoding=3e3,e.minFilter=1006,e.magFilter=1006,e.generateMipmaps=!1,e.flipY=!0}t&&t(e,i)},i,n)}};oq.toneMapping=4,oq.toneMappingExposure=4,oK.load("./assets/hdr/MR_INT-005_WhiteNeons_NAD.hdr",e=>{e.mapping=303,oX.environment=e,oZ.load("./assets/dae_villages__ancient_egyptian_scroll_maker/scene.gltf",e=>{oX.add(e.scene)})}),oq.setAnimationLoop(function(){oq.render(oX,oY)}),window.addEventListener("resize",function(){oY.aspect=window.innerWidth/window.innerHeight,oY.updateProjectionMatrix(),oq.setSize(window.innerWidth,window.innerHeight)});//# sourceMappingURL=index.21e775f1.js.map

//# sourceMappingURL=index.21e775f1.js.map
